// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import '../utils/error.dart';
import 'bolt11.dart';
import 'bolt12.dart';
import 'graph.dart';
import 'on_chain.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'spontaneous.dart';
import 'types.dart';

// Rust type: RustOpaqueNom<Node>
abstract class Node implements RustOpaqueInterface {}

class LdkNode {
  final Node ptr;

  const LdkNode({
    required this.ptr,
  });

  static Future<LdkBolt11Payment> bolt11Payment({required LdkNode ptr}) =>
      core.instance.api.crateApiNodeLdkNodeBolt11Payment(ptr: ptr);

  static Future<LdkBolt12Payment> bolt12Payment({required LdkNode ptr}) =>
      core.instance.api.crateApiNodeLdkNodeBolt12Payment(ptr: ptr);

  Future<void> closeChannel(
          {required UserChannelId userChannelId,
          required PublicKey counterpartyNodeId}) =>
      core.instance.api.crateApiNodeLdkNodeCloseChannel(
          that: this,
          userChannelId: userChannelId,
          counterpartyNodeId: counterpartyNodeId);

  Future<Config> config() => core.instance.api.crateApiNodeLdkNodeConfig(
        that: this,
      );

  Future<void> connect(
          {required PublicKey nodeId,
          required SocketAddress address,
          required bool persist}) =>
      core.instance.api.crateApiNodeLdkNodeConnect(
          that: this, nodeId: nodeId, address: address, persist: persist);

  Future<UserChannelId> connectOpenChannel(
          {required SocketAddress socketAddress,
          required PublicKey nodeId,
          required BigInt channelAmountSats,
          BigInt? pushToCounterpartyMsat,
          required bool announceChannel,
          ChannelConfig? channelConfig}) =>
      core.instance.api.crateApiNodeLdkNodeConnectOpenChannel(
          that: this,
          socketAddress: socketAddress,
          nodeId: nodeId,
          channelAmountSats: channelAmountSats,
          pushToCounterpartyMsat: pushToCounterpartyMsat,
          announceChannel: announceChannel,
          channelConfig: channelConfig);

  Future<void> disconnect({required PublicKey counterpartyNodeId}) =>
      core.instance.api.crateApiNodeLdkNodeDisconnect(
          that: this, counterpartyNodeId: counterpartyNodeId);

  Future<void> eventHandled() =>
      core.instance.api.crateApiNodeLdkNodeEventHandled(
        that: this,
      );

  Future<void> forceCloseChannel(
          {required UserChannelId userChannelId,
          required PublicKey counterpartyNodeId}) =>
      core.instance.api.crateApiNodeLdkNodeForceCloseChannel(
          that: this,
          userChannelId: userChannelId,
          counterpartyNodeId: counterpartyNodeId);

  Future<BalanceDetails> listBalances() =>
      core.instance.api.crateApiNodeLdkNodeListBalances(
        that: this,
      );

  Future<List<ChannelDetails>> listChannels() =>
      core.instance.api.crateApiNodeLdkNodeListChannels(
        that: this,
      );

  Future<List<PaymentDetails>> listPayments() =>
      core.instance.api.crateApiNodeLdkNodeListPayments(
        that: this,
      );

  Future<List<PaymentDetails>> listPaymentsWithFilter(
          {required PaymentDirection paymentDirection}) =>
      core.instance.api.crateApiNodeLdkNodeListPaymentsWithFilter(
          that: this, paymentDirection: paymentDirection);

  Future<List<PeerDetails>> listPeers() =>
      core.instance.api.crateApiNodeLdkNodeListPeers(
        that: this,
      );

  Future<List<SocketAddress>?> listeningAddresses() =>
      core.instance.api.crateApiNodeLdkNodeListeningAddresses(
        that: this,
      );

  Future<LdkNetworkGraph> networkGraph() =>
      core.instance.api.crateApiNodeLdkNodeNetworkGraph(
        that: this,
      );

  Future<Event?> nextEvent() => core.instance.api.crateApiNodeLdkNodeNextEvent(
        that: this,
      );

  Future<Event> nextEventAsync() =>
      core.instance.api.crateApiNodeLdkNodeNextEventAsync(
        that: this,
      );

  Future<PublicKey> nodeId() => core.instance.api.crateApiNodeLdkNodeNodeId(
        that: this,
      );

  static Future<LdkOnChainPayment> onChainPayment({required LdkNode ptr}) =>
      core.instance.api.crateApiNodeLdkNodeOnChainPayment(ptr: ptr);

  Future<PaymentDetails?> payment({required PaymentId paymentId}) =>
      core.instance.api
          .crateApiNodeLdkNodePayment(that: this, paymentId: paymentId);

  Future<void> removePayment({required PaymentId paymentId}) =>
      core.instance.api
          .crateApiNodeLdkNodeRemovePayment(that: this, paymentId: paymentId);

  Future<String> signMessage({required List<int> msg}) =>
      core.instance.api.crateApiNodeLdkNodeSignMessage(that: this, msg: msg);

  static Future<LdkSpontaneousPayment> spontaneousPayment(
          {required LdkNode ptr}) =>
      core.instance.api.crateApiNodeLdkNodeSpontaneousPayment(ptr: ptr);

  Future<void> start() => core.instance.api.crateApiNodeLdkNodeStart(
        that: this,
      );

  Future<NodeStatus> status() => core.instance.api.crateApiNodeLdkNodeStatus(
        that: this,
      );

  Future<void> stop() => core.instance.api.crateApiNodeLdkNodeStop(
        that: this,
      );

  Future<void> syncWallets() =>
      core.instance.api.crateApiNodeLdkNodeSyncWallets(
        that: this,
      );

  Future<void> updateChannelConfig(
          {required UserChannelId userChannelId,
          required PublicKey counterpartyNodeId,
          required ChannelConfig channelConfig}) =>
      core.instance.api.crateApiNodeLdkNodeUpdateChannelConfig(
          that: this,
          userChannelId: userChannelId,
          counterpartyNodeId: counterpartyNodeId,
          channelConfig: channelConfig);

  Future<bool> verifySignature(
          {required List<int> msg,
          required String sig,
          required PublicKey publicKey}) =>
      core.instance.api.crateApiNodeLdkNodeVerifySignature(
          that: this, msg: msg, sig: sig, publicKey: publicKey);

  Future<Event> waitNextEvent() =>
      core.instance.api.crateApiNodeLdkNodeWaitNextEvent(
        that: this,
      );

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LdkNode && runtimeType == other.runtimeType && ptr == other.ptr;
}
