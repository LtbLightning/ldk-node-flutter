// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import '../utils/error.dart';
import 'bolt11.dart';
import 'bolt12.dart';
import 'builder.dart';
import 'graph.dart';
import 'on_chain.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'spontaneous.dart';
import 'types.dart';
import 'unified_qr.dart';

class FfiNode {
  final Node opaque;

  const FfiNode({
    required this.opaque,
  });

  static Future<FfiBolt11Payment> bolt11Payment({required FfiNode ptr}) =>
      core.instance.api.crateApiNodeFfiNodeBolt11Payment(ptr: ptr);

  static Future<FfiBolt12Payment> bolt12Payment({required FfiNode ptr}) =>
      core.instance.api.crateApiNodeFfiNodeBolt12Payment(ptr: ptr);

  Future<void> closeChannel(
          {required UserChannelId userChannelId,
          required PublicKey counterpartyNodeId}) =>
      core.instance.api.crateApiNodeFfiNodeCloseChannel(
          that: this,
          userChannelId: userChannelId,
          counterpartyNodeId: counterpartyNodeId);

  Future<Config> config() => core.instance.api.crateApiNodeFfiNodeConfig(
        that: this,
      );

  Future<void> connect(
          {required PublicKey nodeId,
          required SocketAddress address,
          required bool persist}) =>
      core.instance.api.crateApiNodeFfiNodeConnect(
          that: this, nodeId: nodeId, address: address, persist: persist);

  Future<void> disconnect({required PublicKey counterpartyNodeId}) =>
      core.instance.api.crateApiNodeFfiNodeDisconnect(
          that: this, counterpartyNodeId: counterpartyNodeId);

  Future<void> eventHandled() =>
      core.instance.api.crateApiNodeFfiNodeEventHandled(
        that: this,
      );

  Future<void> forceCloseChannel(
          {required UserChannelId userChannelId,
          required PublicKey counterpartyNodeId}) =>
      core.instance.api.crateApiNodeFfiNodeForceCloseChannel(
          that: this,
          userChannelId: userChannelId,
          counterpartyNodeId: counterpartyNodeId);

  Future<BalanceDetails> listBalances() =>
      core.instance.api.crateApiNodeFfiNodeListBalances(
        that: this,
      );

  Future<List<ChannelDetails>> listChannels() =>
      core.instance.api.crateApiNodeFfiNodeListChannels(
        that: this,
      );

  Future<List<PaymentDetails>> listPayments() =>
      core.instance.api.crateApiNodeFfiNodeListPayments(
        that: this,
      );

  Future<List<PaymentDetails>> listPaymentsWithFilter(
          {required PaymentDirection paymentDirection}) =>
      core.instance.api.crateApiNodeFfiNodeListPaymentsWithFilter(
          that: this, paymentDirection: paymentDirection);

  Future<List<PeerDetails>> listPeers() =>
      core.instance.api.crateApiNodeFfiNodeListPeers(
        that: this,
      );

  Future<List<SocketAddress>?> listeningAddresses() =>
      core.instance.api.crateApiNodeFfiNodeListeningAddresses(
        that: this,
      );

  static Future<FfiNetworkGraph> networkGraph({required FfiNode ptr}) =>
      core.instance.api.crateApiNodeFfiNodeNetworkGraph(ptr: ptr);

  Future<Event?> nextEvent() => core.instance.api.crateApiNodeFfiNodeNextEvent(
        that: this,
      );

  Future<Event> nextEventAsync() =>
      core.instance.api.crateApiNodeFfiNodeNextEventAsync(
        that: this,
      );

  Future<PublicKey> nodeId() => core.instance.api.crateApiNodeFfiNodeNodeId(
        that: this,
      );

  static Future<FfiOnChainPayment> onChainPayment({required FfiNode ptr}) =>
      core.instance.api.crateApiNodeFfiNodeOnChainPayment(ptr: ptr);

  Future<UserChannelId> openAnnouncedChannel(
          {required SocketAddress socketAddress,
          required PublicKey nodeId,
          required BigInt channelAmountSats,
          BigInt? pushToCounterpartyMsat,
          ChannelConfig? channelConfig}) =>
      core.instance.api.crateApiNodeFfiNodeOpenAnnouncedChannel(
          that: this,
          socketAddress: socketAddress,
          nodeId: nodeId,
          channelAmountSats: channelAmountSats,
          pushToCounterpartyMsat: pushToCounterpartyMsat,
          channelConfig: channelConfig);

  Future<UserChannelId> openChannel(
          {required SocketAddress socketAddress,
          required PublicKey nodeId,
          required BigInt channelAmountSats,
          BigInt? pushToCounterpartyMsat,
          ChannelConfig? channelConfig}) =>
      core.instance.api.crateApiNodeFfiNodeOpenChannel(
          that: this,
          socketAddress: socketAddress,
          nodeId: nodeId,
          channelAmountSats: channelAmountSats,
          pushToCounterpartyMsat: pushToCounterpartyMsat,
          channelConfig: channelConfig);

  Future<PaymentDetails?> payment({required PaymentId paymentId}) =>
      core.instance.api
          .crateApiNodeFfiNodePayment(that: this, paymentId: paymentId);

  Future<void> removePayment({required PaymentId paymentId}) =>
      core.instance.api
          .crateApiNodeFfiNodeRemovePayment(that: this, paymentId: paymentId);

  Future<String> signMessage({required List<int> msg}) =>
      core.instance.api.crateApiNodeFfiNodeSignMessage(that: this, msg: msg);

  static Future<FfiSpontaneousPayment> spontaneousPayment(
          {required FfiNode ptr}) =>
      core.instance.api.crateApiNodeFfiNodeSpontaneousPayment(ptr: ptr);

  Future<void> start() => core.instance.api.crateApiNodeFfiNodeStart(
        that: this,
      );

  Future<NodeStatus> status() => core.instance.api.crateApiNodeFfiNodeStatus(
        that: this,
      );

  Future<void> stop() => core.instance.api.crateApiNodeFfiNodeStop(
        that: this,
      );

  Future<void> syncWallets() =>
      core.instance.api.crateApiNodeFfiNodeSyncWallets(
        that: this,
      );

  static Future<FfiUnifiedQrPayment> unifiedQrPayment({required FfiNode ptr}) =>
      core.instance.api.crateApiNodeFfiNodeUnifiedQrPayment(ptr: ptr);

  Future<void> updateChannelConfig(
          {required UserChannelId userChannelId,
          required PublicKey counterpartyNodeId,
          required ChannelConfig channelConfig}) =>
      core.instance.api.crateApiNodeFfiNodeUpdateChannelConfig(
          that: this,
          userChannelId: userChannelId,
          counterpartyNodeId: counterpartyNodeId,
          channelConfig: channelConfig);

  Future<bool> verifySignature(
          {required List<int> msg,
          required String sig,
          required PublicKey publicKey}) =>
      core.instance.api.crateApiNodeFfiNodeVerifySignature(
          that: this, msg: msg, sig: sig, publicKey: publicKey);

  Future<Event> waitNextEvent() =>
      core.instance.api.crateApiNodeFfiNodeWaitNextEvent(
        that: this,
      );

  @override
  int get hashCode => opaque.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiNode &&
          runtimeType == other.runtimeType &&
          opaque == other.opaque;
}
