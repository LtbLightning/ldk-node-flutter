// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'builder.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `hash`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`

/// A Bitcoin address.
///
class Address {
  final String s;

  const Address({
    required this.s,
  });

  @override
  int get hashCode => s.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Address && runtimeType == other.runtimeType && s == other.s;
}

/// Configuration options pertaining to 'Anchor' channels, i.e., channels for which the
/// `optionAnchorsZeroFeeHtlcTx` channel type is negotiated.
///
/// Prior to the introduction of Anchor channels, the on-chain fees paying for the transactions
/// issued on channel closure were pre-determined and locked-in at the time of the channel
/// opening. This required to estimate what fee rate would be sufficient to still have the
/// closing transactions be spendable on-chain (i.e., not be considered dust). This legacy
/// design of pre-anchor channels proved inadequate in the unpredictable, often turbulent, fee
/// markets we experience today.
///
/// In contrast, Anchor channels allow to determine an adequate fee rate *at the time of channel
/// closure*, making them much more robust in the face of fee spikes. In turn, they require to
/// maintain a reserve of on-chain funds to have the channel closure transactions confirmed
/// on-chain, at least if the channel counterparty can't be trusted to do this for us.
///
/// See [BOLT 3] for more technical details on Anchor channels.
///
///
/// ### Defaults
///
/// | Parameter                  | Value  |
/// |----------------------------|--------|
/// | `trustedPeersNoReserve` | []     |
/// | `perChannelReserveSats` | 25000  |
///
///
/// [BOLT 3]: https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions
class AnchorChannelsConfig {
  /// A list of peers that we trust to get the required channel closing transactions confirmed
  /// on-chain.
  ///
  /// Channels with these peers won't count towards the retained on-chain reserve and we won't
  /// take any action to get the required transactions confirmed ourselves.
  ///
  /// **Note:** Trusting the channel counterparty to take the necessary actions to get the
  /// required Anchor spending and HTLC transactions confirmed on-chain is potentially insecure
  /// as the channel may not be closed if they refuse to do so, potentially leaving the user
  /// funds stuck *or* even allow the counterparty to steal any in-flight funds after the
  /// corresponding HTLCs time out.
  final List<PublicKey> trustedPeersNoReserve;

  /// The amount of satoshis per anchors-negotiated channel with an untrusted peer that we keep
  /// as an emergency reserve in our on-chain wallet.
  ///
  /// This allows for having the required Anchor output spending and HTLC transactions confirmed
  /// when the channel is closed.
  ///
  /// If the channel peer is not marked as trusted via trustedPeersNoReserve,
  /// we will always try to spend the Anchor
  /// outputs with *any* on-chain funds available, i.e., the total reserve value as well as any
  /// spendable funds available in the on-chain wallet. Therefore, this per-channel multiplier is
  /// really an emergency reserve that we maintain at all time to reduce reduce the risk of
  /// insufficient funds at time of a channel closure. To this end, we will refuse to open
  /// outbound or accept inbound channels if we don't have sufficient on-chain funds available to
  /// cover the additional reserve requirement.
  ///
  /// **Note:** Depending on the fee market at the time of closure, this reserve amount might or
  /// might not suffice to successfully spend the Anchor output and have the HTLC transactions
  /// confirmed on-chain, i.e., you may want to adjust this value accordingly.
  final BigInt perChannelReserveSats;

  const AnchorChannelsConfig({
    required this.trustedPeersNoReserve,
    required this.perChannelReserveSats,
  });

  static Future<AnchorChannelsConfig> default_() =>
      core.instance.api.crateApiTypesAnchorChannelsConfigDefault();

  @override
  int get hashCode =>
      trustedPeersNoReserve.hashCode ^ perChannelReserveSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AnchorChannelsConfig &&
          runtimeType == other.runtimeType &&
          trustedPeersNoReserve == other.trustedPeersNoReserve &&
          perChannelReserveSats == other.perChannelReserveSats;
}

/// Details of the known available balances returned by `node.listBalances`.
///
class BalanceDetails {
  /// The total balance of our on-chain wallet.
  final BigInt totalOnchainBalanceSats;

  /// The currently spendable balance of our on-chain wallet.
  final BigInt spendableOnchainBalanceSats;

  /// The total balance that we would be able to claim across all our Lightning channels.
  ///
  /// Note this excludes balances that we are unsure if we are able to claim (e.g., as we are
  final BigInt totalLightningBalanceSats;

  /// A detailed list of all known Lightning balances that would be claimable on channel closure.
  ///
  /// Note that less than the listed amounts are spendable over lightning as further reserve
  /// restrictions apply.
  final List<LightningBalance> lightningBalances;

  /// A detailed list of balances currently being swept from the Lightning to the on-chain
  /// wallet.
  ///
  /// These are balances resulting from channel closures that may have been encumbered by a
  /// delay, but are now being claimed and useable once sufficiently confirmed on-chain.
  ///
  /// Note that, depending on the sync status of the wallets, swept balances listed here might or
  /// might not already be accounted for in `totalOnchainBalanceSats`.
  final List<PendingSweepBalance> pendingBalancesFromChannelClosures;

  const BalanceDetails({
    required this.totalOnchainBalanceSats,
    required this.spendableOnchainBalanceSats,
    required this.totalLightningBalanceSats,
    required this.lightningBalances,
    required this.pendingBalancesFromChannelClosures,
  });

  @override
  int get hashCode =>
      totalOnchainBalanceSats.hashCode ^
      spendableOnchainBalanceSats.hashCode ^
      totalLightningBalanceSats.hashCode ^
      lightningBalances.hashCode ^
      pendingBalancesFromChannelClosures.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BalanceDetails &&
          runtimeType == other.runtimeType &&
          totalOnchainBalanceSats == other.totalOnchainBalanceSats &&
          spendableOnchainBalanceSats == other.spendableOnchainBalanceSats &&
          totalLightningBalanceSats == other.totalLightningBalanceSats &&
          lightningBalances == other.lightningBalances &&
          pendingBalancesFromChannelClosures ==
              other.pendingBalancesFromChannelClosures;
}

/// Indicates whether the balance is derived from a cooperative close, a force-close
/// (for holder or counterparty), or whether it is for an HTLC.
enum BalanceSource {
  /// The channel was force closed by the holder.
  holderForceClosed,

  /// The channel was force closed by the counterparty.
  counterpartyForceClosed,

  /// The channel was cooperatively closed.
  coopClose,

  /// This balance is the result of an HTLC.
  htlc,
  ;
}

/// The best known block as identified by its hash and height.
class BestBlock {
  /// The block's hash
  final String blockHash;

  /// The height at which the block was confirmed.
  final int height;

  const BestBlock({
    required this.blockHash,
    required this.height,
  });

  @override
  int get hashCode => blockHash.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BestBlock &&
          runtimeType == other.runtimeType &&
          blockHash == other.blockHash &&
          height == other.height;
}

@freezed
sealed class ChainDataSourceConfig with _$ChainDataSourceConfig {
  const ChainDataSourceConfig._();

  const factory ChainDataSourceConfig.esplora({
    required String serverUrl,
    EsploraSyncConfig? syncConfig,
  }) = ChainDataSourceConfig_Esplora;
  const factory ChainDataSourceConfig.bitcoindRpc({
    required String rpcHost,
    required int rpcPort,
    required String rpcUser,
    required String rpcPassword,
  }) = ChainDataSourceConfig_BitcoindRpc;
}

///Options which apply on a per-channel basis and may change at runtime or based on negotiation with our counterparty.
class ChannelConfig {
  ///Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound over the channel. This may be allowed to change at runtime in a later update, however doing so must result in update messages sent to notify all nodes of our updated relay fee.
  ///
  ///Default value: 0.
  final int forwardingFeeProportionalMillionths;

  /// Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in excess of forwardingFeeProportionalMillionths. This may be allowed to change at runtime in a later update, however doing so must result in update messages sent to notify all nodes of our updated relay fee.
  ///
  /// The default value of a single satoshi roughly matches the market rate on many routing nodes as of July 2021. Adjusting it upwards or downwards may change whether nodes route through this node.
  ///
  ///Default value: 1000.
  final int forwardingFeeBaseMsat;

  ///The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over the channel this config applies to.
  ///
  /// Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed, we (or one of our watchtowers) MUST be online to check for broadcast of the current commitment transaction at least once per this many blocks (minus some margin to allow us enough time to broadcast and confirm a transaction, possibly with time in between to RBF the spending transaction).
  ///
  /// Default value: 72 (12 hours at an average of 6 blocks/hour). Minimum value: MIN_CLTV_EXPIRY_DELTA, any values less than this will be treated as MIN_CLTV_EXPIRY_DELTA instead.
  final int cltvExpiryDelta;

  /// Options for how to set the max dust HTLC exposure allowed on a channel.
  final MaxDustHTLCExposure maxDustHtlcExposure;

  ///The additional fee we’re willing to pay to avoid waiting for the counterparty’s toSelfDelay to reclaim funds.
  ///
  /// When we close a channel cooperatively with our counterparty, we negotiate a fee for the closing transaction which both sides find acceptable, ultimately paid by the channel funder/initiator.
  ///
  /// When we are the funder, because we have to pay the channel closing fee, we bound the acceptable fee by our Background and Normal fees, with the upper bound increased by this value. Because the on-chain fee we’d pay to force-close the channel is kept near our Normal feerate during normal operation, this value represents the additional fee we’re willing to pay in order to avoid waiting for our counterparty’s toSelfDelay to reclaim our funds.
  ///
  /// When we are not the funder, we require the closing transaction fee pay at least our Background fee estimate, but allow our counterparty to pay as much fee as they like. Thus, this value is ignored when we are not the funder.
  ///
  /// Default value: 1000 satoshis.
  final BigInt forceCloseAvoidanceMaxFeeSatoshis;

  ///If set, allows this channel's counterparty to skim an additional fee off this node's inbound HTLCs. Useful for liquidity providers to offload on-chain channel costs to end users.
  final bool acceptUnderpayingHtlcs;

  const ChannelConfig({
    required this.forwardingFeeProportionalMillionths,
    required this.forwardingFeeBaseMsat,
    required this.cltvExpiryDelta,
    required this.maxDustHtlcExposure,
    required this.forceCloseAvoidanceMaxFeeSatoshis,
    required this.acceptUnderpayingHtlcs,
  });

  @override
  int get hashCode =>
      forwardingFeeProportionalMillionths.hashCode ^
      forwardingFeeBaseMsat.hashCode ^
      cltvExpiryDelta.hashCode ^
      maxDustHtlcExposure.hashCode ^
      forceCloseAvoidanceMaxFeeSatoshis.hashCode ^
      acceptUnderpayingHtlcs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelConfig &&
          runtimeType == other.runtimeType &&
          forwardingFeeProportionalMillionths ==
              other.forwardingFeeProportionalMillionths &&
          forwardingFeeBaseMsat == other.forwardingFeeBaseMsat &&
          cltvExpiryDelta == other.cltvExpiryDelta &&
          maxDustHtlcExposure == other.maxDustHtlcExposure &&
          forceCloseAvoidanceMaxFeeSatoshis ==
              other.forceCloseAvoidanceMaxFeeSatoshis &&
          acceptUnderpayingHtlcs == other.acceptUnderpayingHtlcs;
}

class ChannelDetails {
  /// The channel ID (prior to funding transaction generation, this is a random 32-byte
  /// identifier, afterwards this is the transaction ID of the funding transaction XOR the
  /// funding transaction output).
  ///
  /// Note that this means this value is *not* persistent - it can change once during the
  /// lifetime of the channel.
  final ChannelId channelId;

  /// The node ID of our the channel's counterparty.
  final PublicKey counterpartyNodeId;

  /// The channel's funding transaction output, if we've negotiated the funding transaction with
  /// our counterparty already.
  final OutPoint? fundingTxo;

  /// The value, in satoshis, of this channel as it appears in the funding output.
  final BigInt channelValueSats;

  /// The value, in satoshis, that must always be held as a reserve in the channel for us. This
  /// value ensures that if we broadcast a revoked state, our counterparty can punish us by
  /// claiming at least this value on chain.
  ///
  /// This value is not included in `outboundCapacityMsat` as it can never be spent.
  ///
  /// This value will be `None` for outbound channels until the counterparty accepts the channel.
  ///
  final BigInt? unspendablePunishmentReserve;

  /// The local `user_channel_id` of this channel.
  final UserChannelId userChannelId;

  /// The currently negotiated fee rate denominated in satoshi per 1000 weight units,
  /// which is applied to commitment and HTLC transactions.
  final int feerateSatPer1000Weight;

  /// The available outbound capacity for sending HTLCs to the remote peer.
  ///
  /// The amount does not include any pending HTLCs which are not yet resolved (and, thus, whose
  /// balance is not available for inclusion in new outbound HTLCs). This further does not include
  /// any pending outgoing HTLCs which are awaiting some other resolution to be sent.
  final BigInt outboundCapacityMsat;

  /// The available outbound capacity for sending HTLCs to the remote peer.
  ///
  /// The amount does not include any pending HTLCs which are not yet resolved
  /// (and, thus, whose balance is not available for inclusion in new inbound HTLCs). This further
  /// does not include any pending outgoing HTLCs which are awaiting some other resolution to be
  /// sent.
  final BigInt inboundCapacityMsat;

  /// The number of required confirmations on the funding transactions before the funding is
  /// considered "locked". The amount is selected by the channel fundee.
  ///
  /// The value will be `None` for outbound channels until the counterparty accepts the channel.
  final int? confirmationsRequired;

  /// The current number of confirmations on the funding transaction.
  final int? confirmations;

  /// Returns `true` if the channel was initiated (and therefore funded) by us.
  final bool isOutbound;

  /// Returns `true` if both parties have exchanged `channel_ready` messages, and the channel is
  /// not currently being shut down. Both parties exchange `channel_ready` messages upon
  /// independently verifying that the required confirmations count provided by
  /// `confirmations_required` has been reached.
  final bool isChannelReady;

  /// Returns `true` if the channel (a) `channel_ready` messages have been exchanged, (b) the
  /// peer is connected, and (c) the channel is not currently negotiating shutdown.
  ///
  /// This is a strict superset of `is_channel_ready`.
  final bool isUsable;

  /// The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
  /// the channel.
  final int? cltvExpiryDelta;

  /// The value, in satoshis, that must always be held in the channel for our counterparty. This
  /// value ensures that if our counterparty broadcasts a revoked state, we can punish them by
  /// claiming at least this value on chain.
  ///
  /// This value is not included in [`inbound_capacity_msat`] as it can never be spent.
  ///
  /// [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
  final BigInt counterpartyUnspendablePunishmentReserve;

  /// The smallest value HTLC (in msat) the remote peer will accept, for this channel.
  ///
  /// This field is only `None` before we have received either the `OpenChannel` or
  /// `AcceptChannel` message from the remote peer.
  final BigInt? counterpartyOutboundHtlcMinimumMsat;

  /// The largest value HTLC (in msat) the remote peer currently will accept, for this channel.
  final BigInt? counterpartyOutboundHtlcMaximumMsat;

  /// Base routing fee in millisatoshis.
  final int? counterpartyForwardingInfoFeeBaseMsat;

  /// Proportional fee, in millionths of a satoshi the channel will charge per transferred satoshi.
  final int? counterpartyForwardingInfoFeeProportionalMillionths;

  /// The minimum difference in CLTV expiry between an ingoing HTLC and its outgoing counterpart,
  /// such that the outgoing HTLC is forwardable to this counterparty.
  final int? counterpartyForwardingInfoCltvExpiryDelta;

  /// The available outbound capacity for sending a single HTLC to the remote peer. This is
  /// similar to `channelDetails.outboundCapacityMsat` but it may be further restricted by
  /// the current state and per-HTLC limit(s). This is intended for use when routing, allowing us
  /// to use a limit as close as possible to the HTLC limit we can currently send.
  final BigInt nextOutboundHtlcLimitMsat;

  /// The minimum value for sending a single HTLC to the remote peer. This is the equivalent of
  /// `channelDetails.nextOutboundHtlcLimitMsat`  but represents a lower-bound, rather than
  /// an upper-bound. This is intended for use when routing, allowing us to ensure we pick a
  /// route which is valid.
  final BigInt nextOutboundHtlcMinimumMsat;

  /// The number of blocks (after our commitment transaction confirms) that we will need to wait
  /// until we can claim our funds after we force-close the channel. During this time our
  /// counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
  /// force-closes the channel and broadcasts a commitment transaction we do not have to wait any
  /// time to claim our non-HTLC-encumbered funds.
  ///
  /// This value will be `None` for outbound channels until the counterparty accepts the channel.
  final int? forceCloseSpendDelay;

  /// The smallest value HTLC (in msat) we will accept, for this channel.
  final BigInt inboundHtlcMinimumMsat;

  /// The largest value HTLC (in msat) we currently will accept, for this channel.
  final BigInt? inboundHtlcMaximumMsat;

  /// Set of configurable parameters that affect channel operation.
  final ChannelConfig config;

  const ChannelDetails({
    required this.channelId,
    required this.counterpartyNodeId,
    this.fundingTxo,
    required this.channelValueSats,
    this.unspendablePunishmentReserve,
    required this.userChannelId,
    required this.feerateSatPer1000Weight,
    required this.outboundCapacityMsat,
    required this.inboundCapacityMsat,
    this.confirmationsRequired,
    this.confirmations,
    required this.isOutbound,
    required this.isChannelReady,
    required this.isUsable,
    this.cltvExpiryDelta,
    required this.counterpartyUnspendablePunishmentReserve,
    this.counterpartyOutboundHtlcMinimumMsat,
    this.counterpartyOutboundHtlcMaximumMsat,
    this.counterpartyForwardingInfoFeeBaseMsat,
    this.counterpartyForwardingInfoFeeProportionalMillionths,
    this.counterpartyForwardingInfoCltvExpiryDelta,
    required this.nextOutboundHtlcLimitMsat,
    required this.nextOutboundHtlcMinimumMsat,
    this.forceCloseSpendDelay,
    required this.inboundHtlcMinimumMsat,
    this.inboundHtlcMaximumMsat,
    required this.config,
  });

  @override
  int get hashCode =>
      channelId.hashCode ^
      counterpartyNodeId.hashCode ^
      fundingTxo.hashCode ^
      channelValueSats.hashCode ^
      unspendablePunishmentReserve.hashCode ^
      userChannelId.hashCode ^
      feerateSatPer1000Weight.hashCode ^
      outboundCapacityMsat.hashCode ^
      inboundCapacityMsat.hashCode ^
      confirmationsRequired.hashCode ^
      confirmations.hashCode ^
      isOutbound.hashCode ^
      isChannelReady.hashCode ^
      isUsable.hashCode ^
      cltvExpiryDelta.hashCode ^
      counterpartyUnspendablePunishmentReserve.hashCode ^
      counterpartyOutboundHtlcMinimumMsat.hashCode ^
      counterpartyOutboundHtlcMaximumMsat.hashCode ^
      counterpartyForwardingInfoFeeBaseMsat.hashCode ^
      counterpartyForwardingInfoFeeProportionalMillionths.hashCode ^
      counterpartyForwardingInfoCltvExpiryDelta.hashCode ^
      nextOutboundHtlcLimitMsat.hashCode ^
      nextOutboundHtlcMinimumMsat.hashCode ^
      forceCloseSpendDelay.hashCode ^
      inboundHtlcMinimumMsat.hashCode ^
      inboundHtlcMaximumMsat.hashCode ^
      config.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelDetails &&
          runtimeType == other.runtimeType &&
          channelId == other.channelId &&
          counterpartyNodeId == other.counterpartyNodeId &&
          fundingTxo == other.fundingTxo &&
          channelValueSats == other.channelValueSats &&
          unspendablePunishmentReserve == other.unspendablePunishmentReserve &&
          userChannelId == other.userChannelId &&
          feerateSatPer1000Weight == other.feerateSatPer1000Weight &&
          outboundCapacityMsat == other.outboundCapacityMsat &&
          inboundCapacityMsat == other.inboundCapacityMsat &&
          confirmationsRequired == other.confirmationsRequired &&
          confirmations == other.confirmations &&
          isOutbound == other.isOutbound &&
          isChannelReady == other.isChannelReady &&
          isUsable == other.isUsable &&
          cltvExpiryDelta == other.cltvExpiryDelta &&
          counterpartyUnspendablePunishmentReserve ==
              other.counterpartyUnspendablePunishmentReserve &&
          counterpartyOutboundHtlcMinimumMsat ==
              other.counterpartyOutboundHtlcMinimumMsat &&
          counterpartyOutboundHtlcMaximumMsat ==
              other.counterpartyOutboundHtlcMaximumMsat &&
          counterpartyForwardingInfoFeeBaseMsat ==
              other.counterpartyForwardingInfoFeeBaseMsat &&
          counterpartyForwardingInfoFeeProportionalMillionths ==
              other.counterpartyForwardingInfoFeeProportionalMillionths &&
          counterpartyForwardingInfoCltvExpiryDelta ==
              other.counterpartyForwardingInfoCltvExpiryDelta &&
          nextOutboundHtlcLimitMsat == other.nextOutboundHtlcLimitMsat &&
          nextOutboundHtlcMinimumMsat == other.nextOutboundHtlcMinimumMsat &&
          forceCloseSpendDelay == other.forceCloseSpendDelay &&
          inboundHtlcMinimumMsat == other.inboundHtlcMinimumMsat &&
          inboundHtlcMaximumMsat == other.inboundHtlcMaximumMsat &&
          config == other.config;
}

/// The global identifier of a channel.
///
/// Note that this will start out to be a temporary ID until channel funding negotiation is
/// finalized, at which point it will change to be a permanent global ID tied to the on-chain
/// funding transaction.
///
class ChannelId {
  final U8Array32 data;

  const ChannelId({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelId &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

@freezed
sealed class ClosureReason with _$ClosureReason {
  const ClosureReason._();

  /// Our peer provided a feerate which violated our required minimum (fetched from our
  /// `FeeEstimator`
  ///
  const factory ClosureReason.peerFeerateTooLow({
    required int peerFeerateSatPerKw,
    required int requiredFeerateSatPerKw,
  }) = ClosureReason_PeerFeerateTooLow;

  /// Closure generated from receiving a peer error message.
  ///
  /// Our counterparty may have broadcasted their latest commitment state, and we have
  /// as well.
  const factory ClosureReason.counterpartyForceClosed({
    /// The error which the peer sent us.
    ///
    /// Be careful about printing the peer_msg, a well-crafted message could exploit
    /// a security vulnerability in the terminal emulator or the logging subsystem.
    /// To be safe, use `Display` on `UntrustedString`
    ///
    /// [`UntrustedString`]: crate::util::string::UntrustedString
    required String peerMsg,
  }) = ClosureReason_CounterpartyForceClosed;

  /// Closure generated from [`ChannelManager::force_close_channel`], called by the user.
  ///
  /// [`ChannelManager::force_close_channel`]: crate::ln::channelmanager::ChannelManager::force_close_channel.
  const factory ClosureReason.holderForceClosed({
    bool? broadcastedLatestTxn,
  }) = ClosureReason_HolderForceClosed;

  /// The channel was closed after negotiating a cooperative close and we've now broadcasted
  /// the cooperative close transaction. Note the shutdown may have been initiated by us.
  ///
  /// This was only set in versions of LDK prior to 0.0.122.
  const factory ClosureReason.legacyCooperativeClosure() =
      ClosureReason_LegacyCooperativeClosure;

  /// The channel was closed after negotiating a cooperative close and we've now broadcasted
  /// the cooperative close transaction. This indicates that the shutdown was initiated by our
  /// counterparty.
  ///
  /// In rare cases where we initiated closure immediately prior to shutting down without
  /// persisting, this value may be provided for channels we initiated closure for.
  const factory ClosureReason.counterpartyInitiatedCooperativeClosure() =
      ClosureReason_CounterpartyInitiatedCooperativeClosure;

  /// The channel was closed after negotiating a cooperative close and we've now broadcasted
  /// the cooperative close transaction. This indicates that the shutdown was initiated by us.
  const factory ClosureReason.locallyInitiatedCooperativeClosure() =
      ClosureReason_LocallyInitiatedCooperativeClosure;

  /// A commitment transaction was confirmed on chain, closing the channel. Most likely this
  /// commitment transaction came from our counterparty, but it may also have come from
  /// a copy of our own `ChannelMonitor`.
  const factory ClosureReason.commitmentTxConfirmed() =
      ClosureReason_CommitmentTxConfirmed;

  /// The funding transaction failed to confirm in a timely manner on an inbound channel.
  const factory ClosureReason.fundingTimedOut() = ClosureReason_FundingTimedOut;

  /// Closure generated from processing an event, likely a HTLC forward/relay/reception.
  const factory ClosureReason.processingError({
    /// A developer-readable error message which we generated.
    required String err,
  }) = ClosureReason_ProcessingError;

  /// The peer disconnected prior to funding completing. In this case the spec mandates that we
  /// forget the channel entirely - we can attempt again if the peer reconnects.
  ///
  /// This includes cases where we restarted prior to funding completion, including prior to the
  /// initial [`ChannelMonitor`] persistence completing.
  ///
  /// In LDK versions prior to 0.0.107 this could also occur if we were unable to connect to the
  /// peer because of mutual incompatibility between us and our channel counterparty.
  ///
  /// [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
  const factory ClosureReason.disconnectedPeer() =
      ClosureReason_DisconnectedPeer;

  /// Closure generated from `ChannelManager::read` if the [`ChannelMonitor`] is newer than
  /// the [`ChannelManager`] deserialized.
  ///
  /// [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  const factory ClosureReason.outdatedChannelManager() =
      ClosureReason_OutdatedChannelManager;

  /// The counterparty requested a cooperative close of a channel that had not been funded yet.
  /// The channel has been immediately closed.
  const factory ClosureReason.counterpartyCoopClosedUnfundedChannel() =
      ClosureReason_CounterpartyCoopClosedUnfundedChannel;

  /// Another channel in the same funding batch closed before the funding transaction
  /// was ready to be broadcast.
  const factory ClosureReason.fundingBatchClosure() =
      ClosureReason_FundingBatchClosure;

  /// One of our HTLCs timed out in a channel, causing us to force close the channel.
  const factory ClosureReason.htlCsTimedOut() = ClosureReason_HTLCsTimedOut;
}

/// Represents the configuration of an [Node] instance.
///
class Config {
  String storageDirPath;
  String? logDirPath;

  /// The used Bitcoin network.
  ///
  Network network;

  /// The IP address and TCP port the node will listen on.
  ///
  List<SocketAddress>? listeningAddresses;

  /// The node alias that will be used when broadcasting announcements to the gossip network.
  ///
  /// The provided alias must be a valid UTF-8 string and no longer than 32 bytes in total.
  ///
  /// **Note**: We will only allow opening and accepting public channels if the `nodeAlias` and the
  /// `listeningAddresses` are set.
  NodeAlias? nodeAlias;

  ///A list of peers that we allow to establish zero confirmation channels to us.
  ///
  ///Note: Allowing payments via zero-confirmation channels is potentially insecure if the funding transaction ends up never being confirmed on-chain. Zero-confirmation channels should therefore only be accepted from trusted peers.
  final List<PublicKey> trustedPeers0Conf;
  final BigInt probingLiquidityLimitMultiplier;

  ///The level at which we log messages.
  /// Any messages below this level will be excluded from the logs.
  ///
  LogLevel logLevel;
  AnchorChannelsConfig? anchorChannelsConfig;

  /// Configuration options for payment routing and pathfinding.
  ///
  /// Setting the `SendingParameters` provides flexibility to customize how payments are routed,
  /// including setting limits on routing fees, CLTV expiry, and channel utilization.
  ///
  /// **Note:** If unset, default parameters will be used, and you will be able to override the
  /// parameters on a per-payment basis in the corresponding method calls.
  SendingParameters? sendingParameters;

  Config({
    required this.storageDirPath,
    this.logDirPath,
    required this.network,
    this.listeningAddresses,
    this.nodeAlias,
    required this.trustedPeers0Conf,
    required this.probingLiquidityLimitMultiplier,
    required this.logLevel,
    this.anchorChannelsConfig,
    this.sendingParameters,
  });

  static Future<Config> default_() =>
      core.instance.api.crateApiTypesConfigDefault();

  @override
  int get hashCode =>
      storageDirPath.hashCode ^
      logDirPath.hashCode ^
      network.hashCode ^
      listeningAddresses.hashCode ^
      nodeAlias.hashCode ^
      trustedPeers0Conf.hashCode ^
      probingLiquidityLimitMultiplier.hashCode ^
      logLevel.hashCode ^
      anchorChannelsConfig.hashCode ^
      sendingParameters.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          storageDirPath == other.storageDirPath &&
          logDirPath == other.logDirPath &&
          network == other.network &&
          listeningAddresses == other.listeningAddresses &&
          nodeAlias == other.nodeAlias &&
          trustedPeers0Conf == other.trustedPeers0Conf &&
          probingLiquidityLimitMultiplier ==
              other.probingLiquidityLimitMultiplier &&
          logLevel == other.logLevel &&
          anchorChannelsConfig == other.anchorChannelsConfig &&
          sendingParameters == other.sendingParameters;
}

@freezed
sealed class EntropySourceConfig with _$EntropySourceConfig {
  const EntropySourceConfig._();

  const factory EntropySourceConfig.seedFile(
    String field0,
  ) = EntropySourceConfig_SeedFile;
  const factory EntropySourceConfig.seedBytes(
    U8Array64 field0,
  ) = EntropySourceConfig_SeedBytes;
  const factory EntropySourceConfig.bip39Mnemonic({
    required FfiMnemonic mnemonic,
    String? passphrase,
  }) = EntropySourceConfig_Bip39Mnemonic;
}

class EsploraSyncConfig {
  /// The time in-between background sync attempts of the onchain wallet, in seconds.
  ///
  /// **Note:** A minimum of 10 seconds is always enforced.
  final BigInt onchainWalletSyncIntervalSecs;

  /// The time in-between background sync attempts of the LDK wallet, in seconds.
  ///
  /// **Note:** A minimum of 10 seconds is always enforced.
  final BigInt lightningWalletSyncIntervalSecs;

  /// The time in-between background update attempts to our fee rate cache, in seconds.
  ///
  /// **Note:** A minimum of 10 seconds is always enforced.
  final BigInt feeRateCacheUpdateIntervalSecs;

  const EsploraSyncConfig({
    required this.onchainWalletSyncIntervalSecs,
    required this.lightningWalletSyncIntervalSecs,
    required this.feeRateCacheUpdateIntervalSecs,
  });

  @override
  int get hashCode =>
      onchainWalletSyncIntervalSecs.hashCode ^
      lightningWalletSyncIntervalSecs.hashCode ^
      feeRateCacheUpdateIntervalSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EsploraSyncConfig &&
          runtimeType == other.runtimeType &&
          onchainWalletSyncIntervalSecs ==
              other.onchainWalletSyncIntervalSecs &&
          lightningWalletSyncIntervalSecs ==
              other.lightningWalletSyncIntervalSecs &&
          feeRateCacheUpdateIntervalSecs ==
              other.feeRateCacheUpdateIntervalSecs;
}

@freezed
sealed class Event with _$Event {
  const Event._();

  /// A payment for a previously-registered payment hash has been received.
  ///
  /// This needs to be manually claimed by supplying the correct preimage to `claimForHash`.
  ///
  /// If the the provided parameters don't match the expectations or the preimage can't be
  /// retrieved in time, should be failed-back via [`failForHash`].
  const factory Event.paymentClaimable({
    /// A local identifier used to track the payment.
    required PaymentId paymentId,

    /// The hash of the payment.
    required PaymentHash paymentHash,

    /// The value, in thousandths of a satoshi, that is claimable.
    required BigInt claimableAmountMsat,

    /// The block height at which this payment will be failed back and will no longer be
    /// eligible for claiming.
    int? claimDeadline,
  }) = Event_PaymentClaimable;

  /// A sent payment was successful.
  const factory Event.paymentSuccessful({
    /// A local identifier used to track the payment.
    ///
    /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
    PaymentId? paymentId,

    /// The hash of the payment.
    required PaymentHash paymentHash,

    /// The total fee which was spent at intermediate hops in this payment.
    BigInt? feePaidMsat,
  }) = Event_PaymentSuccessful;

  /// A sent payment has failed.
  const factory Event.paymentFailed({
    /// A local identifier used to track the payment.
    ///
    /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
    PaymentId? paymentId,

    /// The hash of the payment.
    PaymentHash? paymentHash,

    /// The reason why the payment failed.
    ///
    /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
    PaymentFailureReason? reason,
  }) = Event_PaymentFailed;

  /// A payment has been received.
  const factory Event.paymentReceived({
    /// A local identifier used to track the payment.
    ///
    /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
    PaymentId? paymentId,

    /// The hash of the payment.
    required PaymentHash paymentHash,

    /// The value, in thousandths of a satoshi, that has been received.
    required BigInt amountMsat,
  }) = Event_PaymentReceived;

  /// A channel has been created and is pending confirmation on-chain.
  const factory Event.channelPending({
    /// The `channelId` of the channel.
    required ChannelId channelId,

    /// The `userChannelId` of the channel.
    required UserChannelId userChannelId,

    /// The `temporaryChannelId` this channel used to be known by during channel establishment.
    required ChannelId formerTemporaryChannelId,

    /// The `nodeId` of the channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The outpoint of the channel's funding transaction.
    required OutPoint fundingTxo,
  }) = Event_ChannelPending;

  /// A channel is ready to be used.
  const factory Event.channelReady({
    /// The `channelId` of the channel.
    required ChannelId channelId,

    /// The `userChannelId` of the channel.
    required UserChannelId userChannelId,

    /// The `nodeId` of the channel counterparty.
    ///
    /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
    PublicKey? counterpartyNodeId,
  }) = Event_ChannelReady;

  /// A channel has been closed.
  const factory Event.channelClosed({
    /// The `channelId` of the channel.
    required ChannelId channelId,

    /// The `userChannelId` of the channel.
    required UserChannelId userChannelId,

    /// The `nodeId` of the channel counterparty.
    ///
    /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
    PublicKey? counterpartyNodeId,

    /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
    ClosureReason? reason,
  }) = Event_ChannelClosed;
}

@freezed
sealed class GossipSourceConfig with _$GossipSourceConfig {
  const GossipSourceConfig._();

  const factory GossipSourceConfig.p2PNetwork() = GossipSourceConfig_P2PNetwork;
  const factory GossipSourceConfig.rapidGossipSync(
    String field0,
  ) = GossipSourceConfig_RapidGossipSync;
}

@freezed
sealed class LightningBalance with _$LightningBalance {
  const LightningBalance._();

  /// The channel is not yet closed (or the commitment or closing transaction has not yet
  /// appeared in a block). The given balance is claimable (less on-chain fees) if the channel is
  /// force-closed now.
  const factory LightningBalance.claimableOnChannelClose({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
    /// required to do so.
    required BigInt amountSatoshis,

    /// The transaction fee we pay for the closing commitment transaction. This amount is not
    /// included in the `amount_satoshis` value.
    ///
    /// Note that if this channel is inbound (and thus our counterparty pays the commitment
    /// transaction fee) this value will be zero. For channels created prior to LDK Node 0.4
    /// the channel is always treated as outbound (and thus this value is never zero).
    required BigInt transactionFeeSatoshis,

    /// The amount of millisatoshis which has been burned to fees from HTLCs which are outbound
    /// from us and are related to a payment which was sent by us. This is the sum of the
    /// millisatoshis part of all HTLCs which are otherwise represented by
    /// This amount (rounded up to a whole satoshi value) will not be included in `amountSatoshis`.
    required BigInt outboundPaymentHtlcRoundedMsat,

    /// The amount of millisatoshis which has been burned to fees from HTLCs which are outbound
    /// from us and are related to a forwarded HTLC. This is the sum of the millisatoshis part
    /// of all HTLCs which are otherwise represented by
    /// This amount (rounded up to a whole satoshi value) will not be included in `amountSatoshis`.
    required BigInt outboundForwardedHtlcRoundedMsat,

    /// The amount of millisatoshis which has been burned to fees from HTLCs which are inbound
    /// to us and for which we know the preimage. This is the sum of the millisatoshis part of
    /// all HTLCs which would be represented by `lightningBalance.ContentiousClaimable` on
    /// channel close, but whose current value is included in `amountSatoshis`, as well as any
    /// dust HTLCs which would otherwise be represented the same.
    ///
    /// This amount (rounded up to a whole satoshi value) will not be included in `amountSatoshis`.
    required BigInt inboundClaimingHtlcRoundedMsat,

    /// The amount of millisatoshis which has been burned to fees from HTLCs which are inbound
    /// to us and for which we do not know the preimage. This is the sum of the millisatoshis
    /// part of all HTLCs which would be represented by
    /// `lightningBalance.MaybePreimageClaimableHTLC` on channel close, as well as any dust
    /// HTLCs which would otherwise be represented the same.
    ///
    /// This amount (rounded up to a whole satoshi value) will not be included in the
    /// counterparty's `amountSatoshis`.
    required BigInt inboundHtlcRoundedMsat,
  }) = LightningBalance_ClaimableOnChannelClose;

  /// The channel has been closed, and the given balance is ours but awaiting confirmations until
  /// we consider it spendable.
  const factory LightningBalance.claimableAwaitingConfirmations({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount available to claim, in satoshis, possibly excluding the on-chain fees which
    /// were spent in broadcasting the transaction.
    required BigInt amountSatoshis,

    /// The height at which an `event.SpendableOutputs` event will be generated for this
    /// amount.
    ///
    required int confirmationHeight,

    /// Whether this balance is a result of cooperative close, a force-close, or an HTLC.
    required BalanceSource source,
  }) = LightningBalance_ClaimableAwaitingConfirmations;

  /// The channel has been closed, and the given balance should be ours but awaiting spending
  /// transaction confirmation. If the spending transaction does not confirm in time, it is
  /// possible our counterparty can take the funds by broadcasting an HTLC timeout on-chain.
  ///
  /// Once the spending transaction confirms, before it has reached enough confirmations to be
  /// considered safe from chain reorganizations, the balance will instead be provided via
  /// `lightningBalance.claimableAwaitingConfirmations`.
  const factory LightningBalance.contentiousClaimable({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
    /// required to do so.
    required BigInt amountSatoshis,

    /// The height at which the counterparty may be able to claim the balance if we have not
    /// done so.
    required int timeoutHeight,

    /// The payment hash that locks this HTLC.
    required PaymentHash paymentHash,

    /// The preimage that can be used to claim this HTLC.
    required PaymentPreimage paymentPreimage,
  }) = LightningBalance_ContentiousClaimable;

  /// HTLCs which we sent to our counterparty which are claimable after a timeout (less on-chain
  /// fees) if the counterparty does not know the preimage for the HTLCs. These are somewhat
  /// likely to be claimed by our counterparty before we do.
  const factory LightningBalance.maybeTimeoutClaimableHtlc({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
    /// which will be required to do so.
    required BigInt amountSatoshis,

    /// The height at which we will be able to claim the balance if our counterparty has not
    /// done so.
    required int claimableHeight,

    /// The payment hash whose preimage our counterparty needs to claim this HTLC.
    required PaymentHash paymentHash,

    ///
    required bool outboundPayment,
  }) = LightningBalance_MaybeTimeoutClaimableHTLC;

  /// HTLCs which we received from our counterparty which are claimable with a preimage which we
  /// do not currently have. This will only be claimable if we receive the preimage from the node
  /// to which we forwarded this HTLC before the timeout.
  const factory LightningBalance.maybePreimageClaimableHtlc({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
    /// which will be required to do so.
    required BigInt amountSatoshis,

    /// The height at which our counterparty will be able to claim the balance if we have not
    /// yet received the preimage and claimed it ourselves.
    required int expiryHeight,

    /// The payment hash whose preimage we need to claim this HTLC.
    required PaymentHash paymentHash,
  }) = LightningBalance_MaybePreimageClaimableHTLC;

  /// The channel has been closed, and our counterparty broadcasted a revoked commitment
  /// transaction.
  ///
  /// Thus, we're able to claim all outputs in the commitment transaction, one of which has the
  /// following amount.
  const factory LightningBalance.counterpartyRevokedOutputClaimable({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount, in satoshis, of the output which we can claim.
    required BigInt amountSatoshis,
  }) = LightningBalance_CounterpartyRevokedOutputClaimable;
}

class LiquiditySourceConfig {
  final (SocketAddress, PublicKey, String?) lsps2Service;

  const LiquiditySourceConfig({
    required this.lsps2Service,
  });

  @override
  int get hashCode => lsps2Service.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LiquiditySourceConfig &&
          runtimeType == other.runtimeType &&
          lsps2Service == other.lsps2Service;
}

/// An enum representing the available verbosity levels of the logger.
///
enum LogLevel {
  /// Designates extremely verbose information, including gossip-induced messages
  ///
  gossip,

  /// Designates very low priority, often extremely verbose, information
  ///
  trace,

  /// Designates lower priority information
  ///
  debug,

  /// Designates useful information
  ///
  info,

  /// Designates hazardous situations
  ///
  warn,

  /// Designates very serious errors
  ///
  error,
  ;
}

/// Limits applying to how much fee we allow an LSP to deduct from the payment amount.
class LSPFeeLimits {
  /// The maximal total amount we allow any configured LSP withhold from us when forwarding the
  /// payment.
  final BigInt? maxTotalOpeningFeeMsat;

  /// The maximal proportional fee, in parts-per-million millisatoshi, we allow any configured
  /// LSP withhold from us when forwarding the payment.
  final BigInt? maxProportionalOpeningFeePpmMsat;

  const LSPFeeLimits({
    this.maxTotalOpeningFeeMsat,
    this.maxProportionalOpeningFeePpmMsat,
  });

  @override
  int get hashCode =>
      maxTotalOpeningFeeMsat.hashCode ^
      maxProportionalOpeningFeePpmMsat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LSPFeeLimits &&
          runtimeType == other.runtimeType &&
          maxTotalOpeningFeeMsat == other.maxTotalOpeningFeeMsat &&
          maxProportionalOpeningFeePpmMsat ==
              other.maxProportionalOpeningFeePpmMsat;
}

@freezed
sealed class MaxDustHTLCExposure with _$MaxDustHTLCExposure {
  const MaxDustHTLCExposure._();

  ///This sets a fixed limit on the total dust exposure in millisatoshis. Setting this too low may prevent the sending or receipt of low-value HTLCs on high-traffic nodes, however this limit is very important to prevent stealing of large amounts of dust HTLCs by miners through fee griefing attacks.
  const factory MaxDustHTLCExposure.fixedLimitMsat(
    BigInt field0,
  ) = MaxDustHTLCExposure_FixedLimitMsat;

  ///This sets a multiplier on the estimated high priority feerate (sats/KW, as obtained from FeeEstimator) to determine the maximum allowed dust exposure. If this variant is used then the maximum dust exposure in millisatoshis is calculated as: high_priority_feerate_per_kw * value. For example, with our default value FeeRateMultiplier(5000):
  const factory MaxDustHTLCExposure.feeRateMultiplier(
    BigInt field0,
  ) = MaxDustHTLCExposure_FeeRateMultiplier;
}

@freezed
sealed class MaxTotalRoutingFeeLimit with _$MaxTotalRoutingFeeLimit {
  const MaxTotalRoutingFeeLimit._();

  const factory MaxTotalRoutingFeeLimit.noFeeCap() =
      MaxTotalRoutingFeeLimit_NoFeeCap;
  const factory MaxTotalRoutingFeeLimit.feeCap({
    required BigInt amountMsat,
  }) = MaxTotalRoutingFeeLimit_FeeCap;
}

/// Bitcoin network enum
///
enum Network {
  ///Classic Bitcoin
  ///
  bitcoin,

  ///Bitcoin’s testnet
  ///
  testnet,

  ///Bitcoin’s signet
  ///
  signet,

  ///Bitcoin’s regtest
  ///
  regtest,
  ;
}

/// A user-defined name for a node, which may be used when displaying the node in a graph.
///
/// Since node aliases are provided by third parties, they are a potential avenue for injection
/// attacks. Care must be taken when processing.
class NodeAlias {
  final U8Array32 field0;

  const NodeAlias({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeAlias &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Represents the status of the [`Node`].
class NodeStatus {
  /// Indicates whether the `Node` is running.
  final bool isRunning;

  /// Indicates whether the `Node` is listening for incoming connections on the addresses
  final bool isListening;

  /// The best block to which our Lightning wallet is currently synced.
  final BestBlock currentBestBlock;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully synced
  /// our Lightning wallet to the chain tip.
  ///
  /// Will be `None` if the wallet hasn't been synced yet.
  final BigInt? latestLightningWalletSyncTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully synced
  /// our on-chain wallet to the chain tip.
  ///
  /// Will be `None` if the wallet hasn't been synced yet.
  final BigInt? latestOnchainWalletSyncTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully update
  /// our fee rate cache.
  ///
  /// Will be `None` if the cache hasn't been updated yet.
  final BigInt? latestFeeRateCacheUpdateTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when the last rapid gossip sync
  /// (RGS) snapshot we successfully applied was generated.
  ///
  /// Will be `None` if RGS isn't configured or the snapshot hasn't been updated yet.
  final BigInt? latestRgsSnapshotTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last broadcasted a node
  /// announcement.
  ///
  /// Will be `None` if we have no public channels or we haven't broadcasted yet.
  final BigInt? latestNodeAnnouncementBroadcastTimestamp;

  /// The block height when we last archived closed channel monitor data.
  ///
  /// Will be `None` if we haven't archived any monitors of closed channels yet.
  final int? latestChannelMonitorArchivalHeight;

  const NodeStatus({
    required this.isRunning,
    required this.isListening,
    required this.currentBestBlock,
    this.latestLightningWalletSyncTimestamp,
    this.latestOnchainWalletSyncTimestamp,
    this.latestFeeRateCacheUpdateTimestamp,
    this.latestRgsSnapshotTimestamp,
    this.latestNodeAnnouncementBroadcastTimestamp,
    this.latestChannelMonitorArchivalHeight,
  });

  @override
  int get hashCode =>
      isRunning.hashCode ^
      isListening.hashCode ^
      currentBestBlock.hashCode ^
      latestLightningWalletSyncTimestamp.hashCode ^
      latestOnchainWalletSyncTimestamp.hashCode ^
      latestFeeRateCacheUpdateTimestamp.hashCode ^
      latestRgsSnapshotTimestamp.hashCode ^
      latestNodeAnnouncementBroadcastTimestamp.hashCode ^
      latestChannelMonitorArchivalHeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeStatus &&
          runtimeType == other.runtimeType &&
          isRunning == other.isRunning &&
          isListening == other.isListening &&
          currentBestBlock == other.currentBestBlock &&
          latestLightningWalletSyncTimestamp ==
              other.latestLightningWalletSyncTimestamp &&
          latestOnchainWalletSyncTimestamp ==
              other.latestOnchainWalletSyncTimestamp &&
          latestFeeRateCacheUpdateTimestamp ==
              other.latestFeeRateCacheUpdateTimestamp &&
          latestRgsSnapshotTimestamp == other.latestRgsSnapshotTimestamp &&
          latestNodeAnnouncementBroadcastTimestamp ==
              other.latestNodeAnnouncementBroadcastTimestamp &&
          latestChannelMonitorArchivalHeight ==
              other.latestChannelMonitorArchivalHeight;
}

class OfferId {
  final U8Array32 field0;

  const OfferId({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OfferId &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

///A reference to a transaction output.
///
class OutPoint {
  final Txid txid;
  final int vout;

  const OutPoint({
    required this.txid,
    required this.vout,
  });

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OutPoint &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout;
}

/// Represents a payment.
class PaymentDetails {
  /// The identifier of this payment.
  final PaymentId id;

  /// The kind of the payment.
  final PaymentKind kind;

  /// The amount transferred.
  final BigInt? amountMsat;

  /// The direction of the payment.
  final PaymentDirection direction;

  /// The status of the payment.
  final PaymentStatus status;

  /// The timestamp, in seconds since start of the UNIX epoch, when this entry was last updated.
  final BigInt latestUpdateTimestamp;

  const PaymentDetails({
    required this.id,
    required this.kind,
    this.amountMsat,
    required this.direction,
    required this.status,
    required this.latestUpdateTimestamp,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      kind.hashCode ^
      amountMsat.hashCode ^
      direction.hashCode ^
      status.hashCode ^
      latestUpdateTimestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentDetails &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          kind == other.kind &&
          amountMsat == other.amountMsat &&
          direction == other.direction &&
          status == other.status &&
          latestUpdateTimestamp == other.latestUpdateTimestamp;
}

/// Represents the direction of a payment.
///
enum PaymentDirection {
  /// The payment is inbound.
  inbound,

  /// The payment is outbound.
  outbound,
  ;
}

/// The reason the payment failed. Used in `Event.PaymentFailed`.
enum PaymentFailureReason {
  /// The intended recipient rejected our payment.
  recipientRejected,

  /// The user chose to abandon this payment by calling `channelManager.abandon_payment`.
  ///
  userAbandoned,

  /// We exhausted all of our retry attempts while trying to send the payment, or we
  /// exhausted the `Retry.Timeout` if the user set one. If at any point a retry
  /// attempt failed while being forwarded along the path, an `Event::PaymentPathFailed` will
  /// have come before this.
  ///
  retriesExhausted,

  /// The payment expired while retrying, based on the provided
  paymentExpired,

  /// We failed to find a route while retrying the payment.
  routeNotFound,

  /// This error should generally never happen. This likely means that there is a problem with
  /// your router.
  unexpectedError,

  ///An invoice was received that required unknown features.
  unknownRequiredFeatures,

  ///A Bolt12Invoice was not received in a reasonable amount of time.
  invoiceRequestExpired,

  ///An InvoiceRequest for the payment was rejected by the recipient.
  invoiceRequestRejected,
  ;
}

/// paymentHash type, use to cross-lock hop
///
class PaymentHash {
  final U8Array32 data;

  const PaymentHash({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentHash &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

///A user-provided identifier in channelManager.sendPayment used to uniquely identify a payment and ensure idempotency in LDK.
class PaymentId {
  final U8Array32 field0;

  const PaymentId({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentId &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

@freezed
sealed class PaymentKind with _$PaymentKind {
  const PaymentKind._();

  /// An on-chain payment.
  const factory PaymentKind.onchain() = PaymentKind_Onchain;

  /// A [BOLT 11] payment.
  ///
  /// [BOLT 11]: https://github.com/lightning/bolts/blob/master/11-payment-encoding.md
  const factory PaymentKind.bolt11({
    /// The payment hash, i.e., the hash of the `preimage`.
    required PaymentHash hash,

    /// The pre-image used by the payment.
    PaymentPreimage? preimage,

    /// The secret used by the payment.
    PaymentSecret? secret,
  }) = PaymentKind_Bolt11;

  /// A [BOLT 11] payment intended to open an [LSPS 2] just-in-time channel.
  ///
  /// [BOLT 11]: https://github.com/lightning/bolts/blob/master/11-payment-encoding.md
  /// [LSPS 2]: https://github.com/BitcoinAndLightningLayerSpecs/lsp/blob/main/LSPS2/README.md
  const factory PaymentKind.bolt11Jit({
    /// The payment hash, i.e., the hash of the `preimage`.
    required PaymentHash hash,

    /// The pre-image used by the payment.
    PaymentPreimage? preimage,

    /// The secret used by the payment.
    PaymentSecret? secret,

    /// Limits applying to how much fee we allow an LSP to deduct from the payment amount.
    ///
    /// Allowing them to deduct this fee from the first inbound payment will pay for the LSP's
    /// channel opening fees.
    ///
    required LSPFeeLimits lspFeeLimits,
  }) = PaymentKind_Bolt11Jit;

  /// A spontaneous ("keysend") payment.
  const factory PaymentKind.spontaneous({
    /// The payment hash, i.e., the hash of the `preimage`.
    required PaymentHash hash,

    /// The pre-image used by the payment.
    PaymentPreimage? preimage,
  }) = PaymentKind_Spontaneous;

  /// A [BOLT 12] offer payment, i.e., a payment for an `Offer`.
  ///
  /// [BOLT 12]: https://github.com/lightning/bolts/blob/master/12-offer-encoding.md
  const factory PaymentKind.bolt12Offer({
    /// The payment hash, i.e., the hash of the `preimage`.
    PaymentHash? hash,

    /// The pre-image used by the payment.
    PaymentPreimage? preimage,

    /// The secret used by the payment.
    PaymentSecret? secret,

    /// The ID of the offer this payment is for.
    required OfferId offerId,

    /// The payer note for the payment.
    ///
    /// Truncated to `PAYER_NOTE_LIMIT` characters.
    ///
    /// This will always be `None` for payments serialized with version `v0.3.0`.
    String? payerNote,

    /// The quantity of an item requested in the offer.
    ///
    /// This will always be `None` for payments serialized with version `v0.3.0`.
    BigInt? quantity,
  }) = PaymentKind_Bolt12Offer;

  /// A [BOLT 12] 'refund' payment, i.e., a payment for a `Refund`.
  ///
  /// [BOLT 12]: https://github.com/lightning/bolts/blob/master/12-offer-encoding.md
  const factory PaymentKind.bolt12Refund({
    /// The payment hash, i.e., the hash of the `preimage`.
    PaymentHash? hash,

    /// The pre-image used by the payment.
    PaymentPreimage? preimage,

    /// The secret used by the payment.
    PaymentSecret? secret,

    ///
    /// This will always be `None` for payments serialized with version `v0.3.0`.
    String? payerNote,

    /// The quantity of an item that the refund is for.
    ///
    /// This will always be `None` for payments serialized with version `v0.3.0`.
    BigInt? quantity,
  }) = PaymentKind_Bolt12Refund;
}

/// paymentPreimage type, use to route payment between hop
///
class PaymentPreimage {
  final U8Array32 data;

  const PaymentPreimage({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentPreimage &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// payment_secret type, use to authenticate sender to the receiver and tie MPP HTLCs together
///
class PaymentSecret {
  final U8Array32 data;

  const PaymentSecret({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentSecret &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// Represents the current status of a payment.
///
enum PaymentStatus {
  /// The payment is still pending.
  pending,

  /// The payment suceeded.
  succeeded,

  /// The payment failed.
  failed,
  ;
}

/// Details of a known Lightning peer as returned by `node.listPeers`.
///
class PeerDetails {
  /// Our peer's node ID.
  ///
  final PublicKey nodeId;

  /// The IP address and TCP port of the peer.
  ///
  final SocketAddress address;

  /// Indicates whether or not the user is currently has an active connection with the peer.
  ///
  final bool isConnected;

  const PeerDetails({
    required this.nodeId,
    required this.address,
    required this.isConnected,
  });

  @override
  int get hashCode => nodeId.hashCode ^ address.hashCode ^ isConnected.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PeerDetails &&
          runtimeType == other.runtimeType &&
          nodeId == other.nodeId &&
          address == other.address &&
          isConnected == other.isConnected;
}

@freezed
sealed class PendingSweepBalance with _$PendingSweepBalance {
  const PendingSweepBalance._();

  /// The spendable output is about to be swept, but a spending transaction has yet to be generated and
  /// broadcast.
  const factory PendingSweepBalance.pendingBroadcast({
    /// The identifier of the channel this balance belongs to.
    ChannelId? channelId,

    /// The amount, in satoshis, of the output being swept.
    required BigInt amountSatoshis,
  }) = PendingSweepBalance_PendingBroadcast;

  /// A spending transaction has been generated and broadcast and is awaiting confirmation
  /// on-chain.
  const factory PendingSweepBalance.broadcastAwaitingConfirmation({
    /// The identifier of the channel this balance belongs to.
    ChannelId? channelId,

    /// The best height when we last broadcast a transaction spending the output being swept.
    required int latestBroadcastHeight,

    /// The identifier of the transaction spending the swept output we last broadcast.
    required Txid latestSpendingTxid,

    /// The amount, in satoshis, of the output being swept.
    required BigInt amountSatoshis,
  }) = PendingSweepBalance_BroadcastAwaitingConfirmation;

  /// A spending transaction has been confirmed on-chain and is awaiting threshold confirmations.
  ///
  /// It will be considered irrevocably confirmed after reaching [`ANTI_REORG_DELAY`].
  ///
  /// [`ANTI_REORG_DELAY`]: lightning::chain::channelmonitor::ANTI_REORG_DELAY
  const factory PendingSweepBalance.awaitingThresholdConfirmations({
    /// The identifier of the channel this balance belongs to.
    ChannelId? channelId,

    /// The identifier of the confirmed transaction spending the swept output.
    required Txid latestSpendingTxid,

    /// The hash of the block in which the spending transaction was confirmed.
    required String confirmationHash,

    /// The height at which the spending transaction was confirmed.
    required int confirmationHeight,

    /// The amount, in satoshis, of the output being swept.
    required BigInt amountSatoshis,
  }) = PendingSweepBalance_AwaitingThresholdConfirmations;
}

///A Secp256k1 public key, used for verification of signatures.
///
class PublicKey {
  final String hex;

  const PublicKey({
    required this.hex,
  });

  @override
  int get hashCode => hex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PublicKey &&
          runtimeType == other.runtimeType &&
          hex == other.hex;
}

/// Represents information used to send a payment.
class SendingParameters {
  /// The maximum total fees, in millisatoshi, that may accrue during route finding.
  ///
  /// This limit also applies to the total fees that may arise while retrying failed payment
  /// paths.
  ///
  /// Note that values below a few sats may result in some paths being spuriously ignored.
  final MaxTotalRoutingFeeLimit? maxTotalRoutingFeeMsat;

  /// The maximum total CLTV delta we accept for the route.
  ///
  /// Defaults to `DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA`.
  ///
  final int? maxTotalCltvExpiryDelta;

  /// The maximum number of paths that may be used by (MPP) payments.
  ///
  /// Defaults to `DEFAULT_MAX_PATH_COUNT`.
  final int? maxPathCount;

  /// Selects the maximum share of a channel's total capacity which will be sent over a channel,
  /// as a power of 1/2.
  ///
  /// A higher value prefers to send the payment using more MPP parts whereas
  /// a lower value prefers to send larger MPP parts, potentially saturating channels and
  /// increasing failure probability for those paths.
  ///
  /// Note that this restriction will be relaxed during pathfinding after paths which meet this
  /// restriction have been found. While paths which meet this criteria will be searched for, it
  /// is ultimately up to the scorer to select them over other paths.
  ///
  /// Examples:
  ///
  /// | Value | Max Proportion of Channel Capacity Used |
  /// |-------|-----------------------------------------|
  /// | 0     | Up to 100% of the channel’s capacity    |
  /// | 1     | Up to 50% of the channel’s capacity     |
  /// | 2     | Up to 25% of the channel’s capacity     |
  /// | 3     | Up to 12.5% of the channel’s capacity   |
  ///
  /// Default value: 2
  final int? maxChannelSaturationPowerOfHalf;

  const SendingParameters({
    this.maxTotalRoutingFeeMsat,
    this.maxTotalCltvExpiryDelta,
    this.maxPathCount,
    this.maxChannelSaturationPowerOfHalf,
  });

  @override
  int get hashCode =>
      maxTotalRoutingFeeMsat.hashCode ^
      maxTotalCltvExpiryDelta.hashCode ^
      maxPathCount.hashCode ^
      maxChannelSaturationPowerOfHalf.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendingParameters &&
          runtimeType == other.runtimeType &&
          maxTotalRoutingFeeMsat == other.maxTotalRoutingFeeMsat &&
          maxTotalCltvExpiryDelta == other.maxTotalCltvExpiryDelta &&
          maxPathCount == other.maxPathCount &&
          maxChannelSaturationPowerOfHalf ==
              other.maxChannelSaturationPowerOfHalf;
}

@freezed
sealed class SocketAddress with _$SocketAddress {
  const SocketAddress._();

  const factory SocketAddress.tcpIpV4({
    required U8Array4 addr,
    required int port,
  }) = SocketAddress_TcpIpV4;
  const factory SocketAddress.tcpIpV6({
    required U8Array16 addr,
    required int port,
  }) = SocketAddress_TcpIpV6;
  const factory SocketAddress.onionV2(
    U8Array12 field0,
  ) = SocketAddress_OnionV2;
  const factory SocketAddress.onionV3({
    required U8Array32 ed25519Pubkey,
    required int checksum,
    required int version,
    required int port,
  }) = SocketAddress_OnionV3;
  const factory SocketAddress.hostname({
    required String addr,
    required int port,
  }) = SocketAddress_Hostname;
}

///A bitcoin transaction hash/transaction ID.
///
class Txid {
  final String hash;

  const Txid({
    required this.hash,
  });

  @override
  int get hashCode => hash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Txid && runtimeType == other.runtimeType && hash == other.hash;
}

///A local, potentially user-provided, identifier of a channel.
///
/// By default, this will be randomly generated for the user to ensure local uniqueness.
///
class UserChannelId {
  final Uint8List data;

  const UserChannelId({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserChannelId &&
          runtimeType == other.runtimeType &&
          data == other.data;
}
