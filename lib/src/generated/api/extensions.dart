// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import '../third_party/ldk_adapter/types.dart';
import '../third_party/shared.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'extensions.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>
abstract class SocketAddress implements RustOpaqueInterface, ESocketAddress {
  @override
  SocketAddressType addressType();

  @override
  AddressHostname? toHostname();

  @override
  AddressOnionV2? toOnionV2();

  @override
  AddressOnionV3? toOnionV3();

  @override
  AddressTcpIpV4? toTcpIpV4();

  @override
  AddressTcpIpV6? toTcpIpV6();
}

abstract class ESocketAddress {
  SocketAddressType addressType();

  AddressHostname? toHostname();

  AddressOnionV2? toOnionV2();

  AddressOnionV3? toOnionV3();

  AddressTcpIpV4? toTcpIpV4();

  AddressTcpIpV6? toTcpIpV6();
}

class AddressHostname {
  final String addr;
  final int port;

  const AddressHostname({
    required this.addr,
    required this.port,
  });

  SocketAddress asSocket() =>
      core.instance.api.crateApiExtensionsAddressHostnameAsSocket(
        that: this,
      );

  @override
  int get hashCode => addr.hashCode ^ port.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddressHostname &&
          runtimeType == other.runtimeType &&
          addr == other.addr &&
          port == other.port;
}

class AddressOnionV2 {
  final U8Array12 field0;

  const AddressOnionV2({
    required this.field0,
  });

  SocketAddress asSocket() =>
      core.instance.api.crateApiExtensionsAddressOnionV2AsSocket(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddressOnionV2 &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class AddressOnionV3 {
  final U8Array32 ed25519Pubkey;
  final int checksum;
  final int version;
  final int port;

  const AddressOnionV3({
    required this.ed25519Pubkey,
    required this.checksum,
    required this.version,
    required this.port,
  });

  SocketAddress asSocket() =>
      core.instance.api.crateApiExtensionsAddressOnionV3AsSocket(
        that: this,
      );

  @override
  int get hashCode =>
      ed25519Pubkey.hashCode ^
      checksum.hashCode ^
      version.hashCode ^
      port.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddressOnionV3 &&
          runtimeType == other.runtimeType &&
          ed25519Pubkey == other.ed25519Pubkey &&
          checksum == other.checksum &&
          version == other.version &&
          port == other.port;
}

class AddressTcpIpV4 {
  final U8Array4 addr;
  final int port;

  const AddressTcpIpV4({
    required this.addr,
    required this.port,
  });

  SocketAddress asSocket() =>
      core.instance.api.crateApiExtensionsAddressTcpIpV4AsSocket(
        that: this,
      );

  @override
  int get hashCode => addr.hashCode ^ port.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddressTcpIpV4 &&
          runtimeType == other.runtimeType &&
          addr == other.addr &&
          port == other.port;
}

class AddressTcpIpV6 {
  final U8Array16 addr;
  final int port;

  const AddressTcpIpV6({
    required this.addr,
    required this.port,
  });

  SocketAddress asSocket() =>
      core.instance.api.crateApiExtensionsAddressTcpIpV6AsSocket(
        that: this,
      );

  @override
  int get hashCode => addr.hashCode ^ port.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddressTcpIpV6 &&
          runtimeType == other.runtimeType &&
          addr == other.addr &&
          port == other.port;
}

@freezed
sealed class ChainDataSourceConfig with _$ChainDataSourceConfig {
  const ChainDataSourceConfig._();

  const factory ChainDataSourceConfig.esplora({
    required String serverUrl,
    EsploraSyncConfig? syncConfig,
  }) = ChainDataSourceConfig_Esplora;
  const factory ChainDataSourceConfig.electrum({
    required String serverUrl,
    ElectrumSyncConfig? syncConfig,
  }) = ChainDataSourceConfig_Electrum;
  const factory ChainDataSourceConfig.bitcoindRpc({
    required String rpcHost,
    required int rpcPort,
    required String rpcUser,
    required String rpcPassword,
  }) = ChainDataSourceConfig_BitcoindRpc;
}

class Config {
  String storageDirPath;

  /// The used Bitcoin network.
  Network network;

  /// The IP address and TCP port the node will listen on.
  ///
  List<SocketAddress>? listeningAddresses;

  /// The addresses which the node will announce to the gossip network that it accepts connections on.
  List<SocketAddress>? announcementAddresses;

  /// The node alias that will be used when broadcasting announcements to the gossip network.
  ///
  /// The provided alias must be a valid UTF-8 string and no longer than 32 bytes in total.
  ///
  /// **Note**: We will only allow opening and accepting public channels if the `nodeAlias` and the
  /// `listeningAddresses` are set.
  NodeAlias? nodeAlias;

  ///A list of peers that we allow to establish zero confirmation channels to us.
  ///
  ///Note: Allowing payments via zero-confirmation channels is potentially insecure if the funding transaction ends up never being confirmed on-chain. Zero-confirmation channels should therefore only be accepted from trusted peers.
  List<PublicKey> trustedPeers0Conf;
  BigInt probingLiquidityLimitMultiplier;

  ///The level at which we log messages.
  /// Any messages below this level will be excluded from the logs.
  ///
  AnchorChannelsConfig? anchorChannelsConfig;

  /// Configuration options for payment routing and pathfinding.
  ///
  /// Setting the `SendingParameters` provides flexibility to customize how payments are routed,
  /// including setting limits on routing fees, CLTV expiry, and channel utilization.
  ///
  /// **Note:** If unset, default parameters will be used, and you will be able to override the
  /// parameters on a per-payment basis in the corresponding method calls.
  SendingParameters? sendingParameters;

  Config({
    required this.storageDirPath,
    required this.network,
    this.listeningAddresses,
    this.announcementAddresses,
    this.nodeAlias,
    required this.trustedPeers0Conf,
    required this.probingLiquidityLimitMultiplier,
    this.anchorChannelsConfig,
    this.sendingParameters,
  });

  static Future<Config> default_() =>
      core.instance.api.crateApiExtensionsConfigDefault();

  @override
  int get hashCode =>
      storageDirPath.hashCode ^
      network.hashCode ^
      listeningAddresses.hashCode ^
      announcementAddresses.hashCode ^
      nodeAlias.hashCode ^
      trustedPeers0Conf.hashCode ^
      probingLiquidityLimitMultiplier.hashCode ^
      anchorChannelsConfig.hashCode ^
      sendingParameters.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          storageDirPath == other.storageDirPath &&
          network == other.network &&
          listeningAddresses == other.listeningAddresses &&
          announcementAddresses == other.announcementAddresses &&
          nodeAlias == other.nodeAlias &&
          trustedPeers0Conf == other.trustedPeers0Conf &&
          probingLiquidityLimitMultiplier ==
              other.probingLiquidityLimitMultiplier &&
          anchorChannelsConfig == other.anchorChannelsConfig &&
          sendingParameters == other.sendingParameters;
}

@freezed
sealed class EntropySourceConfig with _$EntropySourceConfig {
  const EntropySourceConfig._();

  const factory EntropySourceConfig.seedFile(
    String field0,
  ) = EntropySourceConfig_SeedFile;
  const factory EntropySourceConfig.seedBytes(
    Uint8List field0,
  ) = EntropySourceConfig_SeedBytes;
  const factory EntropySourceConfig.bip39Mnemonic(
    Mnemonic field0, [
    String? field1,
  ]) = EntropySourceConfig_Bip39Mnemonic;
}

@freezed
sealed class GossipSourceConfig with _$GossipSourceConfig {
  const GossipSourceConfig._();

  const factory GossipSourceConfig.p2PNetwork() = GossipSourceConfig_P2PNetwork;
  const factory GossipSourceConfig.rapidGossipSync(
    String field0,
  ) = GossipSourceConfig_RapidGossipSync;
}

enum SocketAddressType {
  tcpIpV4,
  tcpIpV6,
  onionV2,
  onionV3,
  hostname,
  ;
}
