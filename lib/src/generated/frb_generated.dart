// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/bolt11.dart';
import 'api/bolt12.dart';
import 'api/builder.dart';
import 'api/graph.dart';
import 'api/node.dart';
import 'api/on_chain.dart';
import 'api/spontaneous.dart';
import 'api/types.dart';
import 'api/unified_qr.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'utils/error.dart';

/// Main entrypoint of the Rust API
class core extends BaseEntrypoint<coreApi, coreApiImpl, coreWire> {
  @internal
  static final instance = core._();

  core._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    coreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required coreApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<coreApiImpl, coreWire> get apiImplConstructor =>
      coreApiImpl.new;

  @override
  WireConstructor<coreWire> get wireConstructor => coreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.4.0';

  @override
  int get rustContentHash => 968713453;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'ldk_node',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class coreApi extends BaseApi {
  Future<void> crateApiBolt11FfiBolt11PaymentClaimForHash(
      {required FfiBolt11Payment that,
      required PaymentHash paymentHash,
      required BigInt claimableAmountMsat,
      required PaymentPreimage preimage});

  Future<void> crateApiBolt11FfiBolt11PaymentFailForHash(
      {required FfiBolt11Payment that, required PaymentHash paymentHash});

  Future<Bolt11Invoice> crateApiBolt11FfiBolt11PaymentReceive(
      {required FfiBolt11Payment that,
      required BigInt amountMsat,
      required String description,
      required int expirySecs});

  Future<Bolt11Invoice> crateApiBolt11FfiBolt11PaymentReceiveForHash(
      {required FfiBolt11Payment that,
      required PaymentHash paymentHash,
      required BigInt amountMsat,
      required String description,
      required int expirySecs});

  Future<Bolt11Invoice> crateApiBolt11FfiBolt11PaymentReceiveVariableAmount(
      {required FfiBolt11Payment that,
      required String description,
      required int expirySecs});

  Future<Bolt11Invoice>
      crateApiBolt11FfiBolt11PaymentReceiveVariableAmountForHash(
          {required FfiBolt11Payment that,
          required String description,
          required int expirySecs,
          required PaymentHash paymentHash});

  Future<Bolt11Invoice>
      crateApiBolt11FfiBolt11PaymentReceiveVariableAmountViaJitChannel(
          {required FfiBolt11Payment that,
          required String description,
          required int expirySecs,
          BigInt? maxProportionalLspFeeLimitPpmMsat});

  Future<Bolt11Invoice> crateApiBolt11FfiBolt11PaymentReceiveViaJitChannel(
      {required FfiBolt11Payment that,
      required BigInt amountMsat,
      required String description,
      required int expirySecs,
      BigInt? maxTotalLspFeeLimitMsat});

  Future<PaymentId> crateApiBolt11FfiBolt11PaymentSend(
      {required FfiBolt11Payment that,
      required Bolt11Invoice invoice,
      SendingParameters? sendingParameters});

  Future<void> crateApiBolt11FfiBolt11PaymentSendProbes(
      {required FfiBolt11Payment that, required Bolt11Invoice invoice});

  Future<void> crateApiBolt11FfiBolt11PaymentSendProbesUsingAmount(
      {required FfiBolt11Payment that,
      required Bolt11Invoice invoice,
      required BigInt amountMsat});

  Future<PaymentId> crateApiBolt11FfiBolt11PaymentSendUsingAmount(
      {required FfiBolt11Payment that,
      required Bolt11Invoice invoice,
      required BigInt amountMsat,
      SendingParameters? sendingParameters});

  Future<Refund> crateApiBolt12FfiBolt12PaymentInitiateRefund(
      {required FfiBolt12Payment that,
      required BigInt amountMsat,
      required int expirySecs,
      BigInt? quantity,
      String? payerNote});

  Future<Offer> crateApiBolt12FfiBolt12PaymentReceive(
      {required FfiBolt12Payment that,
      required BigInt amountMsat,
      required String description,
      int? expirySecs,
      BigInt? quantity});

  Future<Offer> crateApiBolt12FfiBolt12PaymentReceiveVariableAmount(
      {required FfiBolt12Payment that,
      required String description,
      int? expirySecs});

  Future<Bolt12Invoice> crateApiBolt12FfiBolt12PaymentRequestRefundPayment(
      {required FfiBolt12Payment that, required Refund refund});

  Future<PaymentId> crateApiBolt12FfiBolt12PaymentSend(
      {required FfiBolt12Payment that,
      required Offer offer,
      BigInt? quantity,
      String? payerNote});

  Future<PaymentId> crateApiBolt12FfiBolt12PaymentSendUsingAmount(
      {required FfiBolt12Payment that,
      required Offer offer,
      required BigInt amountMsat,
      BigInt? quantity,
      String? payerNote});

  Builder crateApiBuilderFfiBuilderAutoAccessorGetOpaque(
      {required FfiBuilder that});

  void crateApiBuilderFfiBuilderAutoAccessorSetOpaque(
      {required FfiBuilder that, required Builder opaque});

  Future<FfiNode> crateApiBuilderFfiBuilderBuild({required FfiBuilder that});

  Future<FfiNode> crateApiBuilderFfiBuilderBuildWithFsStore(
      {required FfiBuilder that});

  Future<FfiNode> crateApiBuilderFfiBuilderBuildWithVssStore(
      {required FfiBuilder that,
      required String vssUrl,
      required String storeId,
      required String lnurlAuthServerUrl,
      required Map<String, String> fixedHeaders});

  Future<FfiNode> crateApiBuilderFfiBuilderBuildWithVssStoreAndFixedHeaders(
      {required FfiBuilder that,
      required String vssUrl,
      required String storeId,
      required Map<String, String> fixedHeaders});

  FfiBuilder crateApiBuilderFfiBuilderCreateBuilder(
      {required Config config,
      ChainDataSourceConfig? chainDataSourceConfig,
      EntropySourceConfig? entropySourceConfig,
      GossipSourceConfig? gossipSourceConfig,
      LiquiditySourceConfig? liquiditySourceConfig});

  Future<FfiMnemonic> crateApiBuilderFfiMnemonicGenerate();

  Future<ChannelInfo?> crateApiGraphFfiNetworkGraphChannel(
      {required FfiNetworkGraph that, required BigInt shortChannelId});

  Future<Uint64List> crateApiGraphFfiNetworkGraphListChannels(
      {required FfiNetworkGraph that});

  Future<List<NodeId>> crateApiGraphFfiNetworkGraphListNodes(
      {required FfiNetworkGraph that});

  Future<NodeInfo?> crateApiGraphFfiNetworkGraphNode(
      {required FfiNetworkGraph that, required NodeId nodeId});

  Future<FfiBolt11Payment> crateApiNodeFfiNodeBolt11Payment(
      {required FfiNode ptr});

  Future<FfiBolt12Payment> crateApiNodeFfiNodeBolt12Payment(
      {required FfiNode ptr});

  Future<void> crateApiNodeFfiNodeCloseChannel(
      {required FfiNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId});

  Future<Config> crateApiNodeFfiNodeConfig({required FfiNode that});

  Future<void> crateApiNodeFfiNodeConnect(
      {required FfiNode that,
      required PublicKey nodeId,
      required SocketAddress address,
      required bool persist});

  Future<void> crateApiNodeFfiNodeDisconnect(
      {required FfiNode that, required PublicKey counterpartyNodeId});

  Future<void> crateApiNodeFfiNodeEventHandled({required FfiNode that});

  Future<void> crateApiNodeFfiNodeForceCloseChannel(
      {required FfiNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId});

  Future<BalanceDetails> crateApiNodeFfiNodeListBalances(
      {required FfiNode that});

  Future<List<ChannelDetails>> crateApiNodeFfiNodeListChannels(
      {required FfiNode that});

  Future<List<PaymentDetails>> crateApiNodeFfiNodeListPayments(
      {required FfiNode that});

  Future<List<PaymentDetails>> crateApiNodeFfiNodeListPaymentsWithFilter(
      {required FfiNode that, required PaymentDirection paymentDirection});

  Future<List<PeerDetails>> crateApiNodeFfiNodeListPeers(
      {required FfiNode that});

  Future<List<SocketAddress>?> crateApiNodeFfiNodeListeningAddresses(
      {required FfiNode that});

  Future<FfiNetworkGraph> crateApiNodeFfiNodeNetworkGraph(
      {required FfiNode ptr});

  Future<Event?> crateApiNodeFfiNodeNextEvent({required FfiNode that});

  Future<Event> crateApiNodeFfiNodeNextEventAsync({required FfiNode that});

  Future<PublicKey> crateApiNodeFfiNodeNodeId({required FfiNode that});

  Future<FfiOnChainPayment> crateApiNodeFfiNodeOnChainPayment(
      {required FfiNode ptr});

  Future<UserChannelId> crateApiNodeFfiNodeOpenAnnouncedChannel(
      {required FfiNode that,
      required SocketAddress socketAddress,
      required PublicKey nodeId,
      required BigInt channelAmountSats,
      BigInt? pushToCounterpartyMsat,
      ChannelConfig? channelConfig});

  Future<UserChannelId> crateApiNodeFfiNodeOpenChannel(
      {required FfiNode that,
      required SocketAddress socketAddress,
      required PublicKey nodeId,
      required BigInt channelAmountSats,
      BigInt? pushToCounterpartyMsat,
      ChannelConfig? channelConfig});

  Future<PaymentDetails?> crateApiNodeFfiNodePayment(
      {required FfiNode that, required PaymentId paymentId});

  Future<void> crateApiNodeFfiNodeRemovePayment(
      {required FfiNode that, required PaymentId paymentId});

  Future<String> crateApiNodeFfiNodeSignMessage(
      {required FfiNode that, required List<int> msg});

  Future<FfiSpontaneousPayment> crateApiNodeFfiNodeSpontaneousPayment(
      {required FfiNode ptr});

  Future<void> crateApiNodeFfiNodeStart({required FfiNode that});

  Future<NodeStatus> crateApiNodeFfiNodeStatus({required FfiNode that});

  Future<void> crateApiNodeFfiNodeStop({required FfiNode that});

  Future<void> crateApiNodeFfiNodeSyncWallets({required FfiNode that});

  Future<FfiUnifiedQrPayment> crateApiNodeFfiNodeUnifiedQrPayment(
      {required FfiNode ptr});

  Future<void> crateApiNodeFfiNodeUpdateChannelConfig(
      {required FfiNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId,
      required ChannelConfig channelConfig});

  Future<bool> crateApiNodeFfiNodeVerifySignature(
      {required FfiNode that,
      required List<int> msg,
      required String sig,
      required PublicKey publicKey});

  Future<Event> crateApiNodeFfiNodeWaitNextEvent({required FfiNode that});

  Future<Address> crateApiOnChainFfiOnChainPaymentNewAddress(
      {required FfiOnChainPayment that});

  Future<Txid> crateApiOnChainFfiOnChainPaymentSendAllToAddress(
      {required FfiOnChainPayment that, required Address address});

  Future<Txid> crateApiOnChainFfiOnChainPaymentSendToAddress(
      {required FfiOnChainPayment that,
      required Address address,
      required BigInt amountSats});

  Future<PaymentId> crateApiSpontaneousFfiSpontaneousPaymentSend(
      {required FfiSpontaneousPayment that,
      required BigInt amountMsat,
      required PublicKey nodeId,
      SendingParameters? sendingParameters});

  Future<void> crateApiSpontaneousFfiSpontaneousPaymentSendProbes(
      {required FfiSpontaneousPayment that,
      required BigInt amountMsat,
      required PublicKey nodeId});

  Future<AnchorChannelsConfig> crateApiTypesAnchorChannelsConfigDefault();

  Future<Config> crateApiTypesConfigDefault();

  Future<String> crateApiUnifiedQrFfiUnifiedQrPaymentReceive(
      {required FfiUnifiedQrPayment that,
      required BigInt amountSats,
      required String message,
      required int expirySec});

  Future<QrPaymentResult> crateApiUnifiedQrFfiUnifiedQrPaymentSend(
      {required FfiUnifiedQrPayment that, required String uriStr});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_FfiBuilder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_FfiBuilder;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FfiBuilderPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Builder;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Builder;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_BuilderPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Node;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Node;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NodePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NetworkGraph;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NetworkGraph;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NetworkGraphPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Bolt11Payment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Bolt11Payment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_Bolt11PaymentPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Bolt12Payment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Bolt12Payment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_Bolt12PaymentPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OnchainPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OnchainPayment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_OnchainPaymentPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SpontaneousPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SpontaneousPayment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_SpontaneousPaymentPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_UnifiedQrPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_UnifiedQrPayment;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_UnifiedQrPaymentPtr;
}

class coreApiImpl extends coreApiImplPlatform implements coreApi {
  coreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiBolt11FfiBolt11PaymentClaimForHash(
      {required FfiBolt11Payment that,
      required PaymentHash paymentHash,
      required BigInt claimableAmountMsat,
      required PaymentPreimage preimage}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_payment_hash(paymentHash);
        var arg2 = cst_encode_u_64(claimableAmountMsat);
        var arg3 = cst_encode_box_autoadd_payment_preimage(preimage);
        return wire
            .wire__crate__api__bolt11__ffi_bolt_11_payment_claim_for_hash(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt11FfiBolt11PaymentClaimForHashConstMeta,
      argValues: [that, paymentHash, claimableAmountMsat, preimage],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11FfiBolt11PaymentClaimForHashConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_11_payment_claim_for_hash",
        argNames: ["that", "paymentHash", "claimableAmountMsat", "preimage"],
      );

  @override
  Future<void> crateApiBolt11FfiBolt11PaymentFailForHash(
      {required FfiBolt11Payment that, required PaymentHash paymentHash}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_payment_hash(paymentHash);
        return wire.wire__crate__api__bolt11__ffi_bolt_11_payment_fail_for_hash(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt11FfiBolt11PaymentFailForHashConstMeta,
      argValues: [that, paymentHash],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11FfiBolt11PaymentFailForHashConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_11_payment_fail_for_hash",
        argNames: ["that", "paymentHash"],
      );

  @override
  Future<Bolt11Invoice> crateApiBolt11FfiBolt11PaymentReceive(
      {required FfiBolt11Payment that,
      required BigInt amountMsat,
      required String description,
      required int expirySecs}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_String(description);
        var arg3 = cst_encode_u_32(expirySecs);
        return wire.wire__crate__api__bolt11__ffi_bolt_11_payment_receive(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt11FfiBolt11PaymentReceiveConstMeta,
      argValues: [that, amountMsat, description, expirySecs],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11FfiBolt11PaymentReceiveConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_11_payment_receive",
        argNames: ["that", "amountMsat", "description", "expirySecs"],
      );

  @override
  Future<Bolt11Invoice> crateApiBolt11FfiBolt11PaymentReceiveForHash(
      {required FfiBolt11Payment that,
      required PaymentHash paymentHash,
      required BigInt amountMsat,
      required String description,
      required int expirySecs}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_payment_hash(paymentHash);
        var arg2 = cst_encode_u_64(amountMsat);
        var arg3 = cst_encode_String(description);
        var arg4 = cst_encode_u_32(expirySecs);
        return wire
            .wire__crate__api__bolt11__ffi_bolt_11_payment_receive_for_hash(
                port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt11FfiBolt11PaymentReceiveForHashConstMeta,
      argValues: [that, paymentHash, amountMsat, description, expirySecs],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11FfiBolt11PaymentReceiveForHashConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_11_payment_receive_for_hash",
        argNames: [
          "that",
          "paymentHash",
          "amountMsat",
          "description",
          "expirySecs"
        ],
      );

  @override
  Future<Bolt11Invoice> crateApiBolt11FfiBolt11PaymentReceiveVariableAmount(
      {required FfiBolt11Payment that,
      required String description,
      required int expirySecs}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_String(description);
        var arg2 = cst_encode_u_32(expirySecs);
        return wire
            .wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt11FfiBolt11PaymentReceiveVariableAmountConstMeta,
      argValues: [that, description, expirySecs],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt11FfiBolt11PaymentReceiveVariableAmountConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_bolt_11_payment_receive_variable_amount",
            argNames: ["that", "description", "expirySecs"],
          );

  @override
  Future<Bolt11Invoice>
      crateApiBolt11FfiBolt11PaymentReceiveVariableAmountForHash(
          {required FfiBolt11Payment that,
          required String description,
          required int expirySecs,
          required PaymentHash paymentHash}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_String(description);
        var arg2 = cst_encode_u_32(expirySecs);
        var arg3 = cst_encode_box_autoadd_payment_hash(paymentHash);
        return wire
            .wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount_for_hash(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta:
          kCrateApiBolt11FfiBolt11PaymentReceiveVariableAmountForHashConstMeta,
      argValues: [that, description, expirySecs, paymentHash],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt11FfiBolt11PaymentReceiveVariableAmountForHashConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_bolt_11_payment_receive_variable_amount_for_hash",
            argNames: ["that", "description", "expirySecs", "paymentHash"],
          );

  @override
  Future<Bolt11Invoice>
      crateApiBolt11FfiBolt11PaymentReceiveVariableAmountViaJitChannel(
          {required FfiBolt11Payment that,
          required String description,
          required int expirySecs,
          BigInt? maxProportionalLspFeeLimitPpmMsat}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_String(description);
        var arg2 = cst_encode_u_32(expirySecs);
        var arg3 =
            cst_encode_opt_box_autoadd_u_64(maxProportionalLspFeeLimitPpmMsat);
        return wire
            .wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount_via_jit_channel(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta:
          kCrateApiBolt11FfiBolt11PaymentReceiveVariableAmountViaJitChannelConstMeta,
      argValues: [
        that,
        description,
        expirySecs,
        maxProportionalLspFeeLimitPpmMsat
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt11FfiBolt11PaymentReceiveVariableAmountViaJitChannelConstMeta =>
          const TaskConstMeta(
            debugName:
                "ffi_bolt_11_payment_receive_variable_amount_via_jit_channel",
            argNames: [
              "that",
              "description",
              "expirySecs",
              "maxProportionalLspFeeLimitPpmMsat"
            ],
          );

  @override
  Future<Bolt11Invoice> crateApiBolt11FfiBolt11PaymentReceiveViaJitChannel(
      {required FfiBolt11Payment that,
      required BigInt amountMsat,
      required String description,
      required int expirySecs,
      BigInt? maxTotalLspFeeLimitMsat}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_String(description);
        var arg3 = cst_encode_u_32(expirySecs);
        var arg4 = cst_encode_opt_box_autoadd_u_64(maxTotalLspFeeLimitMsat);
        return wire
            .wire__crate__api__bolt11__ffi_bolt_11_payment_receive_via_jit_channel(
                port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_11_invoice,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt11FfiBolt11PaymentReceiveViaJitChannelConstMeta,
      argValues: [
        that,
        amountMsat,
        description,
        expirySecs,
        maxTotalLspFeeLimitMsat
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt11FfiBolt11PaymentReceiveViaJitChannelConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_bolt_11_payment_receive_via_jit_channel",
            argNames: [
              "that",
              "amountMsat",
              "description",
              "expirySecs",
              "maxTotalLspFeeLimitMsat"
            ],
          );

  @override
  Future<PaymentId> crateApiBolt11FfiBolt11PaymentSend(
      {required FfiBolt11Payment that,
      required Bolt11Invoice invoice,
      SendingParameters? sendingParameters}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        var arg2 =
            cst_encode_opt_box_autoadd_sending_parameters(sendingParameters);
        return wire.wire__crate__api__bolt11__ffi_bolt_11_payment_send(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt11FfiBolt11PaymentSendConstMeta,
      argValues: [that, invoice, sendingParameters],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11FfiBolt11PaymentSendConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_11_payment_send",
        argNames: ["that", "invoice", "sendingParameters"],
      );

  @override
  Future<void> crateApiBolt11FfiBolt11PaymentSendProbes(
      {required FfiBolt11Payment that, required Bolt11Invoice invoice}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        return wire.wire__crate__api__bolt11__ffi_bolt_11_payment_send_probes(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt11FfiBolt11PaymentSendProbesConstMeta,
      argValues: [that, invoice],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11FfiBolt11PaymentSendProbesConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_11_payment_send_probes",
        argNames: ["that", "invoice"],
      );

  @override
  Future<void> crateApiBolt11FfiBolt11PaymentSendProbesUsingAmount(
      {required FfiBolt11Payment that,
      required Bolt11Invoice invoice,
      required BigInt amountMsat}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        var arg2 = cst_encode_u_64(amountMsat);
        return wire
            .wire__crate__api__bolt11__ffi_bolt_11_payment_send_probes_using_amount(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt11FfiBolt11PaymentSendProbesUsingAmountConstMeta,
      argValues: [that, invoice, amountMsat],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt11FfiBolt11PaymentSendProbesUsingAmountConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_bolt_11_payment_send_probes_using_amount",
            argNames: ["that", "invoice", "amountMsat"],
          );

  @override
  Future<PaymentId> crateApiBolt11FfiBolt11PaymentSendUsingAmount(
      {required FfiBolt11Payment that,
      required Bolt11Invoice invoice,
      required BigInt amountMsat,
      SendingParameters? sendingParameters}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_11_payment(that);
        var arg1 = cst_encode_box_autoadd_bolt_11_invoice(invoice);
        var arg2 = cst_encode_u_64(amountMsat);
        var arg3 =
            cst_encode_opt_box_autoadd_sending_parameters(sendingParameters);
        return wire
            .wire__crate__api__bolt11__ffi_bolt_11_payment_send_using_amount(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt11FfiBolt11PaymentSendUsingAmountConstMeta,
      argValues: [that, invoice, amountMsat, sendingParameters],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt11FfiBolt11PaymentSendUsingAmountConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_11_payment_send_using_amount",
        argNames: ["that", "invoice", "amountMsat", "sendingParameters"],
      );

  @override
  Future<Refund> crateApiBolt12FfiBolt12PaymentInitiateRefund(
      {required FfiBolt12Payment that,
      required BigInt amountMsat,
      required int expirySecs,
      BigInt? quantity,
      String? payerNote}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_12_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_u_32(expirySecs);
        var arg3 = cst_encode_opt_box_autoadd_u_64(quantity);
        var arg4 = cst_encode_opt_String(payerNote);
        return wire
            .wire__crate__api__bolt12__ffi_bolt_12_payment_initiate_refund(
                port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_refund,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt12FfiBolt12PaymentInitiateRefundConstMeta,
      argValues: [that, amountMsat, expirySecs, quantity, payerNote],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt12FfiBolt12PaymentInitiateRefundConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_12_payment_initiate_refund",
        argNames: ["that", "amountMsat", "expirySecs", "quantity", "payerNote"],
      );

  @override
  Future<Offer> crateApiBolt12FfiBolt12PaymentReceive(
      {required FfiBolt12Payment that,
      required BigInt amountMsat,
      required String description,
      int? expirySecs,
      BigInt? quantity}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_12_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_String(description);
        var arg3 = cst_encode_opt_box_autoadd_u_32(expirySecs);
        var arg4 = cst_encode_opt_box_autoadd_u_64(quantity);
        return wire.wire__crate__api__bolt12__ffi_bolt_12_payment_receive(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_offer,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt12FfiBolt12PaymentReceiveConstMeta,
      argValues: [that, amountMsat, description, expirySecs, quantity],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt12FfiBolt12PaymentReceiveConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_12_payment_receive",
        argNames: [
          "that",
          "amountMsat",
          "description",
          "expirySecs",
          "quantity"
        ],
      );

  @override
  Future<Offer> crateApiBolt12FfiBolt12PaymentReceiveVariableAmount(
      {required FfiBolt12Payment that,
      required String description,
      int? expirySecs}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_12_payment(that);
        var arg1 = cst_encode_String(description);
        var arg2 = cst_encode_opt_box_autoadd_u_32(expirySecs);
        return wire
            .wire__crate__api__bolt12__ffi_bolt_12_payment_receive_variable_amount(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_offer,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt12FfiBolt12PaymentReceiveVariableAmountConstMeta,
      argValues: [that, description, expirySecs],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt12FfiBolt12PaymentReceiveVariableAmountConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_bolt_12_payment_receive_variable_amount",
            argNames: ["that", "description", "expirySecs"],
          );

  @override
  Future<Bolt12Invoice> crateApiBolt12FfiBolt12PaymentRequestRefundPayment(
      {required FfiBolt12Payment that, required Refund refund}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_12_payment(that);
        var arg1 = cst_encode_box_autoadd_refund(refund);
        return wire
            .wire__crate__api__bolt12__ffi_bolt_12_payment_request_refund_payment(
                port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bolt_12_invoice,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt12FfiBolt12PaymentRequestRefundPaymentConstMeta,
      argValues: [that, refund],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBolt12FfiBolt12PaymentRequestRefundPaymentConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_bolt_12_payment_request_refund_payment",
            argNames: ["that", "refund"],
          );

  @override
  Future<PaymentId> crateApiBolt12FfiBolt12PaymentSend(
      {required FfiBolt12Payment that,
      required Offer offer,
      BigInt? quantity,
      String? payerNote}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_12_payment(that);
        var arg1 = cst_encode_box_autoadd_offer(offer);
        var arg2 = cst_encode_opt_box_autoadd_u_64(quantity);
        var arg3 = cst_encode_opt_String(payerNote);
        return wire.wire__crate__api__bolt12__ffi_bolt_12_payment_send(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt12FfiBolt12PaymentSendConstMeta,
      argValues: [that, offer, quantity, payerNote],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt12FfiBolt12PaymentSendConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_12_payment_send",
        argNames: ["that", "offer", "quantity", "payerNote"],
      );

  @override
  Future<PaymentId> crateApiBolt12FfiBolt12PaymentSendUsingAmount(
      {required FfiBolt12Payment that,
      required Offer offer,
      required BigInt amountMsat,
      BigInt? quantity,
      String? payerNote}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_bolt_12_payment(that);
        var arg1 = cst_encode_box_autoadd_offer(offer);
        var arg2 = cst_encode_u_64(amountMsat);
        var arg3 = cst_encode_opt_box_autoadd_u_64(quantity);
        var arg4 = cst_encode_opt_String(payerNote);
        return wire
            .wire__crate__api__bolt12__ffi_bolt_12_payment_send_using_amount(
                port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiBolt12FfiBolt12PaymentSendUsingAmountConstMeta,
      argValues: [that, offer, amountMsat, quantity, payerNote],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBolt12FfiBolt12PaymentSendUsingAmountConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_bolt_12_payment_send_using_amount",
        argNames: ["that", "offer", "amountMsat", "quantity", "payerNote"],
      );

  @override
  Builder crateApiBuilderFfiBuilderAutoAccessorGetOpaque(
      {required FfiBuilder that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
                that);
        return wire
            .wire__crate__api__builder__FfiBuilder_auto_accessor_get_opaque(
                arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_RustOpaque_ldk_nodeBuilder,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBuilderFfiBuilderAutoAccessorGetOpaqueConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderFfiBuilderAutoAccessorGetOpaqueConstMeta =>
      const TaskConstMeta(
        debugName: "FfiBuilder_auto_accessor_get_opaque",
        argNames: ["that"],
      );

  @override
  void crateApiBuilderFfiBuilderAutoAccessorSetOpaque(
      {required FfiBuilder that, required Builder opaque}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
                that);
        var arg1 = cst_encode_RustOpaque_ldk_nodeBuilder(opaque);
        return wire
            .wire__crate__api__builder__FfiBuilder_auto_accessor_set_opaque(
                arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBuilderFfiBuilderAutoAccessorSetOpaqueConstMeta,
      argValues: [that, opaque],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderFfiBuilderAutoAccessorSetOpaqueConstMeta =>
      const TaskConstMeta(
        debugName: "FfiBuilder_auto_accessor_set_opaque",
        argNames: ["that", "opaque"],
      );

  @override
  Future<FfiNode> crateApiBuilderFfiBuilderBuild({required FfiBuilder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
                that);
        return wire.wire__crate__api__builder__FfiBuilder_build(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_node,
        decodeErrorData: dco_decode_ffi_builder_error,
      ),
      constMeta: kCrateApiBuilderFfiBuilderBuildConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderFfiBuilderBuildConstMeta =>
      const TaskConstMeta(
        debugName: "FfiBuilder_build",
        argNames: ["that"],
      );

  @override
  Future<FfiNode> crateApiBuilderFfiBuilderBuildWithFsStore(
      {required FfiBuilder that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
                that);
        return wire.wire__crate__api__builder__FfiBuilder_build_with_fs_store(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_node,
        decodeErrorData: dco_decode_ffi_builder_error,
      ),
      constMeta: kCrateApiBuilderFfiBuilderBuildWithFsStoreConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderFfiBuilderBuildWithFsStoreConstMeta =>
      const TaskConstMeta(
        debugName: "FfiBuilder_build_with_fs_store",
        argNames: ["that"],
      );

  @override
  Future<FfiNode> crateApiBuilderFfiBuilderBuildWithVssStore(
      {required FfiBuilder that,
      required String vssUrl,
      required String storeId,
      required String lnurlAuthServerUrl,
      required Map<String, String> fixedHeaders}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
                that);
        var arg1 = cst_encode_String(vssUrl);
        var arg2 = cst_encode_String(storeId);
        var arg3 = cst_encode_String(lnurlAuthServerUrl);
        var arg4 = cst_encode_Map_String_String(fixedHeaders);
        return wire.wire__crate__api__builder__FfiBuilder_build_with_vss_store(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_node,
        decodeErrorData: dco_decode_ffi_builder_error,
      ),
      constMeta: kCrateApiBuilderFfiBuilderBuildWithVssStoreConstMeta,
      argValues: [that, vssUrl, storeId, lnurlAuthServerUrl, fixedHeaders],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderFfiBuilderBuildWithVssStoreConstMeta =>
      const TaskConstMeta(
        debugName: "FfiBuilder_build_with_vss_store",
        argNames: [
          "that",
          "vssUrl",
          "storeId",
          "lnurlAuthServerUrl",
          "fixedHeaders"
        ],
      );

  @override
  Future<FfiNode> crateApiBuilderFfiBuilderBuildWithVssStoreAndFixedHeaders(
      {required FfiBuilder that,
      required String vssUrl,
      required String storeId,
      required Map<String, String> fixedHeaders}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
                that);
        var arg1 = cst_encode_String(vssUrl);
        var arg2 = cst_encode_String(storeId);
        var arg3 = cst_encode_Map_String_String(fixedHeaders);
        return wire
            .wire__crate__api__builder__FfiBuilder_build_with_vss_store_and_fixed_headers(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_node,
        decodeErrorData: dco_decode_ffi_builder_error,
      ),
      constMeta:
          kCrateApiBuilderFfiBuilderBuildWithVssStoreAndFixedHeadersConstMeta,
      argValues: [that, vssUrl, storeId, fixedHeaders],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiBuilderFfiBuilderBuildWithVssStoreAndFixedHeadersConstMeta =>
          const TaskConstMeta(
            debugName: "FfiBuilder_build_with_vss_store_and_fixed_headers",
            argNames: ["that", "vssUrl", "storeId", "fixedHeaders"],
          );

  @override
  FfiBuilder crateApiBuilderFfiBuilderCreateBuilder(
      {required Config config,
      ChainDataSourceConfig? chainDataSourceConfig,
      EntropySourceConfig? entropySourceConfig,
      GossipSourceConfig? gossipSourceConfig,
      LiquiditySourceConfig? liquiditySourceConfig}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_box_autoadd_config(config);
        var arg1 = cst_encode_opt_box_autoadd_chain_data_source_config(
            chainDataSourceConfig);
        var arg2 = cst_encode_opt_box_autoadd_entropy_source_config(
            entropySourceConfig);
        var arg3 =
            cst_encode_opt_box_autoadd_gossip_source_config(gossipSourceConfig);
        var arg4 = cst_encode_opt_box_autoadd_liquidity_source_config(
            liquiditySourceConfig);
        return wire.wire__crate__api__builder__FfiBuilder_create_builder(
            arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder,
        decodeErrorData: dco_decode_ffi_builder_error,
      ),
      constMeta: kCrateApiBuilderFfiBuilderCreateBuilderConstMeta,
      argValues: [
        config,
        chainDataSourceConfig,
        entropySourceConfig,
        gossipSourceConfig,
        liquiditySourceConfig
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderFfiBuilderCreateBuilderConstMeta =>
      const TaskConstMeta(
        debugName: "FfiBuilder_create_builder",
        argNames: [
          "config",
          "chainDataSourceConfig",
          "entropySourceConfig",
          "gossipSourceConfig",
          "liquiditySourceConfig"
        ],
      );

  @override
  Future<FfiMnemonic> crateApiBuilderFfiMnemonicGenerate() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__builder__ffi_mnemonic_generate(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_mnemonic,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBuilderFfiMnemonicGenerateConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBuilderFfiMnemonicGenerateConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_mnemonic_generate",
        argNames: [],
      );

  @override
  Future<ChannelInfo?> crateApiGraphFfiNetworkGraphChannel(
      {required FfiNetworkGraph that, required BigInt shortChannelId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_network_graph(that);
        var arg1 = cst_encode_u_64(shortChannelId);
        return wire.wire__crate__api__graph__ffi_network_graph_channel(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_channel_info,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGraphFfiNetworkGraphChannelConstMeta,
      argValues: [that, shortChannelId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGraphFfiNetworkGraphChannelConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_network_graph_channel",
        argNames: ["that", "shortChannelId"],
      );

  @override
  Future<Uint64List> crateApiGraphFfiNetworkGraphListChannels(
      {required FfiNetworkGraph that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_network_graph(that);
        return wire.wire__crate__api__graph__ffi_network_graph_list_channels(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_64_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGraphFfiNetworkGraphListChannelsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGraphFfiNetworkGraphListChannelsConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_network_graph_list_channels",
        argNames: ["that"],
      );

  @override
  Future<List<NodeId>> crateApiGraphFfiNetworkGraphListNodes(
      {required FfiNetworkGraph that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_network_graph(that);
        return wire.wire__crate__api__graph__ffi_network_graph_list_nodes(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_node_id,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiGraphFfiNetworkGraphListNodesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGraphFfiNetworkGraphListNodesConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_network_graph_list_nodes",
        argNames: ["that"],
      );

  @override
  Future<NodeInfo?> crateApiGraphFfiNetworkGraphNode(
      {required FfiNetworkGraph that, required NodeId nodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_network_graph(that);
        var arg1 = cst_encode_box_autoadd_node_id(nodeId);
        return wire.wire__crate__api__graph__ffi_network_graph_node(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_node_info,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiGraphFfiNetworkGraphNodeConstMeta,
      argValues: [that, nodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiGraphFfiNetworkGraphNodeConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_network_graph_node",
        argNames: ["that", "nodeId"],
      );

  @override
  Future<FfiBolt11Payment> crateApiNodeFfiNodeBolt11Payment(
      {required FfiNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(ptr);
        return wire.wire__crate__api__node__ffi_node_bolt11_payment(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_bolt_11_payment,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeBolt11PaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeBolt11PaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_bolt11_payment",
        argNames: ["ptr"],
      );

  @override
  Future<FfiBolt12Payment> crateApiNodeFfiNodeBolt12Payment(
      {required FfiNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(ptr);
        return wire.wire__crate__api__node__ffi_node_bolt12_payment(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_bolt_12_payment,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeBolt12PaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeBolt12PaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_bolt12_payment",
        argNames: ["ptr"],
      );

  @override
  Future<void> crateApiNodeFfiNodeCloseChannel(
      {required FfiNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_box_autoadd_user_channel_id(userChannelId);
        var arg2 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        return wire.wire__crate__api__node__ffi_node_close_channel(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeCloseChannelConstMeta,
      argValues: [that, userChannelId, counterpartyNodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeCloseChannelConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_close_channel",
        argNames: ["that", "userChannelId", "counterpartyNodeId"],
      );

  @override
  Future<Config> crateApiNodeFfiNodeConfig({required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_config(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeConfigConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeConfigConstMeta => const TaskConstMeta(
        debugName: "ffi_node_config",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiNodeFfiNodeConnect(
      {required FfiNode that,
      required PublicKey nodeId,
      required SocketAddress address,
      required bool persist}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_box_autoadd_public_key(nodeId);
        var arg2 = cst_encode_box_autoadd_socket_address(address);
        var arg3 = cst_encode_bool(persist);
        return wire.wire__crate__api__node__ffi_node_connect(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeConnectConstMeta,
      argValues: [that, nodeId, address, persist],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeConnectConstMeta => const TaskConstMeta(
        debugName: "ffi_node_connect",
        argNames: ["that", "nodeId", "address", "persist"],
      );

  @override
  Future<void> crateApiNodeFfiNodeDisconnect(
      {required FfiNode that, required PublicKey counterpartyNodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        return wire.wire__crate__api__node__ffi_node_disconnect(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeDisconnectConstMeta,
      argValues: [that, counterpartyNodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeDisconnectConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_disconnect",
        argNames: ["that", "counterpartyNodeId"],
      );

  @override
  Future<void> crateApiNodeFfiNodeEventHandled({required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_event_handled(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeEventHandledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeEventHandledConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_event_handled",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiNodeFfiNodeForceCloseChannel(
      {required FfiNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_box_autoadd_user_channel_id(userChannelId);
        var arg2 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        return wire.wire__crate__api__node__ffi_node_force_close_channel(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeForceCloseChannelConstMeta,
      argValues: [that, userChannelId, counterpartyNodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeForceCloseChannelConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_force_close_channel",
        argNames: ["that", "userChannelId", "counterpartyNodeId"],
      );

  @override
  Future<BalanceDetails> crateApiNodeFfiNodeListBalances(
      {required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_list_balances(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_balance_details,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeListBalancesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeListBalancesConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_list_balances",
        argNames: ["that"],
      );

  @override
  Future<List<ChannelDetails>> crateApiNodeFfiNodeListChannels(
      {required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_list_channels(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_channel_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeListChannelsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeListChannelsConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_list_channels",
        argNames: ["that"],
      );

  @override
  Future<List<PaymentDetails>> crateApiNodeFfiNodeListPayments(
      {required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_list_payments(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeListPaymentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeListPaymentsConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_list_payments",
        argNames: ["that"],
      );

  @override
  Future<List<PaymentDetails>> crateApiNodeFfiNodeListPaymentsWithFilter(
      {required FfiNode that, required PaymentDirection paymentDirection}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_payment_direction(paymentDirection);
        return wire.wire__crate__api__node__ffi_node_list_payments_with_filter(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeListPaymentsWithFilterConstMeta,
      argValues: [that, paymentDirection],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeListPaymentsWithFilterConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_list_payments_with_filter",
        argNames: ["that", "paymentDirection"],
      );

  @override
  Future<List<PeerDetails>> crateApiNodeFfiNodeListPeers(
      {required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_list_peers(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_peer_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeListPeersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeListPeersConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_list_peers",
        argNames: ["that"],
      );

  @override
  Future<List<SocketAddress>?> crateApiNodeFfiNodeListeningAddresses(
      {required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_listening_addresses(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_list_socket_address,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeListeningAddressesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeListeningAddressesConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_listening_addresses",
        argNames: ["that"],
      );

  @override
  Future<FfiNetworkGraph> crateApiNodeFfiNodeNetworkGraph(
      {required FfiNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(ptr);
        return wire.wire__crate__api__node__ffi_node_network_graph(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_network_graph,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeNetworkGraphConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeNetworkGraphConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_network_graph",
        argNames: ["ptr"],
      );

  @override
  Future<Event?> crateApiNodeFfiNodeNextEvent({required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_next_event(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_event,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeNextEventConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeNextEventConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_next_event",
        argNames: ["that"],
      );

  @override
  Future<Event> crateApiNodeFfiNodeNextEventAsync({required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_next_event_async(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_event,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeNextEventAsyncConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeNextEventAsyncConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_next_event_async",
        argNames: ["that"],
      );

  @override
  Future<PublicKey> crateApiNodeFfiNodeNodeId({required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_node_id(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_public_key,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeNodeIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeNodeIdConstMeta => const TaskConstMeta(
        debugName: "ffi_node_node_id",
        argNames: ["that"],
      );

  @override
  Future<FfiOnChainPayment> crateApiNodeFfiNodeOnChainPayment(
      {required FfiNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(ptr);
        return wire.wire__crate__api__node__ffi_node_on_chain_payment(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_on_chain_payment,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeOnChainPaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeOnChainPaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_on_chain_payment",
        argNames: ["ptr"],
      );

  @override
  Future<UserChannelId> crateApiNodeFfiNodeOpenAnnouncedChannel(
      {required FfiNode that,
      required SocketAddress socketAddress,
      required PublicKey nodeId,
      required BigInt channelAmountSats,
      BigInt? pushToCounterpartyMsat,
      ChannelConfig? channelConfig}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_box_autoadd_socket_address(socketAddress);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        var arg3 = cst_encode_u_64(channelAmountSats);
        var arg4 = cst_encode_opt_box_autoadd_u_64(pushToCounterpartyMsat);
        var arg5 = cst_encode_opt_box_autoadd_channel_config(channelConfig);
        return wire.wire__crate__api__node__ffi_node_open_announced_channel(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_channel_id,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeOpenAnnouncedChannelConstMeta,
      argValues: [
        that,
        socketAddress,
        nodeId,
        channelAmountSats,
        pushToCounterpartyMsat,
        channelConfig
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeOpenAnnouncedChannelConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_open_announced_channel",
        argNames: [
          "that",
          "socketAddress",
          "nodeId",
          "channelAmountSats",
          "pushToCounterpartyMsat",
          "channelConfig"
        ],
      );

  @override
  Future<UserChannelId> crateApiNodeFfiNodeOpenChannel(
      {required FfiNode that,
      required SocketAddress socketAddress,
      required PublicKey nodeId,
      required BigInt channelAmountSats,
      BigInt? pushToCounterpartyMsat,
      ChannelConfig? channelConfig}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_box_autoadd_socket_address(socketAddress);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        var arg3 = cst_encode_u_64(channelAmountSats);
        var arg4 = cst_encode_opt_box_autoadd_u_64(pushToCounterpartyMsat);
        var arg5 = cst_encode_opt_box_autoadd_channel_config(channelConfig);
        return wire.wire__crate__api__node__ffi_node_open_channel(
            port_, arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_user_channel_id,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeOpenChannelConstMeta,
      argValues: [
        that,
        socketAddress,
        nodeId,
        channelAmountSats,
        pushToCounterpartyMsat,
        channelConfig
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeOpenChannelConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_open_channel",
        argNames: [
          "that",
          "socketAddress",
          "nodeId",
          "channelAmountSats",
          "pushToCounterpartyMsat",
          "channelConfig"
        ],
      );

  @override
  Future<PaymentDetails?> crateApiNodeFfiNodePayment(
      {required FfiNode that, required PaymentId paymentId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_box_autoadd_payment_id(paymentId);
        return wire.wire__crate__api__node__ffi_node_payment(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_payment_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodePaymentConstMeta,
      argValues: [that, paymentId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodePaymentConstMeta => const TaskConstMeta(
        debugName: "ffi_node_payment",
        argNames: ["that", "paymentId"],
      );

  @override
  Future<void> crateApiNodeFfiNodeRemovePayment(
      {required FfiNode that, required PaymentId paymentId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_box_autoadd_payment_id(paymentId);
        return wire.wire__crate__api__node__ffi_node_remove_payment(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeRemovePaymentConstMeta,
      argValues: [that, paymentId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeRemovePaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_remove_payment",
        argNames: ["that", "paymentId"],
      );

  @override
  Future<String> crateApiNodeFfiNodeSignMessage(
      {required FfiNode that, required List<int> msg}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_list_prim_u_8_loose(msg);
        return wire.wire__crate__api__node__ffi_node_sign_message(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeSignMessageConstMeta,
      argValues: [that, msg],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeSignMessageConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_sign_message",
        argNames: ["that", "msg"],
      );

  @override
  Future<FfiSpontaneousPayment> crateApiNodeFfiNodeSpontaneousPayment(
      {required FfiNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(ptr);
        return wire.wire__crate__api__node__ffi_node_spontaneous_payment(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_spontaneous_payment,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeSpontaneousPaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeSpontaneousPaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_spontaneous_payment",
        argNames: ["ptr"],
      );

  @override
  Future<void> crateApiNodeFfiNodeStart({required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_start(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeStartConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeStartConstMeta => const TaskConstMeta(
        debugName: "ffi_node_start",
        argNames: ["that"],
      );

  @override
  Future<NodeStatus> crateApiNodeFfiNodeStatus({required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_status(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_node_status,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeStatusConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeStatusConstMeta => const TaskConstMeta(
        debugName: "ffi_node_status",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiNodeFfiNodeStop({required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_stop(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeStopConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeStopConstMeta => const TaskConstMeta(
        debugName: "ffi_node_stop",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiNodeFfiNodeSyncWallets({required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_sync_wallets(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeSyncWalletsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeSyncWalletsConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_sync_wallets",
        argNames: ["that"],
      );

  @override
  Future<FfiUnifiedQrPayment> crateApiNodeFfiNodeUnifiedQrPayment(
      {required FfiNode ptr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(ptr);
        return wire.wire__crate__api__node__ffi_node_unified_qr_payment(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_ffi_unified_qr_payment,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeUnifiedQrPaymentConstMeta,
      argValues: [ptr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeUnifiedQrPaymentConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_unified_qr_payment",
        argNames: ["ptr"],
      );

  @override
  Future<void> crateApiNodeFfiNodeUpdateChannelConfig(
      {required FfiNode that,
      required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId,
      required ChannelConfig channelConfig}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_box_autoadd_user_channel_id(userChannelId);
        var arg2 = cst_encode_box_autoadd_public_key(counterpartyNodeId);
        var arg3 = cst_encode_box_autoadd_channel_config(channelConfig);
        return wire.wire__crate__api__node__ffi_node_update_channel_config(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeUpdateChannelConfigConstMeta,
      argValues: [that, userChannelId, counterpartyNodeId, channelConfig],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeUpdateChannelConfigConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_update_channel_config",
        argNames: [
          "that",
          "userChannelId",
          "counterpartyNodeId",
          "channelConfig"
        ],
      );

  @override
  Future<bool> crateApiNodeFfiNodeVerifySignature(
      {required FfiNode that,
      required List<int> msg,
      required String sig,
      required PublicKey publicKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        var arg1 = cst_encode_list_prim_u_8_loose(msg);
        var arg2 = cst_encode_String(sig);
        var arg3 = cst_encode_box_autoadd_public_key(publicKey);
        return wire.wire__crate__api__node__ffi_node_verify_signature(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiNodeFfiNodeVerifySignatureConstMeta,
      argValues: [that, msg, sig, publicKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeVerifySignatureConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_verify_signature",
        argNames: ["that", "msg", "sig", "publicKey"],
      );

  @override
  Future<Event> crateApiNodeFfiNodeWaitNextEvent({required FfiNode that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_node(that);
        return wire.wire__crate__api__node__ffi_node_wait_next_event(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_event,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiNodeFfiNodeWaitNextEventConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiNodeFfiNodeWaitNextEventConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_node_wait_next_event",
        argNames: ["that"],
      );

  @override
  Future<Address> crateApiOnChainFfiOnChainPaymentNewAddress(
      {required FfiOnChainPayment that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_on_chain_payment(that);
        return wire
            .wire__crate__api__on_chain__ffi_on_chain_payment_new_address(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_address,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiOnChainFfiOnChainPaymentNewAddressConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiOnChainFfiOnChainPaymentNewAddressConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_on_chain_payment_new_address",
        argNames: ["that"],
      );

  @override
  Future<Txid> crateApiOnChainFfiOnChainPaymentSendAllToAddress(
      {required FfiOnChainPayment that, required Address address}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_on_chain_payment(that);
        var arg1 = cst_encode_box_autoadd_address(address);
        return wire
            .wire__crate__api__on_chain__ffi_on_chain_payment_send_all_to_address(
                port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_txid,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiOnChainFfiOnChainPaymentSendAllToAddressConstMeta,
      argValues: [that, address],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiOnChainFfiOnChainPaymentSendAllToAddressConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_on_chain_payment_send_all_to_address",
            argNames: ["that", "address"],
          );

  @override
  Future<Txid> crateApiOnChainFfiOnChainPaymentSendToAddress(
      {required FfiOnChainPayment that,
      required Address address,
      required BigInt amountSats}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_on_chain_payment(that);
        var arg1 = cst_encode_box_autoadd_address(address);
        var arg2 = cst_encode_u_64(amountSats);
        return wire
            .wire__crate__api__on_chain__ffi_on_chain_payment_send_to_address(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_txid,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiOnChainFfiOnChainPaymentSendToAddressConstMeta,
      argValues: [that, address, amountSats],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiOnChainFfiOnChainPaymentSendToAddressConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_on_chain_payment_send_to_address",
        argNames: ["that", "address", "amountSats"],
      );

  @override
  Future<PaymentId> crateApiSpontaneousFfiSpontaneousPaymentSend(
      {required FfiSpontaneousPayment that,
      required BigInt amountMsat,
      required PublicKey nodeId,
      SendingParameters? sendingParameters}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_spontaneous_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        var arg3 =
            cst_encode_opt_box_autoadd_sending_parameters(sendingParameters);
        return wire.wire__crate__api__spontaneous__ffi_spontaneous_payment_send(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_payment_id,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiSpontaneousFfiSpontaneousPaymentSendConstMeta,
      argValues: [that, amountMsat, nodeId, sendingParameters],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSpontaneousFfiSpontaneousPaymentSendConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_spontaneous_payment_send",
        argNames: ["that", "amountMsat", "nodeId", "sendingParameters"],
      );

  @override
  Future<void> crateApiSpontaneousFfiSpontaneousPaymentSendProbes(
      {required FfiSpontaneousPayment that,
      required BigInt amountMsat,
      required PublicKey nodeId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_spontaneous_payment(that);
        var arg1 = cst_encode_u_64(amountMsat);
        var arg2 = cst_encode_box_autoadd_public_key(nodeId);
        return wire
            .wire__crate__api__spontaneous__ffi_spontaneous_payment_send_probes(
                port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiSpontaneousFfiSpontaneousPaymentSendProbesConstMeta,
      argValues: [that, amountMsat, nodeId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiSpontaneousFfiSpontaneousPaymentSendProbesConstMeta =>
          const TaskConstMeta(
            debugName: "ffi_spontaneous_payment_send_probes",
            argNames: ["that", "amountMsat", "nodeId"],
          );

  @override
  Future<AnchorChannelsConfig> crateApiTypesAnchorChannelsConfigDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__crate__api__types__anchor_channels_config_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_anchor_channels_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesAnchorChannelsConfigDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesAnchorChannelsConfigDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "anchor_channels_config_default",
        argNames: [],
      );

  @override
  Future<Config> crateApiTypesConfigDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__types__config_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesConfigDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesConfigDefaultConstMeta => const TaskConstMeta(
        debugName: "config_default",
        argNames: [],
      );

  @override
  Future<String> crateApiUnifiedQrFfiUnifiedQrPaymentReceive(
      {required FfiUnifiedQrPayment that,
      required BigInt amountSats,
      required String message,
      required int expirySec}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_unified_qr_payment(that);
        var arg1 = cst_encode_u_64(amountSats);
        var arg2 = cst_encode_String(message);
        var arg3 = cst_encode_u_32(expirySec);
        return wire
            .wire__crate__api__unified_qr__ffi_unified_qr_payment_receive(
                port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiUnifiedQrFfiUnifiedQrPaymentReceiveConstMeta,
      argValues: [that, amountSats, message, expirySec],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUnifiedQrFfiUnifiedQrPaymentReceiveConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_unified_qr_payment_receive",
        argNames: ["that", "amountSats", "message", "expirySec"],
      );

  @override
  Future<QrPaymentResult> crateApiUnifiedQrFfiUnifiedQrPaymentSend(
      {required FfiUnifiedQrPayment that, required String uriStr}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_ffi_unified_qr_payment(that);
        var arg1 = cst_encode_String(uriStr);
        return wire.wire__crate__api__unified_qr__ffi_unified_qr_payment_send(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_qr_payment_result,
        decodeErrorData: dco_decode_ffi_node_error,
      ),
      constMeta: kCrateApiUnifiedQrFfiUnifiedQrPaymentSendConstMeta,
      argValues: [that, uriStr],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiUnifiedQrFfiUnifiedQrPaymentSendConstMeta =>
      const TaskConstMeta(
        debugName: "ffi_unified_qr_payment_send",
        argNames: ["that", "uriStr"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_FfiBuilder => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_FfiBuilder => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Builder =>
          wire.rust_arc_increment_strong_count_RustOpaque_ldk_nodeBuilder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Builder =>
          wire.rust_arc_decrement_strong_count_RustOpaque_ldk_nodeBuilder;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Node =>
      wire.rust_arc_increment_strong_count_RustOpaque_ldk_nodeNode;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Node =>
      wire.rust_arc_decrement_strong_count_RustOpaque_ldk_nodeNode;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NetworkGraph => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodegraphNetworkGraph;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NetworkGraph => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodegraphNetworkGraph;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Bolt11Payment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentBolt11Payment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Bolt11Payment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentBolt11Payment;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Bolt12Payment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentBolt12Payment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Bolt12Payment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentBolt12Payment;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_OnchainPayment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentOnchainPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_OnchainPayment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentOnchainPayment;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SpontaneousPayment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentSpontaneousPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SpontaneousPayment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentSpontaneousPayment;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_UnifiedQrPayment => wire
          .rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentUnifiedQrPayment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_UnifiedQrPayment => wire
          .rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentUnifiedQrPayment;

  @protected
  FfiBuilder
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FfiBuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FfiBuilder
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FfiBuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FfiBuilder
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FfiBuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Map<String, String> dco_decode_Map_String_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_string(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  FfiBuilder
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FfiBuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Builder dco_decode_RustOpaque_ldk_nodeBuilder(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Node dco_decode_RustOpaque_ldk_nodeNode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NodeImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NetworkGraph dco_decode_RustOpaque_ldk_nodegraphNetworkGraph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NetworkGraphImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Bolt11Payment dco_decode_RustOpaque_ldk_nodepaymentBolt11Payment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Bolt11PaymentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Bolt12Payment dco_decode_RustOpaque_ldk_nodepaymentBolt12Payment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Bolt12PaymentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  OnchainPayment dco_decode_RustOpaque_ldk_nodepaymentOnchainPayment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OnchainPaymentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SpontaneousPayment dco_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SpontaneousPaymentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  UnifiedQrPayment dco_decode_RustOpaque_ldk_nodepaymentUnifiedQrPayment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UnifiedQrPaymentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Address dco_decode_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Address(
      s: dco_decode_String(arr[0]),
    );
  }

  @protected
  AnchorChannelsConfig dco_decode_anchor_channels_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return AnchorChannelsConfig(
      trustedPeersNoReserve: dco_decode_list_public_key(arr[0]),
      perChannelReserveSats: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  BalanceDetails dco_decode_balance_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return BalanceDetails(
      totalOnchainBalanceSats: dco_decode_u_64(arr[0]),
      spendableOnchainBalanceSats: dco_decode_u_64(arr[1]),
      totalLightningBalanceSats: dco_decode_u_64(arr[2]),
      lightningBalances: dco_decode_list_lightning_balance(arr[3]),
      pendingBalancesFromChannelClosures:
          dco_decode_list_pending_sweep_balance(arr[4]),
    );
  }

  @protected
  BalanceSource dco_decode_balance_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BalanceSource.values[raw as int];
  }

  @protected
  BestBlock dco_decode_best_block(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BestBlock(
      blockHash: dco_decode_String(arr[0]),
      height: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  Bolt11Invoice dco_decode_bolt_11_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Bolt11Invoice(
      signedRawInvoice: dco_decode_String(arr[0]),
    );
  }

  @protected
  Bolt12Invoice dco_decode_bolt_12_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Bolt12Invoice(
      data: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  Bolt12ParseError dco_decode_bolt_12_parse_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Bolt12ParseError_InvalidContinuation();
      case 1:
        return Bolt12ParseError_InvalidBech32Hrp();
      case 2:
        return Bolt12ParseError_Bech32(
          dco_decode_String(raw[1]),
        );
      case 3:
        return Bolt12ParseError_Decode(
          dco_decode_box_autoadd_decode_error(raw[1]),
        );
      case 4:
        return Bolt12ParseError_InvalidSemantics(
          dco_decode_String(raw[1]),
        );
      case 5:
        return Bolt12ParseError_InvalidSignature(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Address dco_decode_box_autoadd_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_address(raw);
  }

  @protected
  AnchorChannelsConfig dco_decode_box_autoadd_anchor_channels_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_anchor_channels_config(raw);
  }

  @protected
  Bolt11Invoice dco_decode_box_autoadd_bolt_11_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bolt_11_invoice(raw);
  }

  @protected
  Bolt12ParseError dco_decode_box_autoadd_bolt_12_parse_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_bolt_12_parse_error(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  ChainDataSourceConfig dco_decode_box_autoadd_chain_data_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_chain_data_source_config(raw);
  }

  @protected
  ChannelConfig dco_decode_box_autoadd_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_config(raw);
  }

  @protected
  ChannelId dco_decode_box_autoadd_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_id(raw);
  }

  @protected
  ChannelInfo dco_decode_box_autoadd_channel_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_info(raw);
  }

  @protected
  ChannelUpdateInfo dco_decode_box_autoadd_channel_update_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_channel_update_info(raw);
  }

  @protected
  ClosureReason dco_decode_box_autoadd_closure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_closure_reason(raw);
  }

  @protected
  Config dco_decode_box_autoadd_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_config(raw);
  }

  @protected
  DecodeError dco_decode_box_autoadd_decode_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_decode_error(raw);
  }

  @protected
  EntropySourceConfig dco_decode_box_autoadd_entropy_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entropy_source_config(raw);
  }

  @protected
  EsploraSyncConfig dco_decode_box_autoadd_esplora_sync_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_esplora_sync_config(raw);
  }

  @protected
  Event dco_decode_box_autoadd_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_event(raw);
  }

  @protected
  FfiBolt11Payment dco_decode_box_autoadd_ffi_bolt_11_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_bolt_11_payment(raw);
  }

  @protected
  FfiBolt12Payment dco_decode_box_autoadd_ffi_bolt_12_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_bolt_12_payment(raw);
  }

  @protected
  FfiMnemonic dco_decode_box_autoadd_ffi_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_mnemonic(raw);
  }

  @protected
  FfiNetworkGraph dco_decode_box_autoadd_ffi_network_graph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_network_graph(raw);
  }

  @protected
  FfiNode dco_decode_box_autoadd_ffi_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_node(raw);
  }

  @protected
  FfiOnChainPayment dco_decode_box_autoadd_ffi_on_chain_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_on_chain_payment(raw);
  }

  @protected
  FfiSpontaneousPayment dco_decode_box_autoadd_ffi_spontaneous_payment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_spontaneous_payment(raw);
  }

  @protected
  FfiUnifiedQrPayment dco_decode_box_autoadd_ffi_unified_qr_payment(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ffi_unified_qr_payment(raw);
  }

  @protected
  GossipSourceConfig dco_decode_box_autoadd_gossip_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_gossip_source_config(raw);
  }

  @protected
  LiquiditySourceConfig dco_decode_box_autoadd_liquidity_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_liquidity_source_config(raw);
  }

  @protected
  LSPFeeLimits dco_decode_box_autoadd_lsp_fee_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lsp_fee_limits(raw);
  }

  @protected
  MaxTotalRoutingFeeLimit dco_decode_box_autoadd_max_total_routing_fee_limit(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_max_total_routing_fee_limit(raw);
  }

  @protected
  NodeAlias dco_decode_box_autoadd_node_alias(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_alias(raw);
  }

  @protected
  NodeAnnouncementInfo dco_decode_box_autoadd_node_announcement_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_announcement_info(raw);
  }

  @protected
  NodeId dco_decode_box_autoadd_node_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_id(raw);
  }

  @protected
  NodeInfo dco_decode_box_autoadd_node_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_node_info(raw);
  }

  @protected
  Offer dco_decode_box_autoadd_offer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_offer(raw);
  }

  @protected
  OfferId dco_decode_box_autoadd_offer_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_offer_id(raw);
  }

  @protected
  OutPoint dco_decode_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_out_point(raw);
  }

  @protected
  PaymentDetails dco_decode_box_autoadd_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_details(raw);
  }

  @protected
  PaymentFailureReason dco_decode_box_autoadd_payment_failure_reason(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_failure_reason(raw);
  }

  @protected
  PaymentHash dco_decode_box_autoadd_payment_hash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_hash(raw);
  }

  @protected
  PaymentId dco_decode_box_autoadd_payment_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_id(raw);
  }

  @protected
  PaymentPreimage dco_decode_box_autoadd_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_preimage(raw);
  }

  @protected
  PaymentSecret dco_decode_box_autoadd_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_payment_secret(raw);
  }

  @protected
  PublicKey dco_decode_box_autoadd_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_public_key(raw);
  }

  @protected
  Refund dco_decode_box_autoadd_refund(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_refund(raw);
  }

  @protected
  SendingParameters dco_decode_box_autoadd_sending_parameters(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sending_parameters(raw);
  }

  @protected
  SocketAddress dco_decode_box_autoadd_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_socket_address(raw);
  }

  @protected
  Txid dco_decode_box_autoadd_txid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_txid(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  UserChannelId dco_decode_box_autoadd_user_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user_channel_id(raw);
  }

  @protected
  ChainDataSourceConfig dco_decode_chain_data_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ChainDataSourceConfig_Esplora(
          serverUrl: dco_decode_String(raw[1]),
          syncConfig: dco_decode_opt_box_autoadd_esplora_sync_config(raw[2]),
        );
      case 1:
        return ChainDataSourceConfig_BitcoindRpc(
          rpcHost: dco_decode_String(raw[1]),
          rpcPort: dco_decode_u_16(raw[2]),
          rpcUser: dco_decode_String(raw[3]),
          rpcPassword: dco_decode_String(raw[4]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ChannelConfig dco_decode_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ChannelConfig(
      forwardingFeeProportionalMillionths: dco_decode_u_32(arr[0]),
      forwardingFeeBaseMsat: dco_decode_u_32(arr[1]),
      cltvExpiryDelta: dco_decode_u_16(arr[2]),
      maxDustHtlcExposure: dco_decode_max_dust_htlc_exposure(arr[3]),
      forceCloseAvoidanceMaxFeeSatoshis: dco_decode_u_64(arr[4]),
      acceptUnderpayingHtlcs: dco_decode_bool(arr[5]),
    );
  }

  @protected
  ChannelDetails dco_decode_channel_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 27)
      throw Exception('unexpected arr length: expect 27 but see ${arr.length}');
    return ChannelDetails(
      channelId: dco_decode_channel_id(arr[0]),
      counterpartyNodeId: dco_decode_public_key(arr[1]),
      fundingTxo: dco_decode_opt_box_autoadd_out_point(arr[2]),
      channelValueSats: dco_decode_u_64(arr[3]),
      unspendablePunishmentReserve: dco_decode_opt_box_autoadd_u_64(arr[4]),
      userChannelId: dco_decode_user_channel_id(arr[5]),
      feerateSatPer1000Weight: dco_decode_u_32(arr[6]),
      outboundCapacityMsat: dco_decode_u_64(arr[7]),
      inboundCapacityMsat: dco_decode_u_64(arr[8]),
      confirmationsRequired: dco_decode_opt_box_autoadd_u_32(arr[9]),
      confirmations: dco_decode_opt_box_autoadd_u_32(arr[10]),
      isOutbound: dco_decode_bool(arr[11]),
      isChannelReady: dco_decode_bool(arr[12]),
      isUsable: dco_decode_bool(arr[13]),
      cltvExpiryDelta: dco_decode_opt_box_autoadd_u_16(arr[14]),
      counterpartyUnspendablePunishmentReserve: dco_decode_u_64(arr[15]),
      counterpartyOutboundHtlcMinimumMsat:
          dco_decode_opt_box_autoadd_u_64(arr[16]),
      counterpartyOutboundHtlcMaximumMsat:
          dco_decode_opt_box_autoadd_u_64(arr[17]),
      counterpartyForwardingInfoFeeBaseMsat:
          dco_decode_opt_box_autoadd_u_32(arr[18]),
      counterpartyForwardingInfoFeeProportionalMillionths:
          dco_decode_opt_box_autoadd_u_32(arr[19]),
      counterpartyForwardingInfoCltvExpiryDelta:
          dco_decode_opt_box_autoadd_u_16(arr[20]),
      nextOutboundHtlcLimitMsat: dco_decode_u_64(arr[21]),
      nextOutboundHtlcMinimumMsat: dco_decode_u_64(arr[22]),
      forceCloseSpendDelay: dco_decode_opt_box_autoadd_u_16(arr[23]),
      inboundHtlcMinimumMsat: dco_decode_u_64(arr[24]),
      inboundHtlcMaximumMsat: dco_decode_opt_box_autoadd_u_64(arr[25]),
      config: dco_decode_channel_config(arr[26]),
    );
  }

  @protected
  ChannelId dco_decode_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return ChannelId(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  ChannelInfo dco_decode_channel_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return ChannelInfo(
      nodeOne: dco_decode_node_id(arr[0]),
      oneToTwo: dco_decode_opt_box_autoadd_channel_update_info(arr[1]),
      nodeTwo: dco_decode_node_id(arr[2]),
      twoToOne: dco_decode_opt_box_autoadd_channel_update_info(arr[3]),
      capacitySats: dco_decode_opt_box_autoadd_u_64(arr[4]),
    );
  }

  @protected
  ChannelUpdateInfo dco_decode_channel_update_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return ChannelUpdateInfo(
      lastUpdate: dco_decode_u_32(arr[0]),
      enabled: dco_decode_bool(arr[1]),
      cltvExpiryDelta: dco_decode_u_16(arr[2]),
      htlcMinimumMsat: dco_decode_u_64(arr[3]),
      htlcMaximumMsat: dco_decode_u_64(arr[4]),
      fees: dco_decode_routing_fees(arr[5]),
    );
  }

  @protected
  ClosureReason dco_decode_closure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ClosureReason_PeerFeerateTooLow(
          peerFeerateSatPerKw: dco_decode_u_32(raw[1]),
          requiredFeerateSatPerKw: dco_decode_u_32(raw[2]),
        );
      case 1:
        return ClosureReason_CounterpartyForceClosed(
          peerMsg: dco_decode_String(raw[1]),
        );
      case 2:
        return ClosureReason_HolderForceClosed(
          broadcastedLatestTxn: dco_decode_opt_box_autoadd_bool(raw[1]),
        );
      case 3:
        return ClosureReason_LegacyCooperativeClosure();
      case 4:
        return ClosureReason_CounterpartyInitiatedCooperativeClosure();
      case 5:
        return ClosureReason_LocallyInitiatedCooperativeClosure();
      case 6:
        return ClosureReason_CommitmentTxConfirmed();
      case 7:
        return ClosureReason_FundingTimedOut();
      case 8:
        return ClosureReason_ProcessingError(
          err: dco_decode_String(raw[1]),
        );
      case 9:
        return ClosureReason_DisconnectedPeer();
      case 10:
        return ClosureReason_OutdatedChannelManager();
      case 11:
        return ClosureReason_CounterpartyCoopClosedUnfundedChannel();
      case 12:
        return ClosureReason_FundingBatchClosure();
      case 13:
        return ClosureReason_HTLCsTimedOut();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Config dco_decode_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return Config(
      storageDirPath: dco_decode_String(arr[0]),
      logDirPath: dco_decode_opt_String(arr[1]),
      network: dco_decode_network(arr[2]),
      listeningAddresses: dco_decode_opt_list_socket_address(arr[3]),
      nodeAlias: dco_decode_opt_box_autoadd_node_alias(arr[4]),
      trustedPeers0Conf: dco_decode_list_public_key(arr[5]),
      probingLiquidityLimitMultiplier: dco_decode_u_64(arr[6]),
      logLevel: dco_decode_log_level(arr[7]),
      anchorChannelsConfig:
          dco_decode_opt_box_autoadd_anchor_channels_config(arr[8]),
      sendingParameters: dco_decode_opt_box_autoadd_sending_parameters(arr[9]),
    );
  }

  @protected
  DecodeError dco_decode_decode_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return DecodeError_UnknownVersion();
      case 1:
        return DecodeError_UnknownRequiredFeature();
      case 2:
        return DecodeError_InvalidValue();
      case 3:
        return DecodeError_ShortRead();
      case 4:
        return DecodeError_BadLengthDescriptor();
      case 5:
        return DecodeError_Io(
          dco_decode_String(raw[1]),
        );
      case 6:
        return DecodeError_UnsupportedCompression();
      case 7:
        return DecodeError_DangerousValue();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  EntropySourceConfig dco_decode_entropy_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return EntropySourceConfig_SeedFile(
          dco_decode_String(raw[1]),
        );
      case 1:
        return EntropySourceConfig_SeedBytes(
          dco_decode_u_8_array_64(raw[1]),
        );
      case 2:
        return EntropySourceConfig_Bip39Mnemonic(
          mnemonic: dco_decode_box_autoadd_ffi_mnemonic(raw[1]),
          passphrase: dco_decode_opt_String(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  EsploraSyncConfig dco_decode_esplora_sync_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return EsploraSyncConfig(
      onchainWalletSyncIntervalSecs: dco_decode_u_64(arr[0]),
      lightningWalletSyncIntervalSecs: dco_decode_u_64(arr[1]),
      feeRateCacheUpdateIntervalSecs: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  Event dco_decode_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Event_PaymentClaimable(
          paymentId: dco_decode_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[2]),
          claimableAmountMsat: dco_decode_u_64(raw[3]),
          claimDeadline: dco_decode_opt_box_autoadd_u_32(raw[4]),
        );
      case 1:
        return Event_PaymentSuccessful(
          paymentId: dco_decode_opt_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[2]),
          feePaidMsat: dco_decode_opt_box_autoadd_u_64(raw[3]),
        );
      case 2:
        return Event_PaymentFailed(
          paymentId: dco_decode_opt_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_opt_box_autoadd_payment_hash(raw[2]),
          reason: dco_decode_opt_box_autoadd_payment_failure_reason(raw[3]),
        );
      case 3:
        return Event_PaymentReceived(
          paymentId: dco_decode_opt_box_autoadd_payment_id(raw[1]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[2]),
          amountMsat: dco_decode_u_64(raw[3]),
        );
      case 4:
        return Event_ChannelPending(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          formerTemporaryChannelId: dco_decode_box_autoadd_channel_id(raw[3]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[4]),
          fundingTxo: dco_decode_box_autoadd_out_point(raw[5]),
        );
      case 5:
        return Event_ChannelReady(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          counterpartyNodeId: dco_decode_opt_box_autoadd_public_key(raw[3]),
        );
      case 6:
        return Event_ChannelClosed(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          userChannelId: dco_decode_box_autoadd_user_channel_id(raw[2]),
          counterpartyNodeId: dco_decode_opt_box_autoadd_public_key(raw[3]),
          reason: dco_decode_opt_box_autoadd_closure_reason(raw[4]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  FfiBolt11Payment dco_decode_ffi_bolt_11_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiBolt11Payment(
      opaque: dco_decode_RustOpaque_ldk_nodepaymentBolt11Payment(arr[0]),
    );
  }

  @protected
  FfiBolt12Payment dco_decode_ffi_bolt_12_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiBolt12Payment(
      opaque: dco_decode_RustOpaque_ldk_nodepaymentBolt12Payment(arr[0]),
    );
  }

  @protected
  FfiBuilderError dco_decode_ffi_builder_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FfiBuilderError.values[raw as int];
  }

  @protected
  FfiMnemonic dco_decode_ffi_mnemonic(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiMnemonic(
      seedPhrase: dco_decode_String(arr[0]),
    );
  }

  @protected
  FfiNetworkGraph dco_decode_ffi_network_graph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiNetworkGraph(
      opaque: dco_decode_RustOpaque_ldk_nodegraphNetworkGraph(arr[0]),
    );
  }

  @protected
  FfiNode dco_decode_ffi_node(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiNode(
      opaque: dco_decode_RustOpaque_ldk_nodeNode(arr[0]),
    );
  }

  @protected
  FfiNodeError dco_decode_ffi_node_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return FfiNodeError_InvalidTxid();
      case 1:
        return FfiNodeError_AlreadyRunning();
      case 2:
        return FfiNodeError_NotRunning();
      case 3:
        return FfiNodeError_OnchainTxCreationFailed();
      case 4:
        return FfiNodeError_ConnectionFailed();
      case 5:
        return FfiNodeError_InvoiceCreationFailed();
      case 6:
        return FfiNodeError_PaymentSendingFailed();
      case 7:
        return FfiNodeError_ProbeSendingFailed();
      case 8:
        return FfiNodeError_ChannelCreationFailed();
      case 9:
        return FfiNodeError_ChannelClosingFailed();
      case 10:
        return FfiNodeError_ChannelConfigUpdateFailed();
      case 11:
        return FfiNodeError_PersistenceFailed();
      case 12:
        return FfiNodeError_WalletOperationFailed();
      case 13:
        return FfiNodeError_OnchainTxSigningFailed();
      case 14:
        return FfiNodeError_MessageSigningFailed();
      case 15:
        return FfiNodeError_TxSyncFailed();
      case 16:
        return FfiNodeError_GossipUpdateFailed();
      case 17:
        return FfiNodeError_InvalidAddress();
      case 18:
        return FfiNodeError_InvalidSocketAddress();
      case 19:
        return FfiNodeError_InvalidPublicKey();
      case 20:
        return FfiNodeError_InvalidSecretKey();
      case 21:
        return FfiNodeError_InvalidPaymentHash();
      case 22:
        return FfiNodeError_InvalidPaymentPreimage();
      case 23:
        return FfiNodeError_InvalidPaymentSecret();
      case 24:
        return FfiNodeError_InvalidAmount();
      case 25:
        return FfiNodeError_InvalidInvoice();
      case 26:
        return FfiNodeError_InvalidChannelId();
      case 27:
        return FfiNodeError_InvalidNetwork();
      case 28:
        return FfiNodeError_DuplicatePayment();
      case 29:
        return FfiNodeError_InsufficientFunds();
      case 30:
        return FfiNodeError_FeerateEstimationUpdateFailed();
      case 31:
        return FfiNodeError_LiquidityRequestFailed();
      case 32:
        return FfiNodeError_LiquiditySourceUnavailable();
      case 33:
        return FfiNodeError_LiquidityFeeTooHigh();
      case 34:
        return FfiNodeError_InvalidPaymentId();
      case 35:
        return FfiNodeError_Decode(
          dco_decode_box_autoadd_decode_error(raw[1]),
        );
      case 36:
        return FfiNodeError_Bolt12Parse(
          dco_decode_box_autoadd_bolt_12_parse_error(raw[1]),
        );
      case 37:
        return FfiNodeError_InvoiceRequestCreationFailed();
      case 38:
        return FfiNodeError_OfferCreationFailed();
      case 39:
        return FfiNodeError_RefundCreationFailed();
      case 40:
        return FfiNodeError_FeerateEstimationUpdateTimeout();
      case 41:
        return FfiNodeError_WalletOperationTimeout();
      case 42:
        return FfiNodeError_TxSyncTimeout();
      case 43:
        return FfiNodeError_GossipUpdateTimeout();
      case 44:
        return FfiNodeError_InvalidOfferId();
      case 45:
        return FfiNodeError_InvalidNodeId();
      case 46:
        return FfiNodeError_InvalidOffer();
      case 47:
        return FfiNodeError_InvalidRefund();
      case 48:
        return FfiNodeError_UnsupportedCurrency();
      case 49:
        return FfiNodeError_UriParameterParsingFailed();
      case 50:
        return FfiNodeError_InvalidUri();
      case 51:
        return FfiNodeError_InvalidQuantity();
      case 52:
        return FfiNodeError_InvalidNodeAlias();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  FfiOnChainPayment dco_decode_ffi_on_chain_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiOnChainPayment(
      opaque: dco_decode_RustOpaque_ldk_nodepaymentOnchainPayment(arr[0]),
    );
  }

  @protected
  FfiSpontaneousPayment dco_decode_ffi_spontaneous_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiSpontaneousPayment(
      opaque: dco_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(arr[0]),
    );
  }

  @protected
  FfiUnifiedQrPayment dco_decode_ffi_unified_qr_payment(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return FfiUnifiedQrPayment(
      opaque: dco_decode_RustOpaque_ldk_nodepaymentUnifiedQrPayment(arr[0]),
    );
  }

  @protected
  GossipSourceConfig dco_decode_gossip_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return GossipSourceConfig_P2PNetwork();
      case 1:
        return GossipSourceConfig_RapidGossipSync(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  LightningBalance dco_decode_lightning_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return LightningBalance_ClaimableOnChannelClose(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          transactionFeeSatoshis: dco_decode_u_64(raw[4]),
          outboundPaymentHtlcRoundedMsat: dco_decode_u_64(raw[5]),
          outboundForwardedHtlcRoundedMsat: dco_decode_u_64(raw[6]),
          inboundClaimingHtlcRoundedMsat: dco_decode_u_64(raw[7]),
          inboundHtlcRoundedMsat: dco_decode_u_64(raw[8]),
        );
      case 1:
        return LightningBalance_ClaimableAwaitingConfirmations(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          confirmationHeight: dco_decode_u_32(raw[4]),
          source: dco_decode_balance_source(raw[5]),
        );
      case 2:
        return LightningBalance_ContentiousClaimable(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          timeoutHeight: dco_decode_u_32(raw[4]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[5]),
          paymentPreimage: dco_decode_box_autoadd_payment_preimage(raw[6]),
        );
      case 3:
        return LightningBalance_MaybeTimeoutClaimableHTLC(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          claimableHeight: dco_decode_u_32(raw[4]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[5]),
          outboundPayment: dco_decode_bool(raw[6]),
        );
      case 4:
        return LightningBalance_MaybePreimageClaimableHTLC(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
          expiryHeight: dco_decode_u_32(raw[4]),
          paymentHash: dco_decode_box_autoadd_payment_hash(raw[5]),
        );
      case 5:
        return LightningBalance_CounterpartyRevokedOutputClaimable(
          channelId: dco_decode_box_autoadd_channel_id(raw[1]),
          counterpartyNodeId: dco_decode_box_autoadd_public_key(raw[2]),
          amountSatoshis: dco_decode_u_64(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  LiquiditySourceConfig dco_decode_liquidity_source_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LiquiditySourceConfig(
      lsps2Service:
          dco_decode_record_socket_address_public_key_opt_string(arr[0]),
    );
  }

  @protected
  List<ChannelDetails> dco_decode_list_channel_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_channel_details).toList();
  }

  @protected
  List<LightningBalance> dco_decode_list_lightning_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_lightning_balance).toList();
  }

  @protected
  List<NodeId> dco_decode_list_node_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_node_id).toList();
  }

  @protected
  List<PaymentDetails> dco_decode_list_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_payment_details).toList();
  }

  @protected
  List<PeerDetails> dco_decode_list_peer_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_peer_details).toList();
  }

  @protected
  List<PendingSweepBalance> dco_decode_list_pending_sweep_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_pending_sweep_balance)
        .toList();
  }

  @protected
  Uint64List dco_decode_list_prim_u_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeUint64List(raw);
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<PublicKey> dco_decode_list_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_public_key).toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<SocketAddress> dco_decode_list_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_socket_address).toList();
  }

  @protected
  LogLevel dco_decode_log_level(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return LogLevel.values[raw as int];
  }

  @protected
  LSPFeeLimits dco_decode_lsp_fee_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return LSPFeeLimits(
      maxTotalOpeningFeeMsat: dco_decode_opt_box_autoadd_u_64(arr[0]),
      maxProportionalOpeningFeePpmMsat: dco_decode_opt_box_autoadd_u_64(arr[1]),
    );
  }

  @protected
  MaxDustHTLCExposure dco_decode_max_dust_htlc_exposure(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return MaxDustHTLCExposure_FixedLimitMsat(
          dco_decode_u_64(raw[1]),
        );
      case 1:
        return MaxDustHTLCExposure_FeeRateMultiplier(
          dco_decode_u_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  MaxTotalRoutingFeeLimit dco_decode_max_total_routing_fee_limit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return MaxTotalRoutingFeeLimit_NoFeeCap();
      case 1:
        return MaxTotalRoutingFeeLimit_FeeCap(
          amountMsat: dco_decode_u_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Network dco_decode_network(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Network.values[raw as int];
  }

  @protected
  NodeAlias dco_decode_node_alias(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return NodeAlias(
      field0: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  NodeAnnouncementInfo dco_decode_node_announcement_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return NodeAnnouncementInfo(
      lastUpdate: dco_decode_u_32(arr[0]),
      alias: dco_decode_String(arr[1]),
      addresses: dco_decode_list_socket_address(arr[2]),
    );
  }

  @protected
  NodeId dco_decode_node_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return NodeId(
      compressed: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  NodeInfo dco_decode_node_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return NodeInfo(
      channels: dco_decode_list_prim_u_64_strict(arr[0]),
      announcementInfo:
          dco_decode_opt_box_autoadd_node_announcement_info(arr[1]),
    );
  }

  @protected
  NodeStatus dco_decode_node_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return NodeStatus(
      isRunning: dco_decode_bool(arr[0]),
      isListening: dco_decode_bool(arr[1]),
      currentBestBlock: dco_decode_best_block(arr[2]),
      latestLightningWalletSyncTimestamp:
          dco_decode_opt_box_autoadd_u_64(arr[3]),
      latestOnchainWalletSyncTimestamp: dco_decode_opt_box_autoadd_u_64(arr[4]),
      latestFeeRateCacheUpdateTimestamp:
          dco_decode_opt_box_autoadd_u_64(arr[5]),
      latestRgsSnapshotTimestamp: dco_decode_opt_box_autoadd_u_64(arr[6]),
      latestNodeAnnouncementBroadcastTimestamp:
          dco_decode_opt_box_autoadd_u_64(arr[7]),
      latestChannelMonitorArchivalHeight:
          dco_decode_opt_box_autoadd_u_32(arr[8]),
    );
  }

  @protected
  Offer dco_decode_offer(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Offer(
      s: dco_decode_String(arr[0]),
    );
  }

  @protected
  OfferId dco_decode_offer_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return OfferId(
      field0: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  AnchorChannelsConfig? dco_decode_opt_box_autoadd_anchor_channels_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_anchor_channels_config(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  ChainDataSourceConfig? dco_decode_opt_box_autoadd_chain_data_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_chain_data_source_config(raw);
  }

  @protected
  ChannelConfig? dco_decode_opt_box_autoadd_channel_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_config(raw);
  }

  @protected
  ChannelId? dco_decode_opt_box_autoadd_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_id(raw);
  }

  @protected
  ChannelInfo? dco_decode_opt_box_autoadd_channel_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_info(raw);
  }

  @protected
  ChannelUpdateInfo? dco_decode_opt_box_autoadd_channel_update_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_channel_update_info(raw);
  }

  @protected
  ClosureReason? dco_decode_opt_box_autoadd_closure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_closure_reason(raw);
  }

  @protected
  EntropySourceConfig? dco_decode_opt_box_autoadd_entropy_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_entropy_source_config(raw);
  }

  @protected
  EsploraSyncConfig? dco_decode_opt_box_autoadd_esplora_sync_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_esplora_sync_config(raw);
  }

  @protected
  Event? dco_decode_opt_box_autoadd_event(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_event(raw);
  }

  @protected
  GossipSourceConfig? dco_decode_opt_box_autoadd_gossip_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_gossip_source_config(raw);
  }

  @protected
  LiquiditySourceConfig? dco_decode_opt_box_autoadd_liquidity_source_config(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_liquidity_source_config(raw);
  }

  @protected
  MaxTotalRoutingFeeLimit?
      dco_decode_opt_box_autoadd_max_total_routing_fee_limit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_max_total_routing_fee_limit(raw);
  }

  @protected
  NodeAlias? dco_decode_opt_box_autoadd_node_alias(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_node_alias(raw);
  }

  @protected
  NodeAnnouncementInfo? dco_decode_opt_box_autoadd_node_announcement_info(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_node_announcement_info(raw);
  }

  @protected
  NodeInfo? dco_decode_opt_box_autoadd_node_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_node_info(raw);
  }

  @protected
  OutPoint? dco_decode_opt_box_autoadd_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_out_point(raw);
  }

  @protected
  PaymentDetails? dco_decode_opt_box_autoadd_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_details(raw);
  }

  @protected
  PaymentFailureReason? dco_decode_opt_box_autoadd_payment_failure_reason(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_payment_failure_reason(raw);
  }

  @protected
  PaymentHash? dco_decode_opt_box_autoadd_payment_hash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_hash(raw);
  }

  @protected
  PaymentId? dco_decode_opt_box_autoadd_payment_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_id(raw);
  }

  @protected
  PaymentPreimage? dco_decode_opt_box_autoadd_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_preimage(raw);
  }

  @protected
  PaymentSecret? dco_decode_opt_box_autoadd_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_payment_secret(raw);
  }

  @protected
  PublicKey? dco_decode_opt_box_autoadd_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_public_key(raw);
  }

  @protected
  SendingParameters? dco_decode_opt_box_autoadd_sending_parameters(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_sending_parameters(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_16(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_8(raw);
  }

  @protected
  List<SocketAddress>? dco_decode_opt_list_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_socket_address(raw);
  }

  @protected
  OutPoint dco_decode_out_point(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OutPoint(
      txid: dco_decode_txid(arr[0]),
      vout: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  PaymentDetails dco_decode_payment_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return PaymentDetails(
      id: dco_decode_payment_id(arr[0]),
      kind: dco_decode_payment_kind(arr[1]),
      amountMsat: dco_decode_opt_box_autoadd_u_64(arr[2]),
      direction: dco_decode_payment_direction(arr[3]),
      status: dco_decode_payment_status(arr[4]),
      latestUpdateTimestamp: dco_decode_u_64(arr[5]),
    );
  }

  @protected
  PaymentDirection dco_decode_payment_direction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentDirection.values[raw as int];
  }

  @protected
  PaymentFailureReason dco_decode_payment_failure_reason(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentFailureReason.values[raw as int];
  }

  @protected
  PaymentHash dco_decode_payment_hash(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentHash(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentId dco_decode_payment_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentId(
      field0: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentKind dco_decode_payment_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PaymentKind_Onchain();
      case 1:
        return PaymentKind_Bolt11(
          hash: dco_decode_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
          secret: dco_decode_opt_box_autoadd_payment_secret(raw[3]),
        );
      case 2:
        return PaymentKind_Bolt11Jit(
          hash: dco_decode_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
          secret: dco_decode_opt_box_autoadd_payment_secret(raw[3]),
          lspFeeLimits: dco_decode_box_autoadd_lsp_fee_limits(raw[4]),
        );
      case 3:
        return PaymentKind_Spontaneous(
          hash: dco_decode_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
        );
      case 4:
        return PaymentKind_Bolt12Offer(
          hash: dco_decode_opt_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
          secret: dco_decode_opt_box_autoadd_payment_secret(raw[3]),
          offerId: dco_decode_box_autoadd_offer_id(raw[4]),
          payerNote: dco_decode_opt_String(raw[5]),
          quantity: dco_decode_opt_box_autoadd_u_64(raw[6]),
        );
      case 5:
        return PaymentKind_Bolt12Refund(
          hash: dco_decode_opt_box_autoadd_payment_hash(raw[1]),
          preimage: dco_decode_opt_box_autoadd_payment_preimage(raw[2]),
          secret: dco_decode_opt_box_autoadd_payment_secret(raw[3]),
          payerNote: dco_decode_opt_String(raw[4]),
          quantity: dco_decode_opt_box_autoadd_u_64(raw[5]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PaymentPreimage dco_decode_payment_preimage(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentPreimage(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentSecret dco_decode_payment_secret(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PaymentSecret(
      data: dco_decode_u_8_array_32(arr[0]),
    );
  }

  @protected
  PaymentStatus dco_decode_payment_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PaymentStatus.values[raw as int];
  }

  @protected
  PeerDetails dco_decode_peer_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PeerDetails(
      nodeId: dco_decode_public_key(arr[0]),
      address: dco_decode_socket_address(arr[1]),
      isConnected: dco_decode_bool(arr[2]),
    );
  }

  @protected
  PendingSweepBalance dco_decode_pending_sweep_balance(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PendingSweepBalance_PendingBroadcast(
          channelId: dco_decode_opt_box_autoadd_channel_id(raw[1]),
          amountSatoshis: dco_decode_u_64(raw[2]),
        );
      case 1:
        return PendingSweepBalance_BroadcastAwaitingConfirmation(
          channelId: dco_decode_opt_box_autoadd_channel_id(raw[1]),
          latestBroadcastHeight: dco_decode_u_32(raw[2]),
          latestSpendingTxid: dco_decode_box_autoadd_txid(raw[3]),
          amountSatoshis: dco_decode_u_64(raw[4]),
        );
      case 2:
        return PendingSweepBalance_AwaitingThresholdConfirmations(
          channelId: dco_decode_opt_box_autoadd_channel_id(raw[1]),
          latestSpendingTxid: dco_decode_box_autoadd_txid(raw[2]),
          confirmationHash: dco_decode_String(raw[3]),
          confirmationHeight: dco_decode_u_32(raw[4]),
          amountSatoshis: dco_decode_u_64(raw[5]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PublicKey dco_decode_public_key(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return PublicKey(
      hex: dco_decode_String(arr[0]),
    );
  }

  @protected
  QrPaymentResult dco_decode_qr_payment_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return QrPaymentResult_Onchain(
          txid: dco_decode_box_autoadd_txid(raw[1]),
        );
      case 1:
        return QrPaymentResult_Bolt11(
          paymentId: dco_decode_box_autoadd_payment_id(raw[1]),
        );
      case 2:
        return QrPaymentResult_Bolt12(
          paymentId: dco_decode_box_autoadd_payment_id(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  (SocketAddress, PublicKey, String?)
      dco_decode_record_socket_address_public_key_opt_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_socket_address(arr[0]),
      dco_decode_public_key(arr[1]),
      dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  Refund dco_decode_refund(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Refund(
      s: dco_decode_String(arr[0]),
    );
  }

  @protected
  RoutingFees dco_decode_routing_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RoutingFees(
      baseMsat: dco_decode_u_32(arr[0]),
      proportionalMillionths: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  SendingParameters dco_decode_sending_parameters(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SendingParameters(
      maxTotalRoutingFeeMsat:
          dco_decode_opt_box_autoadd_max_total_routing_fee_limit(arr[0]),
      maxTotalCltvExpiryDelta: dco_decode_opt_box_autoadd_u_32(arr[1]),
      maxPathCount: dco_decode_opt_box_autoadd_u_8(arr[2]),
      maxChannelSaturationPowerOfHalf: dco_decode_opt_box_autoadd_u_8(arr[3]),
    );
  }

  @protected
  SocketAddress dco_decode_socket_address(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SocketAddress_TcpIpV4(
          addr: dco_decode_u_8_array_4(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      case 1:
        return SocketAddress_TcpIpV6(
          addr: dco_decode_u_8_array_16(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      case 2:
        return SocketAddress_OnionV2(
          dco_decode_u_8_array_12(raw[1]),
        );
      case 3:
        return SocketAddress_OnionV3(
          ed25519Pubkey: dco_decode_u_8_array_32(raw[1]),
          checksum: dco_decode_u_16(raw[2]),
          version: dco_decode_u_8(raw[3]),
          port: dco_decode_u_16(raw[4]),
        );
      case 4:
        return SocketAddress_Hostname(
          addr: dco_decode_String(raw[1]),
          port: dco_decode_u_16(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Txid dco_decode_txid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Txid(
      hash: dco_decode_String(arr[0]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  U8Array12 dco_decode_u_8_array_12(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array12(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array16 dco_decode_u_8_array_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array16(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array32 dco_decode_u_8_array_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array32(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array4 dco_decode_u_8_array_4(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array4(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  U8Array64 dco_decode_u_8_array_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return U8Array64(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  UserChannelId dco_decode_user_channel_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return UserChannelId(
      data: dco_decode_list_prim_u_8_strict(arr[0]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  FfiBuilder
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FfiBuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FfiBuilder
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FfiBuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FfiBuilder
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FfiBuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Map<String, String> sse_decode_Map_String_String(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_string(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  FfiBuilder
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FfiBuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Builder sse_decode_RustOpaque_ldk_nodeBuilder(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Node sse_decode_RustOpaque_ldk_nodeNode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NodeImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  NetworkGraph sse_decode_RustOpaque_ldk_nodegraphNetworkGraph(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NetworkGraphImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Bolt11Payment sse_decode_RustOpaque_ldk_nodepaymentBolt11Payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Bolt11PaymentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Bolt12Payment sse_decode_RustOpaque_ldk_nodepaymentBolt12Payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Bolt12PaymentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  OnchainPayment sse_decode_RustOpaque_ldk_nodepaymentOnchainPayment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OnchainPaymentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SpontaneousPayment sse_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SpontaneousPaymentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  UnifiedQrPayment sse_decode_RustOpaque_ldk_nodepaymentUnifiedQrPayment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UnifiedQrPaymentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Address sse_decode_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return Address(s: var_s);
  }

  @protected
  AnchorChannelsConfig sse_decode_anchor_channels_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_trustedPeersNoReserve = sse_decode_list_public_key(deserializer);
    var var_perChannelReserveSats = sse_decode_u_64(deserializer);
    return AnchorChannelsConfig(
        trustedPeersNoReserve: var_trustedPeersNoReserve,
        perChannelReserveSats: var_perChannelReserveSats);
  }

  @protected
  BalanceDetails sse_decode_balance_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_totalOnchainBalanceSats = sse_decode_u_64(deserializer);
    var var_spendableOnchainBalanceSats = sse_decode_u_64(deserializer);
    var var_totalLightningBalanceSats = sse_decode_u_64(deserializer);
    var var_lightningBalances = sse_decode_list_lightning_balance(deserializer);
    var var_pendingBalancesFromChannelClosures =
        sse_decode_list_pending_sweep_balance(deserializer);
    return BalanceDetails(
        totalOnchainBalanceSats: var_totalOnchainBalanceSats,
        spendableOnchainBalanceSats: var_spendableOnchainBalanceSats,
        totalLightningBalanceSats: var_totalLightningBalanceSats,
        lightningBalances: var_lightningBalances,
        pendingBalancesFromChannelClosures:
            var_pendingBalancesFromChannelClosures);
  }

  @protected
  BalanceSource sse_decode_balance_source(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return BalanceSource.values[inner];
  }

  @protected
  BestBlock sse_decode_best_block(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_blockHash = sse_decode_String(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    return BestBlock(blockHash: var_blockHash, height: var_height);
  }

  @protected
  Bolt11Invoice sse_decode_bolt_11_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_signedRawInvoice = sse_decode_String(deserializer);
    return Bolt11Invoice(signedRawInvoice: var_signedRawInvoice);
  }

  @protected
  Bolt12Invoice sse_decode_bolt_12_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_list_prim_u_8_strict(deserializer);
    return Bolt12Invoice(data: var_data);
  }

  @protected
  Bolt12ParseError sse_decode_bolt_12_parse_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return Bolt12ParseError_InvalidContinuation();
      case 1:
        return Bolt12ParseError_InvalidBech32Hrp();
      case 2:
        var var_field0 = sse_decode_String(deserializer);
        return Bolt12ParseError_Bech32(var_field0);
      case 3:
        var var_field0 = sse_decode_box_autoadd_decode_error(deserializer);
        return Bolt12ParseError_Decode(var_field0);
      case 4:
        var var_field0 = sse_decode_String(deserializer);
        return Bolt12ParseError_InvalidSemantics(var_field0);
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return Bolt12ParseError_InvalidSignature(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Address sse_decode_box_autoadd_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_address(deserializer));
  }

  @protected
  AnchorChannelsConfig sse_decode_box_autoadd_anchor_channels_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_anchor_channels_config(deserializer));
  }

  @protected
  Bolt11Invoice sse_decode_box_autoadd_bolt_11_invoice(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bolt_11_invoice(deserializer));
  }

  @protected
  Bolt12ParseError sse_decode_box_autoadd_bolt_12_parse_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bolt_12_parse_error(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  ChainDataSourceConfig sse_decode_box_autoadd_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_chain_data_source_config(deserializer));
  }

  @protected
  ChannelConfig sse_decode_box_autoadd_channel_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_config(deserializer));
  }

  @protected
  ChannelId sse_decode_box_autoadd_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_id(deserializer));
  }

  @protected
  ChannelInfo sse_decode_box_autoadd_channel_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_info(deserializer));
  }

  @protected
  ChannelUpdateInfo sse_decode_box_autoadd_channel_update_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_channel_update_info(deserializer));
  }

  @protected
  ClosureReason sse_decode_box_autoadd_closure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_closure_reason(deserializer));
  }

  @protected
  Config sse_decode_box_autoadd_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_config(deserializer));
  }

  @protected
  DecodeError sse_decode_box_autoadd_decode_error(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_decode_error(deserializer));
  }

  @protected
  EntropySourceConfig sse_decode_box_autoadd_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entropy_source_config(deserializer));
  }

  @protected
  EsploraSyncConfig sse_decode_box_autoadd_esplora_sync_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_esplora_sync_config(deserializer));
  }

  @protected
  Event sse_decode_box_autoadd_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_event(deserializer));
  }

  @protected
  FfiBolt11Payment sse_decode_box_autoadd_ffi_bolt_11_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_bolt_11_payment(deserializer));
  }

  @protected
  FfiBolt12Payment sse_decode_box_autoadd_ffi_bolt_12_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_bolt_12_payment(deserializer));
  }

  @protected
  FfiMnemonic sse_decode_box_autoadd_ffi_mnemonic(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_mnemonic(deserializer));
  }

  @protected
  FfiNetworkGraph sse_decode_box_autoadd_ffi_network_graph(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_network_graph(deserializer));
  }

  @protected
  FfiNode sse_decode_box_autoadd_ffi_node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_node(deserializer));
  }

  @protected
  FfiOnChainPayment sse_decode_box_autoadd_ffi_on_chain_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_on_chain_payment(deserializer));
  }

  @protected
  FfiSpontaneousPayment sse_decode_box_autoadd_ffi_spontaneous_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_spontaneous_payment(deserializer));
  }

  @protected
  FfiUnifiedQrPayment sse_decode_box_autoadd_ffi_unified_qr_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ffi_unified_qr_payment(deserializer));
  }

  @protected
  GossipSourceConfig sse_decode_box_autoadd_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_gossip_source_config(deserializer));
  }

  @protected
  LiquiditySourceConfig sse_decode_box_autoadd_liquidity_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_liquidity_source_config(deserializer));
  }

  @protected
  LSPFeeLimits sse_decode_box_autoadd_lsp_fee_limits(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lsp_fee_limits(deserializer));
  }

  @protected
  MaxTotalRoutingFeeLimit sse_decode_box_autoadd_max_total_routing_fee_limit(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_max_total_routing_fee_limit(deserializer));
  }

  @protected
  NodeAlias sse_decode_box_autoadd_node_alias(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_alias(deserializer));
  }

  @protected
  NodeAnnouncementInfo sse_decode_box_autoadd_node_announcement_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_announcement_info(deserializer));
  }

  @protected
  NodeId sse_decode_box_autoadd_node_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_id(deserializer));
  }

  @protected
  NodeInfo sse_decode_box_autoadd_node_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_node_info(deserializer));
  }

  @protected
  Offer sse_decode_box_autoadd_offer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_offer(deserializer));
  }

  @protected
  OfferId sse_decode_box_autoadd_offer_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_offer_id(deserializer));
  }

  @protected
  OutPoint sse_decode_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_out_point(deserializer));
  }

  @protected
  PaymentDetails sse_decode_box_autoadd_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_details(deserializer));
  }

  @protected
  PaymentFailureReason sse_decode_box_autoadd_payment_failure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_failure_reason(deserializer));
  }

  @protected
  PaymentHash sse_decode_box_autoadd_payment_hash(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_hash(deserializer));
  }

  @protected
  PaymentId sse_decode_box_autoadd_payment_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_id(deserializer));
  }

  @protected
  PaymentPreimage sse_decode_box_autoadd_payment_preimage(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_preimage(deserializer));
  }

  @protected
  PaymentSecret sse_decode_box_autoadd_payment_secret(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_payment_secret(deserializer));
  }

  @protected
  PublicKey sse_decode_box_autoadd_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_public_key(deserializer));
  }

  @protected
  Refund sse_decode_box_autoadd_refund(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_refund(deserializer));
  }

  @protected
  SendingParameters sse_decode_box_autoadd_sending_parameters(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sending_parameters(deserializer));
  }

  @protected
  SocketAddress sse_decode_box_autoadd_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_socket_address(deserializer));
  }

  @protected
  Txid sse_decode_box_autoadd_txid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_txid(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_16(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_8(deserializer));
  }

  @protected
  UserChannelId sse_decode_box_autoadd_user_channel_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user_channel_id(deserializer));
  }

  @protected
  ChainDataSourceConfig sse_decode_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_serverUrl = sse_decode_String(deserializer);
        var var_syncConfig =
            sse_decode_opt_box_autoadd_esplora_sync_config(deserializer);
        return ChainDataSourceConfig_Esplora(
            serverUrl: var_serverUrl, syncConfig: var_syncConfig);
      case 1:
        var var_rpcHost = sse_decode_String(deserializer);
        var var_rpcPort = sse_decode_u_16(deserializer);
        var var_rpcUser = sse_decode_String(deserializer);
        var var_rpcPassword = sse_decode_String(deserializer);
        return ChainDataSourceConfig_BitcoindRpc(
            rpcHost: var_rpcHost,
            rpcPort: var_rpcPort,
            rpcUser: var_rpcUser,
            rpcPassword: var_rpcPassword);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ChannelConfig sse_decode_channel_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_forwardingFeeProportionalMillionths = sse_decode_u_32(deserializer);
    var var_forwardingFeeBaseMsat = sse_decode_u_32(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_16(deserializer);
    var var_maxDustHtlcExposure =
        sse_decode_max_dust_htlc_exposure(deserializer);
    var var_forceCloseAvoidanceMaxFeeSatoshis = sse_decode_u_64(deserializer);
    var var_acceptUnderpayingHtlcs = sse_decode_bool(deserializer);
    return ChannelConfig(
        forwardingFeeProportionalMillionths:
            var_forwardingFeeProportionalMillionths,
        forwardingFeeBaseMsat: var_forwardingFeeBaseMsat,
        cltvExpiryDelta: var_cltvExpiryDelta,
        maxDustHtlcExposure: var_maxDustHtlcExposure,
        forceCloseAvoidanceMaxFeeSatoshis:
            var_forceCloseAvoidanceMaxFeeSatoshis,
        acceptUnderpayingHtlcs: var_acceptUnderpayingHtlcs);
  }

  @protected
  ChannelDetails sse_decode_channel_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_channelId = sse_decode_channel_id(deserializer);
    var var_counterpartyNodeId = sse_decode_public_key(deserializer);
    var var_fundingTxo = sse_decode_opt_box_autoadd_out_point(deserializer);
    var var_channelValueSats = sse_decode_u_64(deserializer);
    var var_unspendablePunishmentReserve =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_userChannelId = sse_decode_user_channel_id(deserializer);
    var var_feerateSatPer1000Weight = sse_decode_u_32(deserializer);
    var var_outboundCapacityMsat = sse_decode_u_64(deserializer);
    var var_inboundCapacityMsat = sse_decode_u_64(deserializer);
    var var_confirmationsRequired =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_confirmations = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_isOutbound = sse_decode_bool(deserializer);
    var var_isChannelReady = sse_decode_bool(deserializer);
    var var_isUsable = sse_decode_bool(deserializer);
    var var_cltvExpiryDelta = sse_decode_opt_box_autoadd_u_16(deserializer);
    var var_counterpartyUnspendablePunishmentReserve =
        sse_decode_u_64(deserializer);
    var var_counterpartyOutboundHtlcMinimumMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_counterpartyOutboundHtlcMaximumMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_counterpartyForwardingInfoFeeBaseMsat =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_counterpartyForwardingInfoFeeProportionalMillionths =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_counterpartyForwardingInfoCltvExpiryDelta =
        sse_decode_opt_box_autoadd_u_16(deserializer);
    var var_nextOutboundHtlcLimitMsat = sse_decode_u_64(deserializer);
    var var_nextOutboundHtlcMinimumMsat = sse_decode_u_64(deserializer);
    var var_forceCloseSpendDelay =
        sse_decode_opt_box_autoadd_u_16(deserializer);
    var var_inboundHtlcMinimumMsat = sse_decode_u_64(deserializer);
    var var_inboundHtlcMaximumMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_config = sse_decode_channel_config(deserializer);
    return ChannelDetails(
        channelId: var_channelId,
        counterpartyNodeId: var_counterpartyNodeId,
        fundingTxo: var_fundingTxo,
        channelValueSats: var_channelValueSats,
        unspendablePunishmentReserve: var_unspendablePunishmentReserve,
        userChannelId: var_userChannelId,
        feerateSatPer1000Weight: var_feerateSatPer1000Weight,
        outboundCapacityMsat: var_outboundCapacityMsat,
        inboundCapacityMsat: var_inboundCapacityMsat,
        confirmationsRequired: var_confirmationsRequired,
        confirmations: var_confirmations,
        isOutbound: var_isOutbound,
        isChannelReady: var_isChannelReady,
        isUsable: var_isUsable,
        cltvExpiryDelta: var_cltvExpiryDelta,
        counterpartyUnspendablePunishmentReserve:
            var_counterpartyUnspendablePunishmentReserve,
        counterpartyOutboundHtlcMinimumMsat:
            var_counterpartyOutboundHtlcMinimumMsat,
        counterpartyOutboundHtlcMaximumMsat:
            var_counterpartyOutboundHtlcMaximumMsat,
        counterpartyForwardingInfoFeeBaseMsat:
            var_counterpartyForwardingInfoFeeBaseMsat,
        counterpartyForwardingInfoFeeProportionalMillionths:
            var_counterpartyForwardingInfoFeeProportionalMillionths,
        counterpartyForwardingInfoCltvExpiryDelta:
            var_counterpartyForwardingInfoCltvExpiryDelta,
        nextOutboundHtlcLimitMsat: var_nextOutboundHtlcLimitMsat,
        nextOutboundHtlcMinimumMsat: var_nextOutboundHtlcMinimumMsat,
        forceCloseSpendDelay: var_forceCloseSpendDelay,
        inboundHtlcMinimumMsat: var_inboundHtlcMinimumMsat,
        inboundHtlcMaximumMsat: var_inboundHtlcMaximumMsat,
        config: var_config);
  }

  @protected
  ChannelId sse_decode_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return ChannelId(data: var_data);
  }

  @protected
  ChannelInfo sse_decode_channel_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_nodeOne = sse_decode_node_id(deserializer);
    var var_oneToTwo =
        sse_decode_opt_box_autoadd_channel_update_info(deserializer);
    var var_nodeTwo = sse_decode_node_id(deserializer);
    var var_twoToOne =
        sse_decode_opt_box_autoadd_channel_update_info(deserializer);
    var var_capacitySats = sse_decode_opt_box_autoadd_u_64(deserializer);
    return ChannelInfo(
        nodeOne: var_nodeOne,
        oneToTwo: var_oneToTwo,
        nodeTwo: var_nodeTwo,
        twoToOne: var_twoToOne,
        capacitySats: var_capacitySats);
  }

  @protected
  ChannelUpdateInfo sse_decode_channel_update_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lastUpdate = sse_decode_u_32(deserializer);
    var var_enabled = sse_decode_bool(deserializer);
    var var_cltvExpiryDelta = sse_decode_u_16(deserializer);
    var var_htlcMinimumMsat = sse_decode_u_64(deserializer);
    var var_htlcMaximumMsat = sse_decode_u_64(deserializer);
    var var_fees = sse_decode_routing_fees(deserializer);
    return ChannelUpdateInfo(
        lastUpdate: var_lastUpdate,
        enabled: var_enabled,
        cltvExpiryDelta: var_cltvExpiryDelta,
        htlcMinimumMsat: var_htlcMinimumMsat,
        htlcMaximumMsat: var_htlcMaximumMsat,
        fees: var_fees);
  }

  @protected
  ClosureReason sse_decode_closure_reason(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_peerFeerateSatPerKw = sse_decode_u_32(deserializer);
        var var_requiredFeerateSatPerKw = sse_decode_u_32(deserializer);
        return ClosureReason_PeerFeerateTooLow(
            peerFeerateSatPerKw: var_peerFeerateSatPerKw,
            requiredFeerateSatPerKw: var_requiredFeerateSatPerKw);
      case 1:
        var var_peerMsg = sse_decode_String(deserializer);
        return ClosureReason_CounterpartyForceClosed(peerMsg: var_peerMsg);
      case 2:
        var var_broadcastedLatestTxn =
            sse_decode_opt_box_autoadd_bool(deserializer);
        return ClosureReason_HolderForceClosed(
            broadcastedLatestTxn: var_broadcastedLatestTxn);
      case 3:
        return ClosureReason_LegacyCooperativeClosure();
      case 4:
        return ClosureReason_CounterpartyInitiatedCooperativeClosure();
      case 5:
        return ClosureReason_LocallyInitiatedCooperativeClosure();
      case 6:
        return ClosureReason_CommitmentTxConfirmed();
      case 7:
        return ClosureReason_FundingTimedOut();
      case 8:
        var var_err = sse_decode_String(deserializer);
        return ClosureReason_ProcessingError(err: var_err);
      case 9:
        return ClosureReason_DisconnectedPeer();
      case 10:
        return ClosureReason_OutdatedChannelManager();
      case 11:
        return ClosureReason_CounterpartyCoopClosedUnfundedChannel();
      case 12:
        return ClosureReason_FundingBatchClosure();
      case 13:
        return ClosureReason_HTLCsTimedOut();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Config sse_decode_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_storageDirPath = sse_decode_String(deserializer);
    var var_logDirPath = sse_decode_opt_String(deserializer);
    var var_network = sse_decode_network(deserializer);
    var var_listeningAddresses =
        sse_decode_opt_list_socket_address(deserializer);
    var var_nodeAlias = sse_decode_opt_box_autoadd_node_alias(deserializer);
    var var_trustedPeers0Conf = sse_decode_list_public_key(deserializer);
    var var_probingLiquidityLimitMultiplier = sse_decode_u_64(deserializer);
    var var_logLevel = sse_decode_log_level(deserializer);
    var var_anchorChannelsConfig =
        sse_decode_opt_box_autoadd_anchor_channels_config(deserializer);
    var var_sendingParameters =
        sse_decode_opt_box_autoadd_sending_parameters(deserializer);
    return Config(
        storageDirPath: var_storageDirPath,
        logDirPath: var_logDirPath,
        network: var_network,
        listeningAddresses: var_listeningAddresses,
        nodeAlias: var_nodeAlias,
        trustedPeers0Conf: var_trustedPeers0Conf,
        probingLiquidityLimitMultiplier: var_probingLiquidityLimitMultiplier,
        logLevel: var_logLevel,
        anchorChannelsConfig: var_anchorChannelsConfig,
        sendingParameters: var_sendingParameters);
  }

  @protected
  DecodeError sse_decode_decode_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DecodeError_UnknownVersion();
      case 1:
        return DecodeError_UnknownRequiredFeature();
      case 2:
        return DecodeError_InvalidValue();
      case 3:
        return DecodeError_ShortRead();
      case 4:
        return DecodeError_BadLengthDescriptor();
      case 5:
        var var_field0 = sse_decode_String(deserializer);
        return DecodeError_Io(var_field0);
      case 6:
        return DecodeError_UnsupportedCompression();
      case 7:
        return DecodeError_DangerousValue();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  EntropySourceConfig sse_decode_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return EntropySourceConfig_SeedFile(var_field0);
      case 1:
        var var_field0 = sse_decode_u_8_array_64(deserializer);
        return EntropySourceConfig_SeedBytes(var_field0);
      case 2:
        var var_mnemonic = sse_decode_box_autoadd_ffi_mnemonic(deserializer);
        var var_passphrase = sse_decode_opt_String(deserializer);
        return EntropySourceConfig_Bip39Mnemonic(
            mnemonic: var_mnemonic, passphrase: var_passphrase);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  EsploraSyncConfig sse_decode_esplora_sync_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_onchainWalletSyncIntervalSecs = sse_decode_u_64(deserializer);
    var var_lightningWalletSyncIntervalSecs = sse_decode_u_64(deserializer);
    var var_feeRateCacheUpdateIntervalSecs = sse_decode_u_64(deserializer);
    return EsploraSyncConfig(
        onchainWalletSyncIntervalSecs: var_onchainWalletSyncIntervalSecs,
        lightningWalletSyncIntervalSecs: var_lightningWalletSyncIntervalSecs,
        feeRateCacheUpdateIntervalSecs: var_feeRateCacheUpdateIntervalSecs);
  }

  @protected
  Event sse_decode_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_paymentId = sse_decode_box_autoadd_payment_id(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_claimableAmountMsat = sse_decode_u_64(deserializer);
        var var_claimDeadline = sse_decode_opt_box_autoadd_u_32(deserializer);
        return Event_PaymentClaimable(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            claimableAmountMsat: var_claimableAmountMsat,
            claimDeadline: var_claimDeadline);
      case 1:
        var var_paymentId = sse_decode_opt_box_autoadd_payment_id(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_feePaidMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
        return Event_PaymentSuccessful(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            feePaidMsat: var_feePaidMsat);
      case 2:
        var var_paymentId = sse_decode_opt_box_autoadd_payment_id(deserializer);
        var var_paymentHash =
            sse_decode_opt_box_autoadd_payment_hash(deserializer);
        var var_reason =
            sse_decode_opt_box_autoadd_payment_failure_reason(deserializer);
        return Event_PaymentFailed(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            reason: var_reason);
      case 3:
        var var_paymentId = sse_decode_opt_box_autoadd_payment_id(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_amountMsat = sse_decode_u_64(deserializer);
        return Event_PaymentReceived(
            paymentId: var_paymentId,
            paymentHash: var_paymentHash,
            amountMsat: var_amountMsat);
      case 4:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_formerTemporaryChannelId =
            sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_fundingTxo = sse_decode_box_autoadd_out_point(deserializer);
        return Event_ChannelPending(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            formerTemporaryChannelId: var_formerTemporaryChannelId,
            counterpartyNodeId: var_counterpartyNodeId,
            fundingTxo: var_fundingTxo);
      case 5:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_opt_box_autoadd_public_key(deserializer);
        return Event_ChannelReady(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            counterpartyNodeId: var_counterpartyNodeId);
      case 6:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_userChannelId =
            sse_decode_box_autoadd_user_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_opt_box_autoadd_public_key(deserializer);
        var var_reason =
            sse_decode_opt_box_autoadd_closure_reason(deserializer);
        return Event_ChannelClosed(
            channelId: var_channelId,
            userChannelId: var_userChannelId,
            counterpartyNodeId: var_counterpartyNodeId,
            reason: var_reason);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  FfiBolt11Payment sse_decode_ffi_bolt_11_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_ldk_nodepaymentBolt11Payment(deserializer);
    return FfiBolt11Payment(opaque: var_opaque);
  }

  @protected
  FfiBolt12Payment sse_decode_ffi_bolt_12_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_ldk_nodepaymentBolt12Payment(deserializer);
    return FfiBolt12Payment(opaque: var_opaque);
  }

  @protected
  FfiBuilderError sse_decode_ffi_builder_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return FfiBuilderError.values[inner];
  }

  @protected
  FfiMnemonic sse_decode_ffi_mnemonic(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_seedPhrase = sse_decode_String(deserializer);
    return FfiMnemonic(seedPhrase: var_seedPhrase);
  }

  @protected
  FfiNetworkGraph sse_decode_ffi_network_graph(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_ldk_nodegraphNetworkGraph(deserializer);
    return FfiNetworkGraph(opaque: var_opaque);
  }

  @protected
  FfiNode sse_decode_ffi_node(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque = sse_decode_RustOpaque_ldk_nodeNode(deserializer);
    return FfiNode(opaque: var_opaque);
  }

  @protected
  FfiNodeError sse_decode_ffi_node_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return FfiNodeError_InvalidTxid();
      case 1:
        return FfiNodeError_AlreadyRunning();
      case 2:
        return FfiNodeError_NotRunning();
      case 3:
        return FfiNodeError_OnchainTxCreationFailed();
      case 4:
        return FfiNodeError_ConnectionFailed();
      case 5:
        return FfiNodeError_InvoiceCreationFailed();
      case 6:
        return FfiNodeError_PaymentSendingFailed();
      case 7:
        return FfiNodeError_ProbeSendingFailed();
      case 8:
        return FfiNodeError_ChannelCreationFailed();
      case 9:
        return FfiNodeError_ChannelClosingFailed();
      case 10:
        return FfiNodeError_ChannelConfigUpdateFailed();
      case 11:
        return FfiNodeError_PersistenceFailed();
      case 12:
        return FfiNodeError_WalletOperationFailed();
      case 13:
        return FfiNodeError_OnchainTxSigningFailed();
      case 14:
        return FfiNodeError_MessageSigningFailed();
      case 15:
        return FfiNodeError_TxSyncFailed();
      case 16:
        return FfiNodeError_GossipUpdateFailed();
      case 17:
        return FfiNodeError_InvalidAddress();
      case 18:
        return FfiNodeError_InvalidSocketAddress();
      case 19:
        return FfiNodeError_InvalidPublicKey();
      case 20:
        return FfiNodeError_InvalidSecretKey();
      case 21:
        return FfiNodeError_InvalidPaymentHash();
      case 22:
        return FfiNodeError_InvalidPaymentPreimage();
      case 23:
        return FfiNodeError_InvalidPaymentSecret();
      case 24:
        return FfiNodeError_InvalidAmount();
      case 25:
        return FfiNodeError_InvalidInvoice();
      case 26:
        return FfiNodeError_InvalidChannelId();
      case 27:
        return FfiNodeError_InvalidNetwork();
      case 28:
        return FfiNodeError_DuplicatePayment();
      case 29:
        return FfiNodeError_InsufficientFunds();
      case 30:
        return FfiNodeError_FeerateEstimationUpdateFailed();
      case 31:
        return FfiNodeError_LiquidityRequestFailed();
      case 32:
        return FfiNodeError_LiquiditySourceUnavailable();
      case 33:
        return FfiNodeError_LiquidityFeeTooHigh();
      case 34:
        return FfiNodeError_InvalidPaymentId();
      case 35:
        var var_field0 = sse_decode_box_autoadd_decode_error(deserializer);
        return FfiNodeError_Decode(var_field0);
      case 36:
        var var_field0 =
            sse_decode_box_autoadd_bolt_12_parse_error(deserializer);
        return FfiNodeError_Bolt12Parse(var_field0);
      case 37:
        return FfiNodeError_InvoiceRequestCreationFailed();
      case 38:
        return FfiNodeError_OfferCreationFailed();
      case 39:
        return FfiNodeError_RefundCreationFailed();
      case 40:
        return FfiNodeError_FeerateEstimationUpdateTimeout();
      case 41:
        return FfiNodeError_WalletOperationTimeout();
      case 42:
        return FfiNodeError_TxSyncTimeout();
      case 43:
        return FfiNodeError_GossipUpdateTimeout();
      case 44:
        return FfiNodeError_InvalidOfferId();
      case 45:
        return FfiNodeError_InvalidNodeId();
      case 46:
        return FfiNodeError_InvalidOffer();
      case 47:
        return FfiNodeError_InvalidRefund();
      case 48:
        return FfiNodeError_UnsupportedCurrency();
      case 49:
        return FfiNodeError_UriParameterParsingFailed();
      case 50:
        return FfiNodeError_InvalidUri();
      case 51:
        return FfiNodeError_InvalidQuantity();
      case 52:
        return FfiNodeError_InvalidNodeAlias();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  FfiOnChainPayment sse_decode_ffi_on_chain_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_ldk_nodepaymentOnchainPayment(deserializer);
    return FfiOnChainPayment(opaque: var_opaque);
  }

  @protected
  FfiSpontaneousPayment sse_decode_ffi_spontaneous_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_ldk_nodepaymentSpontaneousPayment(deserializer);
    return FfiSpontaneousPayment(opaque: var_opaque);
  }

  @protected
  FfiUnifiedQrPayment sse_decode_ffi_unified_qr_payment(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_opaque =
        sse_decode_RustOpaque_ldk_nodepaymentUnifiedQrPayment(deserializer);
    return FfiUnifiedQrPayment(opaque: var_opaque);
  }

  @protected
  GossipSourceConfig sse_decode_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return GossipSourceConfig_P2PNetwork();
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return GossipSourceConfig_RapidGossipSync(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  LightningBalance sse_decode_lightning_balance(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_transactionFeeSatoshis = sse_decode_u_64(deserializer);
        var var_outboundPaymentHtlcRoundedMsat = sse_decode_u_64(deserializer);
        var var_outboundForwardedHtlcRoundedMsat =
            sse_decode_u_64(deserializer);
        var var_inboundClaimingHtlcRoundedMsat = sse_decode_u_64(deserializer);
        var var_inboundHtlcRoundedMsat = sse_decode_u_64(deserializer);
        return LightningBalance_ClaimableOnChannelClose(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            transactionFeeSatoshis: var_transactionFeeSatoshis,
            outboundPaymentHtlcRoundedMsat: var_outboundPaymentHtlcRoundedMsat,
            outboundForwardedHtlcRoundedMsat:
                var_outboundForwardedHtlcRoundedMsat,
            inboundClaimingHtlcRoundedMsat: var_inboundClaimingHtlcRoundedMsat,
            inboundHtlcRoundedMsat: var_inboundHtlcRoundedMsat);
      case 1:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_confirmationHeight = sse_decode_u_32(deserializer);
        var var_source = sse_decode_balance_source(deserializer);
        return LightningBalance_ClaimableAwaitingConfirmations(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            confirmationHeight: var_confirmationHeight,
            source: var_source);
      case 2:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_timeoutHeight = sse_decode_u_32(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_paymentPreimage =
            sse_decode_box_autoadd_payment_preimage(deserializer);
        return LightningBalance_ContentiousClaimable(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            timeoutHeight: var_timeoutHeight,
            paymentHash: var_paymentHash,
            paymentPreimage: var_paymentPreimage);
      case 3:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_claimableHeight = sse_decode_u_32(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_outboundPayment = sse_decode_bool(deserializer);
        return LightningBalance_MaybeTimeoutClaimableHTLC(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            claimableHeight: var_claimableHeight,
            paymentHash: var_paymentHash,
            outboundPayment: var_outboundPayment);
      case 4:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        var var_expiryHeight = sse_decode_u_32(deserializer);
        var var_paymentHash = sse_decode_box_autoadd_payment_hash(deserializer);
        return LightningBalance_MaybePreimageClaimableHTLC(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis,
            expiryHeight: var_expiryHeight,
            paymentHash: var_paymentHash);
      case 5:
        var var_channelId = sse_decode_box_autoadd_channel_id(deserializer);
        var var_counterpartyNodeId =
            sse_decode_box_autoadd_public_key(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return LightningBalance_CounterpartyRevokedOutputClaimable(
            channelId: var_channelId,
            counterpartyNodeId: var_counterpartyNodeId,
            amountSatoshis: var_amountSatoshis);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  LiquiditySourceConfig sse_decode_liquidity_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lsps2Service =
        sse_decode_record_socket_address_public_key_opt_string(deserializer);
    return LiquiditySourceConfig(lsps2Service: var_lsps2Service);
  }

  @protected
  List<ChannelDetails> sse_decode_list_channel_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ChannelDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_channel_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<LightningBalance> sse_decode_list_lightning_balance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LightningBalance>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_lightning_balance(deserializer));
    }
    return ans_;
  }

  @protected
  List<NodeId> sse_decode_list_node_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NodeId>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_node_id(deserializer));
    }
    return ans_;
  }

  @protected
  List<PaymentDetails> sse_decode_list_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PaymentDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_payment_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<PeerDetails> sse_decode_list_peer_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PeerDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_peer_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<PendingSweepBalance> sse_decode_list_pending_sweep_balance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PendingSweepBalance>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_pending_sweep_balance(deserializer));
    }
    return ans_;
  }

  @protected
  Uint64List sse_decode_list_prim_u_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<PublicKey> sse_decode_list_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PublicKey>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_public_key(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<SocketAddress> sse_decode_list_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SocketAddress>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_socket_address(deserializer));
    }
    return ans_;
  }

  @protected
  LogLevel sse_decode_log_level(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return LogLevel.values[inner];
  }

  @protected
  LSPFeeLimits sse_decode_lsp_fee_limits(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_maxTotalOpeningFeeMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_maxProportionalOpeningFeePpmMsat =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    return LSPFeeLimits(
        maxTotalOpeningFeeMsat: var_maxTotalOpeningFeeMsat,
        maxProportionalOpeningFeePpmMsat: var_maxProportionalOpeningFeePpmMsat);
  }

  @protected
  MaxDustHTLCExposure sse_decode_max_dust_htlc_exposure(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_u_64(deserializer);
        return MaxDustHTLCExposure_FixedLimitMsat(var_field0);
      case 1:
        var var_field0 = sse_decode_u_64(deserializer);
        return MaxDustHTLCExposure_FeeRateMultiplier(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  MaxTotalRoutingFeeLimit sse_decode_max_total_routing_fee_limit(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return MaxTotalRoutingFeeLimit_NoFeeCap();
      case 1:
        var var_amountMsat = sse_decode_u_64(deserializer);
        return MaxTotalRoutingFeeLimit_FeeCap(amountMsat: var_amountMsat);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Network sse_decode_network(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Network.values[inner];
  }

  @protected
  NodeAlias sse_decode_node_alias(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_8_array_32(deserializer);
    return NodeAlias(field0: var_field0);
  }

  @protected
  NodeAnnouncementInfo sse_decode_node_announcement_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lastUpdate = sse_decode_u_32(deserializer);
    var var_alias = sse_decode_String(deserializer);
    var var_addresses = sse_decode_list_socket_address(deserializer);
    return NodeAnnouncementInfo(
        lastUpdate: var_lastUpdate, alias: var_alias, addresses: var_addresses);
  }

  @protected
  NodeId sse_decode_node_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_compressed = sse_decode_list_prim_u_8_strict(deserializer);
    return NodeId(compressed: var_compressed);
  }

  @protected
  NodeInfo sse_decode_node_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_channels = sse_decode_list_prim_u_64_strict(deserializer);
    var var_announcementInfo =
        sse_decode_opt_box_autoadd_node_announcement_info(deserializer);
    return NodeInfo(
        channels: var_channels, announcementInfo: var_announcementInfo);
  }

  @protected
  NodeStatus sse_decode_node_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_isRunning = sse_decode_bool(deserializer);
    var var_isListening = sse_decode_bool(deserializer);
    var var_currentBestBlock = sse_decode_best_block(deserializer);
    var var_latestLightningWalletSyncTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestOnchainWalletSyncTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestFeeRateCacheUpdateTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestRgsSnapshotTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestNodeAnnouncementBroadcastTimestamp =
        sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_latestChannelMonitorArchivalHeight =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    return NodeStatus(
        isRunning: var_isRunning,
        isListening: var_isListening,
        currentBestBlock: var_currentBestBlock,
        latestLightningWalletSyncTimestamp:
            var_latestLightningWalletSyncTimestamp,
        latestOnchainWalletSyncTimestamp: var_latestOnchainWalletSyncTimestamp,
        latestFeeRateCacheUpdateTimestamp:
            var_latestFeeRateCacheUpdateTimestamp,
        latestRgsSnapshotTimestamp: var_latestRgsSnapshotTimestamp,
        latestNodeAnnouncementBroadcastTimestamp:
            var_latestNodeAnnouncementBroadcastTimestamp,
        latestChannelMonitorArchivalHeight:
            var_latestChannelMonitorArchivalHeight);
  }

  @protected
  Offer sse_decode_offer(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return Offer(s: var_s);
  }

  @protected
  OfferId sse_decode_offer_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_8_array_32(deserializer);
    return OfferId(field0: var_field0);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  AnchorChannelsConfig? sse_decode_opt_box_autoadd_anchor_channels_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_anchor_channels_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChainDataSourceConfig? sse_decode_opt_box_autoadd_chain_data_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_chain_data_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelConfig? sse_decode_opt_box_autoadd_channel_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelId? sse_decode_opt_box_autoadd_channel_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_id(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelInfo? sse_decode_opt_box_autoadd_channel_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ChannelUpdateInfo? sse_decode_opt_box_autoadd_channel_update_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_channel_update_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  ClosureReason? sse_decode_opt_box_autoadd_closure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_closure_reason(deserializer));
    } else {
      return null;
    }
  }

  @protected
  EntropySourceConfig? sse_decode_opt_box_autoadd_entropy_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_entropy_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  EsploraSyncConfig? sse_decode_opt_box_autoadd_esplora_sync_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_esplora_sync_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Event? sse_decode_opt_box_autoadd_event(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_event(deserializer));
    } else {
      return null;
    }
  }

  @protected
  GossipSourceConfig? sse_decode_opt_box_autoadd_gossip_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_gossip_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  LiquiditySourceConfig? sse_decode_opt_box_autoadd_liquidity_source_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_liquidity_source_config(deserializer));
    } else {
      return null;
    }
  }

  @protected
  MaxTotalRoutingFeeLimit?
      sse_decode_opt_box_autoadd_max_total_routing_fee_limit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_max_total_routing_fee_limit(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NodeAlias? sse_decode_opt_box_autoadd_node_alias(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_node_alias(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NodeAnnouncementInfo? sse_decode_opt_box_autoadd_node_announcement_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_node_announcement_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NodeInfo? sse_decode_opt_box_autoadd_node_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_node_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint? sse_decode_opt_box_autoadd_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_out_point(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentDetails? sse_decode_opt_box_autoadd_payment_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_details(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentFailureReason? sse_decode_opt_box_autoadd_payment_failure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_failure_reason(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentHash? sse_decode_opt_box_autoadd_payment_hash(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_hash(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentId? sse_decode_opt_box_autoadd_payment_id(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_id(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentPreimage? sse_decode_opt_box_autoadd_payment_preimage(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_preimage(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PaymentSecret? sse_decode_opt_box_autoadd_payment_secret(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_payment_secret(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PublicKey? sse_decode_opt_box_autoadd_public_key(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_public_key(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SendingParameters? sse_decode_opt_box_autoadd_sending_parameters(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_sending_parameters(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_16(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_8(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<SocketAddress>? sse_decode_opt_list_socket_address(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_socket_address(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutPoint sse_decode_out_point(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_txid = sse_decode_txid(deserializer);
    var var_vout = sse_decode_u_32(deserializer);
    return OutPoint(txid: var_txid, vout: var_vout);
  }

  @protected
  PaymentDetails sse_decode_payment_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_payment_id(deserializer);
    var var_kind = sse_decode_payment_kind(deserializer);
    var var_amountMsat = sse_decode_opt_box_autoadd_u_64(deserializer);
    var var_direction = sse_decode_payment_direction(deserializer);
    var var_status = sse_decode_payment_status(deserializer);
    var var_latestUpdateTimestamp = sse_decode_u_64(deserializer);
    return PaymentDetails(
        id: var_id,
        kind: var_kind,
        amountMsat: var_amountMsat,
        direction: var_direction,
        status: var_status,
        latestUpdateTimestamp: var_latestUpdateTimestamp);
  }

  @protected
  PaymentDirection sse_decode_payment_direction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentDirection.values[inner];
  }

  @protected
  PaymentFailureReason sse_decode_payment_failure_reason(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentFailureReason.values[inner];
  }

  @protected
  PaymentHash sse_decode_payment_hash(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentHash(data: var_data);
  }

  @protected
  PaymentId sse_decode_payment_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_8_array_32(deserializer);
    return PaymentId(field0: var_field0);
  }

  @protected
  PaymentKind sse_decode_payment_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return PaymentKind_Onchain();
      case 1:
        var var_hash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        var var_secret =
            sse_decode_opt_box_autoadd_payment_secret(deserializer);
        return PaymentKind_Bolt11(
            hash: var_hash, preimage: var_preimage, secret: var_secret);
      case 2:
        var var_hash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        var var_secret =
            sse_decode_opt_box_autoadd_payment_secret(deserializer);
        var var_lspFeeLimits =
            sse_decode_box_autoadd_lsp_fee_limits(deserializer);
        return PaymentKind_Bolt11Jit(
            hash: var_hash,
            preimage: var_preimage,
            secret: var_secret,
            lspFeeLimits: var_lspFeeLimits);
      case 3:
        var var_hash = sse_decode_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        return PaymentKind_Spontaneous(hash: var_hash, preimage: var_preimage);
      case 4:
        var var_hash = sse_decode_opt_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        var var_secret =
            sse_decode_opt_box_autoadd_payment_secret(deserializer);
        var var_offerId = sse_decode_box_autoadd_offer_id(deserializer);
        var var_payerNote = sse_decode_opt_String(deserializer);
        var var_quantity = sse_decode_opt_box_autoadd_u_64(deserializer);
        return PaymentKind_Bolt12Offer(
            hash: var_hash,
            preimage: var_preimage,
            secret: var_secret,
            offerId: var_offerId,
            payerNote: var_payerNote,
            quantity: var_quantity);
      case 5:
        var var_hash = sse_decode_opt_box_autoadd_payment_hash(deserializer);
        var var_preimage =
            sse_decode_opt_box_autoadd_payment_preimage(deserializer);
        var var_secret =
            sse_decode_opt_box_autoadd_payment_secret(deserializer);
        var var_payerNote = sse_decode_opt_String(deserializer);
        var var_quantity = sse_decode_opt_box_autoadd_u_64(deserializer);
        return PaymentKind_Bolt12Refund(
            hash: var_hash,
            preimage: var_preimage,
            secret: var_secret,
            payerNote: var_payerNote,
            quantity: var_quantity);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PaymentPreimage sse_decode_payment_preimage(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentPreimage(data: var_data);
  }

  @protected
  PaymentSecret sse_decode_payment_secret(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_u_8_array_32(deserializer);
    return PaymentSecret(data: var_data);
  }

  @protected
  PaymentStatus sse_decode_payment_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return PaymentStatus.values[inner];
  }

  @protected
  PeerDetails sse_decode_peer_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_nodeId = sse_decode_public_key(deserializer);
    var var_address = sse_decode_socket_address(deserializer);
    var var_isConnected = sse_decode_bool(deserializer);
    return PeerDetails(
        nodeId: var_nodeId, address: var_address, isConnected: var_isConnected);
  }

  @protected
  PendingSweepBalance sse_decode_pending_sweep_balance(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_channelId = sse_decode_opt_box_autoadd_channel_id(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return PendingSweepBalance_PendingBroadcast(
            channelId: var_channelId, amountSatoshis: var_amountSatoshis);
      case 1:
        var var_channelId = sse_decode_opt_box_autoadd_channel_id(deserializer);
        var var_latestBroadcastHeight = sse_decode_u_32(deserializer);
        var var_latestSpendingTxid = sse_decode_box_autoadd_txid(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return PendingSweepBalance_BroadcastAwaitingConfirmation(
            channelId: var_channelId,
            latestBroadcastHeight: var_latestBroadcastHeight,
            latestSpendingTxid: var_latestSpendingTxid,
            amountSatoshis: var_amountSatoshis);
      case 2:
        var var_channelId = sse_decode_opt_box_autoadd_channel_id(deserializer);
        var var_latestSpendingTxid = sse_decode_box_autoadd_txid(deserializer);
        var var_confirmationHash = sse_decode_String(deserializer);
        var var_confirmationHeight = sse_decode_u_32(deserializer);
        var var_amountSatoshis = sse_decode_u_64(deserializer);
        return PendingSweepBalance_AwaitingThresholdConfirmations(
            channelId: var_channelId,
            latestSpendingTxid: var_latestSpendingTxid,
            confirmationHash: var_confirmationHash,
            confirmationHeight: var_confirmationHeight,
            amountSatoshis: var_amountSatoshis);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PublicKey sse_decode_public_key(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hex = sse_decode_String(deserializer);
    return PublicKey(hex: var_hex);
  }

  @protected
  QrPaymentResult sse_decode_qr_payment_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_txid = sse_decode_box_autoadd_txid(deserializer);
        return QrPaymentResult_Onchain(txid: var_txid);
      case 1:
        var var_paymentId = sse_decode_box_autoadd_payment_id(deserializer);
        return QrPaymentResult_Bolt11(paymentId: var_paymentId);
      case 2:
        var var_paymentId = sse_decode_box_autoadd_payment_id(deserializer);
        return QrPaymentResult_Bolt12(paymentId: var_paymentId);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  (SocketAddress, PublicKey, String?)
      sse_decode_record_socket_address_public_key_opt_string(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_socket_address(deserializer);
    var var_field1 = sse_decode_public_key(deserializer);
    var var_field2 = sse_decode_opt_String(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  Refund sse_decode_refund(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_s = sse_decode_String(deserializer);
    return Refund(s: var_s);
  }

  @protected
  RoutingFees sse_decode_routing_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_baseMsat = sse_decode_u_32(deserializer);
    var var_proportionalMillionths = sse_decode_u_32(deserializer);
    return RoutingFees(
        baseMsat: var_baseMsat,
        proportionalMillionths: var_proportionalMillionths);
  }

  @protected
  SendingParameters sse_decode_sending_parameters(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_maxTotalRoutingFeeMsat =
        sse_decode_opt_box_autoadd_max_total_routing_fee_limit(deserializer);
    var var_maxTotalCltvExpiryDelta =
        sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_maxPathCount = sse_decode_opt_box_autoadd_u_8(deserializer);
    var var_maxChannelSaturationPowerOfHalf =
        sse_decode_opt_box_autoadd_u_8(deserializer);
    return SendingParameters(
        maxTotalRoutingFeeMsat: var_maxTotalRoutingFeeMsat,
        maxTotalCltvExpiryDelta: var_maxTotalCltvExpiryDelta,
        maxPathCount: var_maxPathCount,
        maxChannelSaturationPowerOfHalf: var_maxChannelSaturationPowerOfHalf);
  }

  @protected
  SocketAddress sse_decode_socket_address(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_addr = sse_decode_u_8_array_4(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_TcpIpV4(addr: var_addr, port: var_port);
      case 1:
        var var_addr = sse_decode_u_8_array_16(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_TcpIpV6(addr: var_addr, port: var_port);
      case 2:
        var var_field0 = sse_decode_u_8_array_12(deserializer);
        return SocketAddress_OnionV2(var_field0);
      case 3:
        var var_ed25519Pubkey = sse_decode_u_8_array_32(deserializer);
        var var_checksum = sse_decode_u_16(deserializer);
        var var_version = sse_decode_u_8(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_OnionV3(
            ed25519Pubkey: var_ed25519Pubkey,
            checksum: var_checksum,
            version: var_version,
            port: var_port);
      case 4:
        var var_addr = sse_decode_String(deserializer);
        var var_port = sse_decode_u_16(deserializer);
        return SocketAddress_Hostname(addr: var_addr, port: var_port);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Txid sse_decode_txid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hash = sse_decode_String(deserializer);
    return Txid(hash: var_hash);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  U8Array12 sse_decode_u_8_array_12(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array12(inner);
  }

  @protected
  U8Array16 sse_decode_u_8_array_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array16(inner);
  }

  @protected
  U8Array32 sse_decode_u_8_array_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array32(inner);
  }

  @protected
  U8Array4 sse_decode_u_8_array_4(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array4(inner);
  }

  @protected
  U8Array64 sse_decode_u_8_array_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return U8Array64(inner);
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  UserChannelId sse_decode_user_channel_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_data = sse_decode_list_prim_u_8_strict(deserializer);
    return UserChannelId(data: var_data);
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
      FfiBuilder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as FfiBuilderImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
      FfiBuilder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as FfiBuilderImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
      FfiBuilder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as FfiBuilderImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
      FfiBuilder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as FfiBuilderImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodeBuilder(Builder raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as BuilderImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodeNode(Node raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as NodeImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodegraphNetworkGraph(NetworkGraph raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as NetworkGraphImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentBolt11Payment(Bolt11Payment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as Bolt11PaymentImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentBolt12Payment(Bolt12Payment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as Bolt12PaymentImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentOnchainPayment(OnchainPayment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as OnchainPaymentImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
      SpontaneousPayment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as SpontaneousPaymentImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_ldk_nodepaymentUnifiedQrPayment(
      UnifiedQrPayment raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as UnifiedQrPaymentImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_balance_source(BalanceSource raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_ffi_builder_error(FfiBuilderError raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_log_level(LogLevel raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_network(Network raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_direction(PaymentDirection raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_failure_reason(PaymentFailureReason raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_payment_status(PaymentStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          FfiBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FfiBuilderImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          FfiBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FfiBuilderImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          FfiBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FfiBuilderImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_Map_String_String(
      Map<String, String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_string(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
          FfiBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FfiBuilderImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodeBuilder(
      Builder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as BuilderImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodeNode(Node self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NodeImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodegraphNetworkGraph(
      NetworkGraph self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NetworkGraphImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentBolt11Payment(
      Bolt11Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Bolt11PaymentImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentBolt12Payment(
      Bolt12Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Bolt12PaymentImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentOnchainPayment(
      OnchainPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as OnchainPaymentImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
      SpontaneousPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SpontaneousPaymentImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_RustOpaque_ldk_nodepaymentUnifiedQrPayment(
      UnifiedQrPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as UnifiedQrPaymentImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_address(Address self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_anchor_channels_config(
      AnchorChannelsConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_public_key(self.trustedPeersNoReserve, serializer);
    sse_encode_u_64(self.perChannelReserveSats, serializer);
  }

  @protected
  void sse_encode_balance_details(
      BalanceDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.totalOnchainBalanceSats, serializer);
    sse_encode_u_64(self.spendableOnchainBalanceSats, serializer);
    sse_encode_u_64(self.totalLightningBalanceSats, serializer);
    sse_encode_list_lightning_balance(self.lightningBalances, serializer);
    sse_encode_list_pending_sweep_balance(
        self.pendingBalancesFromChannelClosures, serializer);
  }

  @protected
  void sse_encode_balance_source(BalanceSource self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_best_block(BestBlock self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.blockHash, serializer);
    sse_encode_u_32(self.height, serializer);
  }

  @protected
  void sse_encode_bolt_11_invoice(
      Bolt11Invoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.signedRawInvoice, serializer);
  }

  @protected
  void sse_encode_bolt_12_invoice(
      Bolt12Invoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_bolt_12_parse_error(
      Bolt12ParseError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Bolt12ParseError_InvalidContinuation():
        sse_encode_i_32(0, serializer);
      case Bolt12ParseError_InvalidBech32Hrp():
        sse_encode_i_32(1, serializer);
      case Bolt12ParseError_Bech32(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_String(field0, serializer);
      case Bolt12ParseError_Decode(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_decode_error(field0, serializer);
      case Bolt12ParseError_InvalidSemantics(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_String(field0, serializer);
      case Bolt12ParseError_InvalidSignature(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_address(Address self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_anchor_channels_config(
      AnchorChannelsConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_anchor_channels_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bolt_11_invoice(
      Bolt11Invoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bolt_11_invoice(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bolt_12_parse_error(
      Bolt12ParseError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bolt_12_parse_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_chain_data_source_config(
      ChainDataSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_chain_data_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_config(
      ChannelConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_id(
      ChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_info(
      ChannelInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_channel_update_info(
      ChannelUpdateInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_update_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_closure_reason(
      ClosureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_closure_reason(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_decode_error(
      DecodeError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_decode_error(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entropy_source_config(
      EntropySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entropy_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_esplora_sync_config(
      EsploraSyncConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_esplora_sync_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_event(Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_event(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_bolt_11_payment(
      FfiBolt11Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_bolt_11_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_bolt_12_payment(
      FfiBolt12Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_bolt_12_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_mnemonic(
      FfiMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_mnemonic(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_network_graph(
      FfiNetworkGraph self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_network_graph(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_node(FfiNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_node(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_on_chain_payment(
      FfiOnChainPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_on_chain_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_spontaneous_payment(
      FfiSpontaneousPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_spontaneous_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_ffi_unified_qr_payment(
      FfiUnifiedQrPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ffi_unified_qr_payment(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_gossip_source_config(
      GossipSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gossip_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_liquidity_source_config(
      LiquiditySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_liquidity_source_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lsp_fee_limits(
      LSPFeeLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lsp_fee_limits(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_max_total_routing_fee_limit(
      MaxTotalRoutingFeeLimit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_max_total_routing_fee_limit(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_alias(
      NodeAlias self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_alias(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_announcement_info(
      NodeAnnouncementInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_announcement_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_id(NodeId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_node_info(
      NodeInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_offer(Offer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_offer(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_offer_id(OfferId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_offer_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_out_point(
      OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_out_point(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_details(
      PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_details(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_failure_reason(
      PaymentFailureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_failure_reason(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_hash(
      PaymentHash self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_hash(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_id(
      PaymentId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_preimage(
      PaymentPreimage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_preimage(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_payment_secret(
      PaymentSecret self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_secret(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_public_key(
      PublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_public_key(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_refund(Refund self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_refund(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sending_parameters(
      SendingParameters self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sending_parameters(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_socket_address(
      SocketAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_socket_address(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_txid(Txid self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_txid(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_16(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user_channel_id(
      UserChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user_channel_id(self, serializer);
  }

  @protected
  void sse_encode_chain_data_source_config(
      ChainDataSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ChainDataSourceConfig_Esplora(
          serverUrl: final serverUrl,
          syncConfig: final syncConfig
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_String(serverUrl, serializer);
        sse_encode_opt_box_autoadd_esplora_sync_config(syncConfig, serializer);
      case ChainDataSourceConfig_BitcoindRpc(
          rpcHost: final rpcHost,
          rpcPort: final rpcPort,
          rpcUser: final rpcUser,
          rpcPassword: final rpcPassword
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(rpcHost, serializer);
        sse_encode_u_16(rpcPort, serializer);
        sse_encode_String(rpcUser, serializer);
        sse_encode_String(rpcPassword, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_channel_config(ChannelConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.forwardingFeeProportionalMillionths, serializer);
    sse_encode_u_32(self.forwardingFeeBaseMsat, serializer);
    sse_encode_u_16(self.cltvExpiryDelta, serializer);
    sse_encode_max_dust_htlc_exposure(self.maxDustHtlcExposure, serializer);
    sse_encode_u_64(self.forceCloseAvoidanceMaxFeeSatoshis, serializer);
    sse_encode_bool(self.acceptUnderpayingHtlcs, serializer);
  }

  @protected
  void sse_encode_channel_details(
      ChannelDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_channel_id(self.channelId, serializer);
    sse_encode_public_key(self.counterpartyNodeId, serializer);
    sse_encode_opt_box_autoadd_out_point(self.fundingTxo, serializer);
    sse_encode_u_64(self.channelValueSats, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.unspendablePunishmentReserve, serializer);
    sse_encode_user_channel_id(self.userChannelId, serializer);
    sse_encode_u_32(self.feerateSatPer1000Weight, serializer);
    sse_encode_u_64(self.outboundCapacityMsat, serializer);
    sse_encode_u_64(self.inboundCapacityMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(self.confirmationsRequired, serializer);
    sse_encode_opt_box_autoadd_u_32(self.confirmations, serializer);
    sse_encode_bool(self.isOutbound, serializer);
    sse_encode_bool(self.isChannelReady, serializer);
    sse_encode_bool(self.isUsable, serializer);
    sse_encode_opt_box_autoadd_u_16(self.cltvExpiryDelta, serializer);
    sse_encode_u_64(self.counterpartyUnspendablePunishmentReserve, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.counterpartyOutboundHtlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.counterpartyOutboundHtlcMaximumMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(
        self.counterpartyForwardingInfoFeeBaseMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(
        self.counterpartyForwardingInfoFeeProportionalMillionths, serializer);
    sse_encode_opt_box_autoadd_u_16(
        self.counterpartyForwardingInfoCltvExpiryDelta, serializer);
    sse_encode_u_64(self.nextOutboundHtlcLimitMsat, serializer);
    sse_encode_u_64(self.nextOutboundHtlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_16(self.forceCloseSpendDelay, serializer);
    sse_encode_u_64(self.inboundHtlcMinimumMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(self.inboundHtlcMaximumMsat, serializer);
    sse_encode_channel_config(self.config, serializer);
  }

  @protected
  void sse_encode_channel_id(ChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_channel_info(ChannelInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_node_id(self.nodeOne, serializer);
    sse_encode_opt_box_autoadd_channel_update_info(self.oneToTwo, serializer);
    sse_encode_node_id(self.nodeTwo, serializer);
    sse_encode_opt_box_autoadd_channel_update_info(self.twoToOne, serializer);
    sse_encode_opt_box_autoadd_u_64(self.capacitySats, serializer);
  }

  @protected
  void sse_encode_channel_update_info(
      ChannelUpdateInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.lastUpdate, serializer);
    sse_encode_bool(self.enabled, serializer);
    sse_encode_u_16(self.cltvExpiryDelta, serializer);
    sse_encode_u_64(self.htlcMinimumMsat, serializer);
    sse_encode_u_64(self.htlcMaximumMsat, serializer);
    sse_encode_routing_fees(self.fees, serializer);
  }

  @protected
  void sse_encode_closure_reason(ClosureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ClosureReason_PeerFeerateTooLow(
          peerFeerateSatPerKw: final peerFeerateSatPerKw,
          requiredFeerateSatPerKw: final requiredFeerateSatPerKw
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_u_32(peerFeerateSatPerKw, serializer);
        sse_encode_u_32(requiredFeerateSatPerKw, serializer);
      case ClosureReason_CounterpartyForceClosed(peerMsg: final peerMsg):
        sse_encode_i_32(1, serializer);
        sse_encode_String(peerMsg, serializer);
      case ClosureReason_HolderForceClosed(
          broadcastedLatestTxn: final broadcastedLatestTxn
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_opt_box_autoadd_bool(broadcastedLatestTxn, serializer);
      case ClosureReason_LegacyCooperativeClosure():
        sse_encode_i_32(3, serializer);
      case ClosureReason_CounterpartyInitiatedCooperativeClosure():
        sse_encode_i_32(4, serializer);
      case ClosureReason_LocallyInitiatedCooperativeClosure():
        sse_encode_i_32(5, serializer);
      case ClosureReason_CommitmentTxConfirmed():
        sse_encode_i_32(6, serializer);
      case ClosureReason_FundingTimedOut():
        sse_encode_i_32(7, serializer);
      case ClosureReason_ProcessingError(err: final err):
        sse_encode_i_32(8, serializer);
        sse_encode_String(err, serializer);
      case ClosureReason_DisconnectedPeer():
        sse_encode_i_32(9, serializer);
      case ClosureReason_OutdatedChannelManager():
        sse_encode_i_32(10, serializer);
      case ClosureReason_CounterpartyCoopClosedUnfundedChannel():
        sse_encode_i_32(11, serializer);
      case ClosureReason_FundingBatchClosure():
        sse_encode_i_32(12, serializer);
      case ClosureReason_HTLCsTimedOut():
        sse_encode_i_32(13, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_config(Config self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.storageDirPath, serializer);
    sse_encode_opt_String(self.logDirPath, serializer);
    sse_encode_network(self.network, serializer);
    sse_encode_opt_list_socket_address(self.listeningAddresses, serializer);
    sse_encode_opt_box_autoadd_node_alias(self.nodeAlias, serializer);
    sse_encode_list_public_key(self.trustedPeers0Conf, serializer);
    sse_encode_u_64(self.probingLiquidityLimitMultiplier, serializer);
    sse_encode_log_level(self.logLevel, serializer);
    sse_encode_opt_box_autoadd_anchor_channels_config(
        self.anchorChannelsConfig, serializer);
    sse_encode_opt_box_autoadd_sending_parameters(
        self.sendingParameters, serializer);
  }

  @protected
  void sse_encode_decode_error(DecodeError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case DecodeError_UnknownVersion():
        sse_encode_i_32(0, serializer);
      case DecodeError_UnknownRequiredFeature():
        sse_encode_i_32(1, serializer);
      case DecodeError_InvalidValue():
        sse_encode_i_32(2, serializer);
      case DecodeError_ShortRead():
        sse_encode_i_32(3, serializer);
      case DecodeError_BadLengthDescriptor():
        sse_encode_i_32(4, serializer);
      case DecodeError_Io(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_String(field0, serializer);
      case DecodeError_UnsupportedCompression():
        sse_encode_i_32(6, serializer);
      case DecodeError_DangerousValue():
        sse_encode_i_32(7, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_entropy_source_config(
      EntropySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case EntropySourceConfig_SeedFile(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case EntropySourceConfig_SeedBytes(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_8_array_64(field0, serializer);
      case EntropySourceConfig_Bip39Mnemonic(
          mnemonic: final mnemonic,
          passphrase: final passphrase
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_ffi_mnemonic(mnemonic, serializer);
        sse_encode_opt_String(passphrase, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_esplora_sync_config(
      EsploraSyncConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.onchainWalletSyncIntervalSecs, serializer);
    sse_encode_u_64(self.lightningWalletSyncIntervalSecs, serializer);
    sse_encode_u_64(self.feeRateCacheUpdateIntervalSecs, serializer);
  }

  @protected
  void sse_encode_event(Event self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Event_PaymentClaimable(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          claimableAmountMsat: final claimableAmountMsat,
          claimDeadline: final claimDeadline
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_u_64(claimableAmountMsat, serializer);
        sse_encode_opt_box_autoadd_u_32(claimDeadline, serializer);
      case Event_PaymentSuccessful(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          feePaidMsat: final feePaidMsat
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_opt_box_autoadd_u_64(feePaidMsat, serializer);
      case Event_PaymentFailed(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          reason: final reason
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_opt_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_opt_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_opt_box_autoadd_payment_failure_reason(reason, serializer);
      case Event_PaymentReceived(
          paymentId: final paymentId,
          paymentHash: final paymentHash,
          amountMsat: final amountMsat
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_opt_box_autoadd_payment_id(paymentId, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_u_64(amountMsat, serializer);
      case Event_ChannelPending(
          channelId: final channelId,
          userChannelId: final userChannelId,
          formerTemporaryChannelId: final formerTemporaryChannelId,
          counterpartyNodeId: final counterpartyNodeId,
          fundingTxo: final fundingTxo
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_box_autoadd_channel_id(formerTemporaryChannelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_box_autoadd_out_point(fundingTxo, serializer);
      case Event_ChannelReady(
          channelId: final channelId,
          userChannelId: final userChannelId,
          counterpartyNodeId: final counterpartyNodeId
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_opt_box_autoadd_public_key(counterpartyNodeId, serializer);
      case Event_ChannelClosed(
          channelId: final channelId,
          userChannelId: final userChannelId,
          counterpartyNodeId: final counterpartyNodeId,
          reason: final reason
        ):
        sse_encode_i_32(6, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_user_channel_id(userChannelId, serializer);
        sse_encode_opt_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_opt_box_autoadd_closure_reason(reason, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_ffi_bolt_11_payment(
      FfiBolt11Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentBolt11Payment(self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_bolt_12_payment(
      FfiBolt12Payment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentBolt12Payment(self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_builder_error(
      FfiBuilderError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_ffi_mnemonic(FfiMnemonic self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.seedPhrase, serializer);
  }

  @protected
  void sse_encode_ffi_network_graph(
      FfiNetworkGraph self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodegraphNetworkGraph(self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_node(FfiNode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodeNode(self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_node_error(FfiNodeError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case FfiNodeError_InvalidTxid():
        sse_encode_i_32(0, serializer);
      case FfiNodeError_AlreadyRunning():
        sse_encode_i_32(1, serializer);
      case FfiNodeError_NotRunning():
        sse_encode_i_32(2, serializer);
      case FfiNodeError_OnchainTxCreationFailed():
        sse_encode_i_32(3, serializer);
      case FfiNodeError_ConnectionFailed():
        sse_encode_i_32(4, serializer);
      case FfiNodeError_InvoiceCreationFailed():
        sse_encode_i_32(5, serializer);
      case FfiNodeError_PaymentSendingFailed():
        sse_encode_i_32(6, serializer);
      case FfiNodeError_ProbeSendingFailed():
        sse_encode_i_32(7, serializer);
      case FfiNodeError_ChannelCreationFailed():
        sse_encode_i_32(8, serializer);
      case FfiNodeError_ChannelClosingFailed():
        sse_encode_i_32(9, serializer);
      case FfiNodeError_ChannelConfigUpdateFailed():
        sse_encode_i_32(10, serializer);
      case FfiNodeError_PersistenceFailed():
        sse_encode_i_32(11, serializer);
      case FfiNodeError_WalletOperationFailed():
        sse_encode_i_32(12, serializer);
      case FfiNodeError_OnchainTxSigningFailed():
        sse_encode_i_32(13, serializer);
      case FfiNodeError_MessageSigningFailed():
        sse_encode_i_32(14, serializer);
      case FfiNodeError_TxSyncFailed():
        sse_encode_i_32(15, serializer);
      case FfiNodeError_GossipUpdateFailed():
        sse_encode_i_32(16, serializer);
      case FfiNodeError_InvalidAddress():
        sse_encode_i_32(17, serializer);
      case FfiNodeError_InvalidSocketAddress():
        sse_encode_i_32(18, serializer);
      case FfiNodeError_InvalidPublicKey():
        sse_encode_i_32(19, serializer);
      case FfiNodeError_InvalidSecretKey():
        sse_encode_i_32(20, serializer);
      case FfiNodeError_InvalidPaymentHash():
        sse_encode_i_32(21, serializer);
      case FfiNodeError_InvalidPaymentPreimage():
        sse_encode_i_32(22, serializer);
      case FfiNodeError_InvalidPaymentSecret():
        sse_encode_i_32(23, serializer);
      case FfiNodeError_InvalidAmount():
        sse_encode_i_32(24, serializer);
      case FfiNodeError_InvalidInvoice():
        sse_encode_i_32(25, serializer);
      case FfiNodeError_InvalidChannelId():
        sse_encode_i_32(26, serializer);
      case FfiNodeError_InvalidNetwork():
        sse_encode_i_32(27, serializer);
      case FfiNodeError_DuplicatePayment():
        sse_encode_i_32(28, serializer);
      case FfiNodeError_InsufficientFunds():
        sse_encode_i_32(29, serializer);
      case FfiNodeError_FeerateEstimationUpdateFailed():
        sse_encode_i_32(30, serializer);
      case FfiNodeError_LiquidityRequestFailed():
        sse_encode_i_32(31, serializer);
      case FfiNodeError_LiquiditySourceUnavailable():
        sse_encode_i_32(32, serializer);
      case FfiNodeError_LiquidityFeeTooHigh():
        sse_encode_i_32(33, serializer);
      case FfiNodeError_InvalidPaymentId():
        sse_encode_i_32(34, serializer);
      case FfiNodeError_Decode(field0: final field0):
        sse_encode_i_32(35, serializer);
        sse_encode_box_autoadd_decode_error(field0, serializer);
      case FfiNodeError_Bolt12Parse(field0: final field0):
        sse_encode_i_32(36, serializer);
        sse_encode_box_autoadd_bolt_12_parse_error(field0, serializer);
      case FfiNodeError_InvoiceRequestCreationFailed():
        sse_encode_i_32(37, serializer);
      case FfiNodeError_OfferCreationFailed():
        sse_encode_i_32(38, serializer);
      case FfiNodeError_RefundCreationFailed():
        sse_encode_i_32(39, serializer);
      case FfiNodeError_FeerateEstimationUpdateTimeout():
        sse_encode_i_32(40, serializer);
      case FfiNodeError_WalletOperationTimeout():
        sse_encode_i_32(41, serializer);
      case FfiNodeError_TxSyncTimeout():
        sse_encode_i_32(42, serializer);
      case FfiNodeError_GossipUpdateTimeout():
        sse_encode_i_32(43, serializer);
      case FfiNodeError_InvalidOfferId():
        sse_encode_i_32(44, serializer);
      case FfiNodeError_InvalidNodeId():
        sse_encode_i_32(45, serializer);
      case FfiNodeError_InvalidOffer():
        sse_encode_i_32(46, serializer);
      case FfiNodeError_InvalidRefund():
        sse_encode_i_32(47, serializer);
      case FfiNodeError_UnsupportedCurrency():
        sse_encode_i_32(48, serializer);
      case FfiNodeError_UriParameterParsingFailed():
        sse_encode_i_32(49, serializer);
      case FfiNodeError_InvalidUri():
        sse_encode_i_32(50, serializer);
      case FfiNodeError_InvalidQuantity():
        sse_encode_i_32(51, serializer);
      case FfiNodeError_InvalidNodeAlias():
        sse_encode_i_32(52, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_ffi_on_chain_payment(
      FfiOnChainPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentOnchainPayment(
        self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_spontaneous_payment(
      FfiSpontaneousPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentSpontaneousPayment(
        self.opaque, serializer);
  }

  @protected
  void sse_encode_ffi_unified_qr_payment(
      FfiUnifiedQrPayment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_RustOpaque_ldk_nodepaymentUnifiedQrPayment(
        self.opaque, serializer);
  }

  @protected
  void sse_encode_gossip_source_config(
      GossipSourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case GossipSourceConfig_P2PNetwork():
        sse_encode_i_32(0, serializer);
      case GossipSourceConfig_RapidGossipSync(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_lightning_balance(
      LightningBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case LightningBalance_ClaimableOnChannelClose(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          transactionFeeSatoshis: final transactionFeeSatoshis,
          outboundPaymentHtlcRoundedMsat: final outboundPaymentHtlcRoundedMsat,
          outboundForwardedHtlcRoundedMsat:
              final outboundForwardedHtlcRoundedMsat,
          inboundClaimingHtlcRoundedMsat: final inboundClaimingHtlcRoundedMsat,
          inboundHtlcRoundedMsat: final inboundHtlcRoundedMsat
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_64(transactionFeeSatoshis, serializer);
        sse_encode_u_64(outboundPaymentHtlcRoundedMsat, serializer);
        sse_encode_u_64(outboundForwardedHtlcRoundedMsat, serializer);
        sse_encode_u_64(inboundClaimingHtlcRoundedMsat, serializer);
        sse_encode_u_64(inboundHtlcRoundedMsat, serializer);
      case LightningBalance_ClaimableAwaitingConfirmations(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          confirmationHeight: final confirmationHeight,
          source: final source
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(confirmationHeight, serializer);
        sse_encode_balance_source(source, serializer);
      case LightningBalance_ContentiousClaimable(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          timeoutHeight: final timeoutHeight,
          paymentHash: final paymentHash,
          paymentPreimage: final paymentPreimage
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(timeoutHeight, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_box_autoadd_payment_preimage(paymentPreimage, serializer);
      case LightningBalance_MaybeTimeoutClaimableHTLC(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          claimableHeight: final claimableHeight,
          paymentHash: final paymentHash,
          outboundPayment: final outboundPayment
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(claimableHeight, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
        sse_encode_bool(outboundPayment, serializer);
      case LightningBalance_MaybePreimageClaimableHTLC(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis,
          expiryHeight: final expiryHeight,
          paymentHash: final paymentHash
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
        sse_encode_u_32(expiryHeight, serializer);
        sse_encode_box_autoadd_payment_hash(paymentHash, serializer);
      case LightningBalance_CounterpartyRevokedOutputClaimable(
          channelId: final channelId,
          counterpartyNodeId: final counterpartyNodeId,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_public_key(counterpartyNodeId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_liquidity_source_config(
      LiquiditySourceConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_record_socket_address_public_key_opt_string(
        self.lsps2Service, serializer);
  }

  @protected
  void sse_encode_list_channel_details(
      List<ChannelDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_channel_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_lightning_balance(
      List<LightningBalance> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_lightning_balance(item, serializer);
    }
  }

  @protected
  void sse_encode_list_node_id(List<NodeId> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_node_id(item, serializer);
    }
  }

  @protected
  void sse_encode_list_payment_details(
      List<PaymentDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_payment_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_peer_details(
      List<PeerDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_peer_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_pending_sweep_balance(
      List<PendingSweepBalance> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_pending_sweep_balance(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_64_strict(
      Uint64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_public_key(
      List<PublicKey> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_public_key(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_socket_address(
      List<SocketAddress> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_socket_address(item, serializer);
    }
  }

  @protected
  void sse_encode_log_level(LogLevel self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_lsp_fee_limits(LSPFeeLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_u_64(self.maxTotalOpeningFeeMsat, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.maxProportionalOpeningFeePpmMsat, serializer);
  }

  @protected
  void sse_encode_max_dust_htlc_exposure(
      MaxDustHTLCExposure self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case MaxDustHTLCExposure_FixedLimitMsat(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_u_64(field0, serializer);
      case MaxDustHTLCExposure_FeeRateMultiplier(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(field0, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_max_total_routing_fee_limit(
      MaxTotalRoutingFeeLimit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case MaxTotalRoutingFeeLimit_NoFeeCap():
        sse_encode_i_32(0, serializer);
      case MaxTotalRoutingFeeLimit_FeeCap(amountMsat: final amountMsat):
        sse_encode_i_32(1, serializer);
        sse_encode_u_64(amountMsat, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_network(Network self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_node_alias(NodeAlias self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.field0, serializer);
  }

  @protected
  void sse_encode_node_announcement_info(
      NodeAnnouncementInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.lastUpdate, serializer);
    sse_encode_String(self.alias, serializer);
    sse_encode_list_socket_address(self.addresses, serializer);
  }

  @protected
  void sse_encode_node_id(NodeId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.compressed, serializer);
  }

  @protected
  void sse_encode_node_info(NodeInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_64_strict(self.channels, serializer);
    sse_encode_opt_box_autoadd_node_announcement_info(
        self.announcementInfo, serializer);
  }

  @protected
  void sse_encode_node_status(NodeStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.isRunning, serializer);
    sse_encode_bool(self.isListening, serializer);
    sse_encode_best_block(self.currentBestBlock, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestLightningWalletSyncTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestOnchainWalletSyncTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestFeeRateCacheUpdateTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestRgsSnapshotTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_64(
        self.latestNodeAnnouncementBroadcastTimestamp, serializer);
    sse_encode_opt_box_autoadd_u_32(
        self.latestChannelMonitorArchivalHeight, serializer);
  }

  @protected
  void sse_encode_offer(Offer self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_offer_id(OfferId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.field0, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_anchor_channels_config(
      AnchorChannelsConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_anchor_channels_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_chain_data_source_config(
      ChainDataSourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_chain_data_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_config(
      ChannelConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_id(
      ChannelId? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_id(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_info(
      ChannelInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_channel_update_info(
      ChannelUpdateInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_channel_update_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_closure_reason(
      ClosureReason? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_closure_reason(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_entropy_source_config(
      EntropySourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_entropy_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_esplora_sync_config(
      EsploraSyncConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_esplora_sync_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_event(Event? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_event(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_gossip_source_config(
      GossipSourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_gossip_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_liquidity_source_config(
      LiquiditySourceConfig? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_liquidity_source_config(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_max_total_routing_fee_limit(
      MaxTotalRoutingFeeLimit? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_max_total_routing_fee_limit(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_node_alias(
      NodeAlias? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_node_alias(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_node_announcement_info(
      NodeAnnouncementInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_node_announcement_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_node_info(
      NodeInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_node_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_out_point(
      OutPoint? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_out_point(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_details(
      PaymentDetails? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_details(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_failure_reason(
      PaymentFailureReason? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_failure_reason(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_hash(
      PaymentHash? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_hash(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_id(
      PaymentId? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_id(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_preimage(
      PaymentPreimage? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_preimage(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_payment_secret(
      PaymentSecret? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_payment_secret(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_public_key(
      PublicKey? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_public_key(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_sending_parameters(
      SendingParameters? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_sending_parameters(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_16(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_16(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_8(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_8(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_socket_address(
      List<SocketAddress>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_socket_address(self, serializer);
    }
  }

  @protected
  void sse_encode_out_point(OutPoint self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_txid(self.txid, serializer);
    sse_encode_u_32(self.vout, serializer);
  }

  @protected
  void sse_encode_payment_details(
      PaymentDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_payment_id(self.id, serializer);
    sse_encode_payment_kind(self.kind, serializer);
    sse_encode_opt_box_autoadd_u_64(self.amountMsat, serializer);
    sse_encode_payment_direction(self.direction, serializer);
    sse_encode_payment_status(self.status, serializer);
    sse_encode_u_64(self.latestUpdateTimestamp, serializer);
  }

  @protected
  void sse_encode_payment_direction(
      PaymentDirection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_failure_reason(
      PaymentFailureReason self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_payment_hash(PaymentHash self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_id(PaymentId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.field0, serializer);
  }

  @protected
  void sse_encode_payment_kind(PaymentKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PaymentKind_Onchain():
        sse_encode_i_32(0, serializer);
      case PaymentKind_Bolt11(
          hash: final hash,
          preimage: final preimage,
          secret: final secret
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
        sse_encode_opt_box_autoadd_payment_secret(secret, serializer);
      case PaymentKind_Bolt11Jit(
          hash: final hash,
          preimage: final preimage,
          secret: final secret,
          lspFeeLimits: final lspFeeLimits
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
        sse_encode_opt_box_autoadd_payment_secret(secret, serializer);
        sse_encode_box_autoadd_lsp_fee_limits(lspFeeLimits, serializer);
      case PaymentKind_Spontaneous(hash: final hash, preimage: final preimage):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
      case PaymentKind_Bolt12Offer(
          hash: final hash,
          preimage: final preimage,
          secret: final secret,
          offerId: final offerId,
          payerNote: final payerNote,
          quantity: final quantity
        ):
        sse_encode_i_32(4, serializer);
        sse_encode_opt_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
        sse_encode_opt_box_autoadd_payment_secret(secret, serializer);
        sse_encode_box_autoadd_offer_id(offerId, serializer);
        sse_encode_opt_String(payerNote, serializer);
        sse_encode_opt_box_autoadd_u_64(quantity, serializer);
      case PaymentKind_Bolt12Refund(
          hash: final hash,
          preimage: final preimage,
          secret: final secret,
          payerNote: final payerNote,
          quantity: final quantity
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_opt_box_autoadd_payment_hash(hash, serializer);
        sse_encode_opt_box_autoadd_payment_preimage(preimage, serializer);
        sse_encode_opt_box_autoadd_payment_secret(secret, serializer);
        sse_encode_opt_String(payerNote, serializer);
        sse_encode_opt_box_autoadd_u_64(quantity, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_payment_preimage(
      PaymentPreimage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_secret(PaymentSecret self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_8_array_32(self.data, serializer);
  }

  @protected
  void sse_encode_payment_status(PaymentStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_peer_details(PeerDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_public_key(self.nodeId, serializer);
    sse_encode_socket_address(self.address, serializer);
    sse_encode_bool(self.isConnected, serializer);
  }

  @protected
  void sse_encode_pending_sweep_balance(
      PendingSweepBalance self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PendingSweepBalance_PendingBroadcast(
          channelId: final channelId,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_opt_box_autoadd_channel_id(channelId, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      case PendingSweepBalance_BroadcastAwaitingConfirmation(
          channelId: final channelId,
          latestBroadcastHeight: final latestBroadcastHeight,
          latestSpendingTxid: final latestSpendingTxid,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_box_autoadd_channel_id(channelId, serializer);
        sse_encode_u_32(latestBroadcastHeight, serializer);
        sse_encode_box_autoadd_txid(latestSpendingTxid, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      case PendingSweepBalance_AwaitingThresholdConfirmations(
          channelId: final channelId,
          latestSpendingTxid: final latestSpendingTxid,
          confirmationHash: final confirmationHash,
          confirmationHeight: final confirmationHeight,
          amountSatoshis: final amountSatoshis
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_opt_box_autoadd_channel_id(channelId, serializer);
        sse_encode_box_autoadd_txid(latestSpendingTxid, serializer);
        sse_encode_String(confirmationHash, serializer);
        sse_encode_u_32(confirmationHeight, serializer);
        sse_encode_u_64(amountSatoshis, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_public_key(PublicKey self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.hex, serializer);
  }

  @protected
  void sse_encode_qr_payment_result(
      QrPaymentResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case QrPaymentResult_Onchain(txid: final txid):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_txid(txid, serializer);
      case QrPaymentResult_Bolt11(paymentId: final paymentId):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_payment_id(paymentId, serializer);
      case QrPaymentResult_Bolt12(paymentId: final paymentId):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_payment_id(paymentId, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_record_socket_address_public_key_opt_string(
      (SocketAddress, PublicKey, String?) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_socket_address(self.$1, serializer);
    sse_encode_public_key(self.$2, serializer);
    sse_encode_opt_String(self.$3, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_refund(Refund self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.s, serializer);
  }

  @protected
  void sse_encode_routing_fees(RoutingFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.baseMsat, serializer);
    sse_encode_u_32(self.proportionalMillionths, serializer);
  }

  @protected
  void sse_encode_sending_parameters(
      SendingParameters self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_max_total_routing_fee_limit(
        self.maxTotalRoutingFeeMsat, serializer);
    sse_encode_opt_box_autoadd_u_32(self.maxTotalCltvExpiryDelta, serializer);
    sse_encode_opt_box_autoadd_u_8(self.maxPathCount, serializer);
    sse_encode_opt_box_autoadd_u_8(
        self.maxChannelSaturationPowerOfHalf, serializer);
  }

  @protected
  void sse_encode_socket_address(SocketAddress self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SocketAddress_TcpIpV4(addr: final addr, port: final port):
        sse_encode_i_32(0, serializer);
        sse_encode_u_8_array_4(addr, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_TcpIpV6(addr: final addr, port: final port):
        sse_encode_i_32(1, serializer);
        sse_encode_u_8_array_16(addr, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_OnionV2(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_u_8_array_12(field0, serializer);
      case SocketAddress_OnionV3(
          ed25519Pubkey: final ed25519Pubkey,
          checksum: final checksum,
          version: final version,
          port: final port
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_u_8_array_32(ed25519Pubkey, serializer);
        sse_encode_u_16(checksum, serializer);
        sse_encode_u_8(version, serializer);
        sse_encode_u_16(port, serializer);
      case SocketAddress_Hostname(addr: final addr, port: final port):
        sse_encode_i_32(4, serializer);
        sse_encode_String(addr, serializer);
        sse_encode_u_16(port, serializer);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_encode_txid(Txid self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.hash, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_u_8_array_12(U8Array12 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_16(U8Array16 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_32(U8Array32 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_4(U8Array4 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_u_8_array_64(U8Array64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user_channel_id(
      UserChannelId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.data, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class Bolt11PaymentImpl extends RustOpaque implements Bolt11Payment {
  // Not to be used by end users
  Bolt11PaymentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  Bolt11PaymentImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Bolt11Payment,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Bolt11Payment,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_Bolt11PaymentPtr,
  );
}

@sealed
class Bolt12PaymentImpl extends RustOpaque implements Bolt12Payment {
  // Not to be used by end users
  Bolt12PaymentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  Bolt12PaymentImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Bolt12Payment,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Bolt12Payment,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_Bolt12PaymentPtr,
  );
}

@sealed
class BuilderImpl extends RustOpaque implements Builder {
  // Not to be used by end users
  BuilderImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BuilderImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Builder,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Builder,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_BuilderPtr,
  );
}

@sealed
class FfiBuilderImpl extends RustOpaque implements FfiBuilder {
  // Not to be used by end users
  FfiBuilderImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  FfiBuilderImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_FfiBuilder,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_FfiBuilder,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_FfiBuilderPtr,
  );

  Builder get opaque =>
      core.instance.api.crateApiBuilderFfiBuilderAutoAccessorGetOpaque(
        that: this,
      );

  set opaque(Builder opaque) =>
      core.instance.api.crateApiBuilderFfiBuilderAutoAccessorSetOpaque(
          that: this, opaque: opaque);

  Future<FfiNode> build() => core.instance.api.crateApiBuilderFfiBuilderBuild(
        that: this,
      );

  Future<FfiNode> buildWithFsStore() =>
      core.instance.api.crateApiBuilderFfiBuilderBuildWithFsStore(
        that: this,
      );

  Future<FfiNode> buildWithVssStore(
          {required String vssUrl,
          required String storeId,
          required String lnurlAuthServerUrl,
          required Map<String, String> fixedHeaders}) =>
      core.instance.api.crateApiBuilderFfiBuilderBuildWithVssStore(
          that: this,
          vssUrl: vssUrl,
          storeId: storeId,
          lnurlAuthServerUrl: lnurlAuthServerUrl,
          fixedHeaders: fixedHeaders);

  Future<FfiNode> buildWithVssStoreAndFixedHeaders(
          {required String vssUrl,
          required String storeId,
          required Map<String, String> fixedHeaders}) =>
      core.instance.api
          .crateApiBuilderFfiBuilderBuildWithVssStoreAndFixedHeaders(
              that: this,
              vssUrl: vssUrl,
              storeId: storeId,
              fixedHeaders: fixedHeaders);
}

@sealed
class NetworkGraphImpl extends RustOpaque implements NetworkGraph {
  // Not to be used by end users
  NetworkGraphImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  NetworkGraphImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_NetworkGraph,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_NetworkGraph,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_NetworkGraphPtr,
  );
}

@sealed
class NodeImpl extends RustOpaque implements Node {
  // Not to be used by end users
  NodeImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  NodeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_Node,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_Node,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_NodePtr,
  );
}

@sealed
class OnchainPaymentImpl extends RustOpaque implements OnchainPayment {
  // Not to be used by end users
  OnchainPaymentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  OnchainPaymentImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_OnchainPayment,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_OnchainPayment,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_OnchainPaymentPtr,
  );
}

@sealed
class SpontaneousPaymentImpl extends RustOpaque implements SpontaneousPayment {
  // Not to be used by end users
  SpontaneousPaymentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SpontaneousPaymentImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_SpontaneousPayment,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_SpontaneousPayment,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_SpontaneousPaymentPtr,
  );
}

@sealed
class UnifiedQrPaymentImpl extends RustOpaque implements UnifiedQrPayment {
  // Not to be used by end users
  UnifiedQrPaymentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  UnifiedQrPaymentImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        core.instance.api.rust_arc_increment_strong_count_UnifiedQrPayment,
    rustArcDecrementStrongCount:
        core.instance.api.rust_arc_decrement_strong_count_UnifiedQrPayment,
    rustArcDecrementStrongCountPtr:
        core.instance.api.rust_arc_decrement_strong_count_UnifiedQrPaymentPtr,
  );
}
