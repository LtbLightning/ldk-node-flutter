// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'shared.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`, `try_from`

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>
abstract class AddressData implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>
abstract class BitcoinAddress implements RustOpaqueInterface {
  BitcoinAddressInner get inner;

  set inner(BitcoinAddressInner inner);

  /// Parse a script as an address for the given network
  static Future<BitcoinAddress> fromScript(
          {required ScriptBuf script, required Network network}) =>
      core.instance.api
          .sharedBitcoinAddressFromScript(script: script, network: network);

  /// Is the address valid for the provided network
  Future<bool> isValidForNetwork({required Network network});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Parse a string as an address for the given network.
  static Future<BitcoinAddress> newInstance(
          {required String address, required Network network}) =>
      core.instance.api
          .sharedBitcoinAddressNew(address: address, network: network);

  /// Return the `scriptPubKey` underlying an address.
  Future<ScriptBuf> scriptPubkey();

  /// Return the data for the address.
  Future<AddressData> toAddressData();

  /// Return a BIP-21 URI string for this address.
  Future<String> toQrUri();
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>
abstract class BitcoinAddressInner implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>
abstract class TaprootSpendInfo implements RustOpaqueInterface {
  TaprootSpendInfoInner get inner;

  set inner(TaprootSpendInfoInner inner);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
abstract class Transaction implements RustOpaqueInterface {
  BitcoinTransactionInner get inner;

  set inner(BitcoinTransactionInner inner);

  /// Computes the Txid.
  /// Hashes the transaction excluding the segwit data (i.e. the marker, flag bytes, and the witness fields themselves).
  Future<Txid> computeTxid();

  /// Compute the Wtxid, which includes the witness in the transaction hash.
  Future<WTxid> computeWtxid();

  /// List of transaction inputs.
  Future<List<TxIn>> input();

  /// Checks if this is a coinbase transaction.
  /// The first transaction in the block distributes the mining reward and is called the coinbase transaction.
  /// It is impossible to check if the transaction is first in the block, so this function checks the structure
  /// of the transaction instead - the previous output must be all-zeros (creates satoshis “out of thin air”).
  Future<bool> isCoinbase();

  /// Returns `true` if the transaction itself opted in to be BIP-125-replaceable (RBF).
  ///
  /// # Warning
  ///
  /// **Incorrectly relying on RBF may lead to monetary loss!**
  ///
  /// This **does not** cover the case where a transaction becomes replaceable due to ancestors
  /// being RBF. Please note that transactions **may be replaced** even if they **do not** include
  /// the RBF signal: <https://bitcoinops.org/en/newsletters/2022/10/19/#transaction-replacement-option>.
  Future<bool> isExplicitlyRbf();

  /// Returns `true` if this transactions nLockTime is enabled ([BIP-65]).
  ///
  /// [BIP-65]: https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki
  Future<bool> isLockTimeEnabled();

  /// Block height or timestamp. Transaction cannot be included in a block until this height/time.
  ///
  /// /// ### Relevant BIPs
  ///
  /// * [BIP-65 OP_CHECKLOCKTIMEVERIFY](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki)
  /// * [BIP-113 Median time-past as endpoint for lock-time calculations](https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki)
  Future<int> lockTime();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new `Transaction` instance from serialized transaction bytes.
  static Future<Transaction> newInstance(
          {required List<int> transactionBytes}) =>
      core.instance.api
          .sharedTransactionNew(transactionBytes: transactionBytes);

  /// List of transaction outputs.
  Future<List<TxOut>> output();

  /// Returns the total transaction size
  ///
  /// Total transaction size is the transaction size in bytes serialized as described in BIP144,
  /// including base data and witness data.
  Future<BigInt> totalSize();

  /// The protocol version, is currently expected to be 1 or 2 (BIP 68).
  Future<int> version();

  /// Returns the "virtual size" (vsize) of this transaction.
  ///
  /// Will be `ceil(weight / 4.0)`. Note this implements the virtual size as per [`BIP141`], which
  /// is different to what is implemented in Bitcoin Core.
  /// > Virtual transaction size is defined as Transaction weight / 4 (rounded up to the next integer).
  ///
  /// [`BIP141`]: https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki
  Future<BigInt> vsize();

  /// Returns the weight of this transaction, as defined by BIP-141.
  ///
  /// > Transaction weight is defined as Base transaction size * 3 + Total transaction size (ie.
  /// > the same method as calculating Block weight from Base size and Total size).
  ///
  /// For transactions with an empty witness, this is simply the consensus-serialized size times
  /// four. For transactions with a witness, this is the non-witness consensus-serialized size
  /// multiplied by three plus the with-witness consensus-serialized size.
  ///
  /// For transactions with no inputs, this function will return a value 2 less than the actual
  /// weight of the serialized transaction. The reason is that zero-input transactions, post-segwit,
  /// cannot be unambiguously serialized; we make a choice that adds two extra bytes. For more
  /// details see [BIP 141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki)
  /// which uses a "input count" of `0x00` as a `marker` for a Segwit-encoded transaction.
  ///
  /// If you need to use 0-input transactions, we strongly recommend you do so using the PSBT
  /// API. The unsigned transaction encoded within PSBT is always a non-segwit transaction
  /// and can therefore avoid this ambiguity.
  Future<BigInt> weight();
}

class Bolt11Invoice {
  final String signedRawInvoice;

  const Bolt11Invoice({
    required this.signedRawInvoice,
  });

  @override
  int get hashCode => signedRawInvoice.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt11Invoice &&
          runtimeType == other.runtimeType &&
          signedRawInvoice == other.signedRawInvoice;
}

class Bolt12Invoice {
  final Uint8List data;

  const Bolt12Invoice({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Bolt12Invoice &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

class Mnemonic {
  final List<String> words;

  const Mnemonic({
    required this.words,
  });

  Future<String> asString() => core.instance.api.sharedMnemonicAsString(
        that: this,
      );

  static Future<Mnemonic> fromEntropy({required List<int> entropy}) =>
      core.instance.api.sharedMnemonicFromEntropy(entropy: entropy);

  static Future<Mnemonic> fromSeedPhrase({required String seedPhrase}) =>
      core.instance.api.sharedMnemonicFromSeedPhrase(seedPhrase: seedPhrase);

  static Future<Mnemonic> generate() =>
      core.instance.api.sharedMnemonicGenerate();

  Future<U8Array64> toSeed({required String passphrase}) => core.instance.api
      .sharedMnemonicToSeed(that: this, passphrase: passphrase);

  @override
  int get hashCode => words.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Mnemonic &&
          runtimeType == other.runtimeType &&
          words == other.words;
}

enum Network {
  bitcoin,
  testnet,
  testnet4,
  signet,
  regtest,
  ;
}

class Offer {
  final String s;

  const Offer({
    required this.s,
  });

  @override
  int get hashCode => s.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Offer && runtimeType == other.runtimeType && s == other.s;
}

class OutPoint {
  final Txid txid;
  final int vout;

  const OutPoint({
    required this.txid,
    required this.vout,
  });

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OutPoint &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout;
}

class PaymentHash {
  final U8Array32 data;

  const PaymentHash({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentHash &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

class PaymentId {
  final Uint8List data;

  const PaymentId({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentId &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

class PaymentPreimage {
  final U8Array32 data;

  const PaymentPreimage({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentPreimage &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

class Psbt {
  final String inner;

  const Psbt({
    required this.inner,
  });

  Future<Transaction> extractTx() => core.instance.api.sharedPsbtExtractTx(
        that: this,
      );

  /// Calculates transaction fee.
  ///
  /// 'Fee' being the amount that will be paid for mining a transaction with the current inputs
  /// and outputs i.e., the difference in value of the total inputs and the total outputs.
  ///
  /// #### Errors
  ///
  /// - `MissingUtxo` when UTXO information for any input is not present or is invalid.
  /// - `NegativeFee` if calculated value is negative.
  /// - `FeeOverflow` if an integer overflow occurs.
  Future<BigInt> fee() => core.instance.api.sharedPsbtFee(
        that: this,
      );

  static Future<Psbt> fromBase64({required String base64}) =>
      core.instance.api.sharedPsbtFromBase64(base64: base64);

  @override
  int get hashCode => inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Psbt && runtimeType == other.runtimeType && inner == other.inner;
}

class PublicKey {
  final String hex;

  const PublicKey({
    required this.hex,
  });

  @override
  int get hashCode => hex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PublicKey &&
          runtimeType == other.runtimeType &&
          hex == other.hex;
}

class Refund {
  final String s;

  const Refund({
    required this.s,
  });

  @override
  int get hashCode => s.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Refund && runtimeType == other.runtimeType && s == other.s;
}

class ScriptBuf {
  final Uint8List inner;

  const ScriptBuf({
    required this.inner,
  });

  @override
  int get hashCode => inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScriptBuf &&
          runtimeType == other.runtimeType &&
          inner == other.inner;
}

class SendingParameters {
  final BigInt? maxTotalRoutingFeeMsat;
  final int? maxTotalCltvExpiryDelta;
  final int? maxPathCount;
  final int? maxChannelSaturationPowerOfHalf;

  const SendingParameters({
    this.maxTotalRoutingFeeMsat,
    this.maxTotalCltvExpiryDelta,
    this.maxPathCount,
    this.maxChannelSaturationPowerOfHalf,
  });

  @override
  int get hashCode =>
      maxTotalRoutingFeeMsat.hashCode ^
      maxTotalCltvExpiryDelta.hashCode ^
      maxPathCount.hashCode ^
      maxChannelSaturationPowerOfHalf.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SendingParameters &&
          runtimeType == other.runtimeType &&
          maxTotalRoutingFeeMsat == other.maxTotalRoutingFeeMsat &&
          maxTotalCltvExpiryDelta == other.maxTotalCltvExpiryDelta &&
          maxPathCount == other.maxPathCount &&
          maxChannelSaturationPowerOfHalf ==
              other.maxChannelSaturationPowerOfHalf;
}

@freezed
sealed class SocketAddress with _$SocketAddress {
  const SocketAddress._();

  const factory SocketAddress.tcpIpV4({
    required U8Array4 addr,
    required int port,
  }) = SocketAddress_TcpIpV4;
  const factory SocketAddress.tcpIpV6({
    required U8Array16 addr,
    required int port,
  }) = SocketAddress_TcpIpV6;
  const factory SocketAddress.onionV2(
    U8Array12 field0,
  ) = SocketAddress_OnionV2;
  const factory SocketAddress.onionV3({
    required U8Array32 ed25519Pubkey,
    required int checksum,
    required int version,
    required int port,
  }) = SocketAddress_OnionV3;
  const factory SocketAddress.hostname({
    required String addr,
    required int port,
  }) = SocketAddress_Hostname;
}

class TxIn {
  /// The reference to the previous output that is being used as an input.
  final OutPoint previousOutput;

  /// The script which pushes values on the stack which will cause
  /// the referenced output's script to be accepted.
  final ScriptBuf scriptSig;

  /// The sequence number, which suggests to miners which of two
  /// conflicting transactions should be preferred, or 0xFFFFFFFF
  /// to ignore this feature. This is generally never used since
  /// the miner behavior cannot be enforced.
  final int sequence;

  /// A proof for the script that authorizes the spend of the output.
  final List<Uint8List> witness;

  const TxIn({
    required this.previousOutput,
    required this.scriptSig,
    required this.sequence,
    required this.witness,
  });

  @override
  int get hashCode =>
      previousOutput.hashCode ^
      scriptSig.hashCode ^
      sequence.hashCode ^
      witness.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxIn &&
          runtimeType == other.runtimeType &&
          previousOutput == other.previousOutput &&
          scriptSig == other.scriptSig &&
          sequence == other.sequence &&
          witness == other.witness;
}

/// Bitcoin transaction output.
///
/// Defines new coins to be created as a result of the transaction,
/// along with spending conditions ("script", aka "output script"),
/// which an input spending it must satisfy.
///
/// An output that is not yet spent by an input is called Unspent Transaction Output ("UTXO").
class TxOut {
  /// The value of the output, in satoshis.
  final BigInt value;

  /// The script which must be satisfied for the output to be spent.
  final ScriptBuf scriptPubkey;

  const TxOut({
    required this.value,
    required this.scriptPubkey,
  });

  @override
  int get hashCode => value.hashCode ^ scriptPubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxOut &&
          runtimeType == other.runtimeType &&
          value == other.value &&
          scriptPubkey == other.scriptPubkey;
}

class Txid {
  final String hash;

  const Txid({
    required this.hash,
  });

  @override
  int get hashCode => hash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Txid && runtimeType == other.runtimeType && hash == other.hash;
}

class WTxid {
  final String hash;

  const WTxid({
    required this.hash,
  });

  @override
  int get hashCode => hash.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WTxid && runtimeType == other.runtimeType && hash == other.hash;
}

/// The version and program of a Segwit address.
class WitnessProgram {
  /// Version. For example 1 for Taproot.
  final int version;

  /// The witness program.
  final Uint8List program;

  const WitnessProgram({
    required this.version,
    required this.program,
  });

  @override
  int get hashCode => version.hashCode ^ program.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WitnessProgram &&
          runtimeType == other.runtimeType &&
          version == other.version &&
          program == other.program;
}
