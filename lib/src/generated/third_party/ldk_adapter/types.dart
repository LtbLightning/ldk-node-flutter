// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import '../shared.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BackgroundSyncConfig`, `BalanceSource`, `ClosureReason`, `ConfirmationStatus`, `ElectrumSyncConfig`, `EsploraSyncConfig`, `LSPFeeLimits`, `MaxTotalRoutingFeeLimit`, `OfferId`, `PaymentFailureReason`, `PaymentSecret`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `try_from`, `try_from`, `try_from`

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>>
abstract class ChainDataSourceConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
abstract class ChannelConfig implements RustOpaqueInterface {
  bool get acceptUnderpayingHtlcs;

  int get cltvExpiryDelta;

  BigInt get forceCloseAvoidanceMaxFeeSatoshis;

  int get forwardingFeeBaseMsat;

  int get forwardingFeeProportionalMillionths;

  MaxDustHtlcExposure get maxDustHtlcExposure;

  set acceptUnderpayingHtlcs(bool acceptUnderpayingHtlcs);

  set cltvExpiryDelta(int cltvExpiryDelta);

  set forceCloseAvoidanceMaxFeeSatoshis(
      BigInt forceCloseAvoidanceMaxFeeSatoshis);

  set forwardingFeeBaseMsat(int forwardingFeeBaseMsat);

  set forwardingFeeProportionalMillionths(
      int forwardingFeeProportionalMillionths);

  set maxDustHtlcExposure(MaxDustHtlcExposure maxDustHtlcExposure);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
abstract class ChannelDetails implements RustOpaqueInterface {
  ChannelId get channelId;

  BigInt get channelValueSats;

  int? get cltvExpiryDelta;

  ChannelConfig get config;

  int? get confirmations;

  int? get confirmationsRequired;

  int? get counterpartyForwardingInfoCltvExpiryDelta;

  int? get counterpartyForwardingInfoFeeBaseMsat;

  int? get counterpartyForwardingInfoFeeProportionalMillionths;

  PublicKey get counterpartyNodeId;

  BigInt? get counterpartyOutboundHtlcMaximumMsat;

  BigInt? get counterpartyOutboundHtlcMinimumMsat;

  BigInt get counterpartyUnspendablePunishmentReserve;

  int get feerateSatPer1000Weight;

  int? get forceCloseSpendDelay;

  OutPoint? get fundingTxo;

  BigInt get inboundCapacityMsat;

  BigInt? get inboundHtlcMaximumMsat;

  BigInt get inboundHtlcMinimumMsat;

  bool get isChannelReady;

  bool get isOutbound;

  bool get isUsable;

  BigInt get nextOutboundHtlcLimitMsat;

  BigInt get nextOutboundHtlcMinimumMsat;

  BigInt get outboundCapacityMsat;

  BigInt? get unspendablePunishmentReserve;

  UserChannelId get userChannelId;

  set channelId(ChannelId channelId);

  set channelValueSats(BigInt channelValueSats);

  set cltvExpiryDelta(int? cltvExpiryDelta);

  set config(ChannelConfig config);

  set confirmations(int? confirmations);

  set confirmationsRequired(int? confirmationsRequired);

  set counterpartyForwardingInfoCltvExpiryDelta(
      int? counterpartyForwardingInfoCltvExpiryDelta);

  set counterpartyForwardingInfoFeeBaseMsat(
      int? counterpartyForwardingInfoFeeBaseMsat);

  set counterpartyForwardingInfoFeeProportionalMillionths(
      int? counterpartyForwardingInfoFeeProportionalMillionths);

  set counterpartyNodeId(PublicKey counterpartyNodeId);

  set counterpartyOutboundHtlcMaximumMsat(
      BigInt? counterpartyOutboundHtlcMaximumMsat);

  set counterpartyOutboundHtlcMinimumMsat(
      BigInt? counterpartyOutboundHtlcMinimumMsat);

  set counterpartyUnspendablePunishmentReserve(
      BigInt counterpartyUnspendablePunishmentReserve);

  set feerateSatPer1000Weight(int feerateSatPer1000Weight);

  set forceCloseSpendDelay(int? forceCloseSpendDelay);

  set fundingTxo(OutPoint? fundingTxo);

  set inboundCapacityMsat(BigInt inboundCapacityMsat);

  set inboundHtlcMaximumMsat(BigInt? inboundHtlcMaximumMsat);

  set inboundHtlcMinimumMsat(BigInt inboundHtlcMinimumMsat);

  set isChannelReady(bool isChannelReady);

  set isOutbound(bool isOutbound);

  set isUsable(bool isUsable);

  set nextOutboundHtlcLimitMsat(BigInt nextOutboundHtlcLimitMsat);

  set nextOutboundHtlcMinimumMsat(BigInt nextOutboundHtlcMinimumMsat);

  set outboundCapacityMsat(BigInt outboundCapacityMsat);

  set unspendablePunishmentReserve(BigInt? unspendablePunishmentReserve);

  set userChannelId(UserChannelId userChannelId);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>>
abstract class EntropySourceConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>
abstract class Event implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>>
abstract class GossipSourceConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>
abstract class LightningBalance implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>
abstract class MaxDustHtlcExposure implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>
abstract class PaymentDetails implements RustOpaqueInterface {
  BigInt? get amountMsat;

  PaymentDirection get direction;

  PaymentId get id;

  PaymentKind get kind;

  BigInt get latestUpdateTimestamp;

  PaymentStatus get status;

  set amountMsat(BigInt? amountMsat);

  set direction(PaymentDirection direction);

  set id(PaymentId id);

  set kind(PaymentKind kind);

  set latestUpdateTimestamp(BigInt latestUpdateTimestamp);

  set status(PaymentStatus status);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>
abstract class PaymentKind implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
abstract class PeerDetails implements RustOpaqueInterface {
  SocketAddress get address;

  bool get isConnected;

  PublicKey get nodeId;

  set address(SocketAddress address);

  set isConnected(bool isConnected);

  set nodeId(PublicKey nodeId);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>
abstract class PendingSweepBalance implements RustOpaqueInterface {}

abstract class FfiLogWriter {
  /// Handle a log record.
  Future<void> log({required FfiLogRecord record});
}

/// Configuration options pertaining to 'Anchor' channels, i.e., channels for which the
/// `optionAnchorsZeroFeeHtlcTx` channel type is negotiated.
///
/// Prior to the introduction of Anchor channels, the on-chain fees paying for the transactions
/// issued on channel closure were pre-determined and locked-in at the time of the channel
/// opening. This required to estimate what fee rate would be sufficient to still have the
/// closing transactions be spendable on-chain (i.e., not be considered dust). This legacy
/// design of pre-anchor channels proved inadequate in the unpredictable, often turbulent, fee
/// markets we experience today.
///
/// In contrast, Anchor channels allow to determine an adequate fee rate *at the time of channel
/// closure*, making them much more robust in the face of fee spikes. In turn, they require to
/// maintain a reserve of on-chain funds to have the channel closure transactions confirmed
/// on-chain, at least if the channel counterparty can't be trusted to do this for us.
///
/// See [BOLT 3] for more technical details on Anchor channels.
///
///
/// ### Defaults
///
/// | Parameter                  | Value  |
/// |----------------------------|--------|
/// | `trustedPeersNoReserve` | []     |
/// | `perChannelReserveSats` | 25000  |
///
///
/// [BOLT 3]: https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions
class AnchorChannelsConfig {
  /// A list of peers that we trust to get the required channel closing transactions confirmed
  /// on-chain.
  ///
  /// Channels with these peers won't count towards the retained on-chain reserve and we won't
  /// take any action to get the required transactions confirmed ourselves.
  ///
  /// **Note:** Trusting the channel counterparty to take the necessary actions to get the
  /// required Anchor spending and HTLC transactions confirmed on-chain is potentially insecure
  /// as the channel may not be closed if they refuse to do so, potentially leaving the user
  /// funds stuck *or* even allow the counterparty to steal any in-flight funds after the
  /// corresponding HTLCs time out.
  final List<PublicKey> trustedPeersNoReserve;

  /// The amount of satoshis per anchors-negotiated channel with an untrusted peer that we keep
  /// as an emergency reserve in our on-chain wallet.
  ///
  /// This allows for having the required Anchor output spending and HTLC transactions confirmed
  /// when the channel is closed.
  ///
  /// If the channel peer is not marked as trusted via trustedPeersNoReserve,
  /// we will always try to spend the Anchor
  /// outputs with *any* on-chain funds available, i.e., the total reserve value as well as any
  /// spendable funds available in the on-chain wallet. Therefore, this per-channel multiplier is
  /// really an emergency reserve that we maintain at all time to reduce reduce the risk of
  /// insufficient funds at time of a channel closure. To this end, we will refuse to open
  /// outbound or accept inbound channels if we don't have sufficient on-chain funds available to
  /// cover the additional reserve requirement.
  ///
  /// **Note:** Depending on the fee market at the time of closure, this reserve amount might or
  /// might not suffice to successfully spend the Anchor output and have the HTLC transactions
  /// confirmed on-chain, i.e., you may want to adjust this value accordingly.
  final BigInt perChannelReserveSats;

  const AnchorChannelsConfig({
    required this.trustedPeersNoReserve,
    required this.perChannelReserveSats,
  });

  static Future<AnchorChannelsConfig> default_() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigDefault();

  @override
  int get hashCode =>
      trustedPeersNoReserve.hashCode ^ perChannelReserveSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AnchorChannelsConfig &&
          runtimeType == other.runtimeType &&
          trustedPeersNoReserve == other.trustedPeersNoReserve &&
          perChannelReserveSats == other.perChannelReserveSats;
}

/// Details of the known available balances returned by `node.listBalances`.
///
class BalanceDetails {
  /// The total balance of our on-chain wallet.
  final BigInt totalOnchainBalanceSats;

  /// The currently spendable balance of our on-chain wallet.
  final BigInt spendableOnchainBalanceSats;

  /// The total balance that we would be able to claim across all our Lightning channels.
  ///
  /// Note this excludes balances that we are unsure if we are able to claim (e.g., as we are
  final BigInt totalLightningBalanceSats;

  /// A detailed list of all known Lightning balances that would be claimable on channel closure.
  ///
  /// Note that less than the listed amounts are spendable over lightning as further reserve
  /// restrictions apply.
  final List<LightningBalance> lightningBalances;

  /// A detailed list of balances currently being swept from the Lightning to the on-chain
  /// wallet.
  ///
  /// These are balances resulting from channel closures that may have been encumbered by a
  /// delay, but are now being claimed and useable once sufficiently confirmed on-chain.
  ///
  /// Note that, depending on the sync status of the wallets, swept balances listed here might or
  /// might not already be accounted for in `totalOnchainBalanceSats`.
  final List<PendingSweepBalance> pendingBalancesFromChannelClosures;

  const BalanceDetails({
    required this.totalOnchainBalanceSats,
    required this.spendableOnchainBalanceSats,
    required this.totalLightningBalanceSats,
    required this.lightningBalances,
    required this.pendingBalancesFromChannelClosures,
  });

  @override
  int get hashCode =>
      totalOnchainBalanceSats.hashCode ^
      spendableOnchainBalanceSats.hashCode ^
      totalLightningBalanceSats.hashCode ^
      lightningBalances.hashCode ^
      pendingBalancesFromChannelClosures.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BalanceDetails &&
          runtimeType == other.runtimeType &&
          totalOnchainBalanceSats == other.totalOnchainBalanceSats &&
          spendableOnchainBalanceSats == other.spendableOnchainBalanceSats &&
          totalLightningBalanceSats == other.totalLightningBalanceSats &&
          lightningBalances == other.lightningBalances &&
          pendingBalancesFromChannelClosures ==
              other.pendingBalancesFromChannelClosures;
}

/// The best known block as identified by its hash and height.
class BestBlock {
  /// The block's hash
  final String blockHash;

  /// The height at which the block was confirmed.
  final int height;

  const BestBlock({
    required this.blockHash,
    required this.height,
  });

  @override
  int get hashCode => blockHash.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BestBlock &&
          runtimeType == other.runtimeType &&
          blockHash == other.blockHash &&
          height == other.height;
}

/// The global identifier of a channel.
///
/// Note that this will start out to be a temporary ID until channel funding negotiation is
/// finalized, at which point it will change to be a permanent global ID tied to the on-chain
/// funding transaction.
///
class ChannelId {
  final U8Array32 data;

  const ChannelId({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelId &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// Represents the configuration of an [Node] instance.
///
class Config {
  final String storageDirPath;

  /// The used Bitcoin network.
  final Network network;

  /// The IP address and TCP port the node will listen on.
  ///
  final List<SocketAddress>? listeningAddresses;

  /// The addresses which the node will announce to the gossip network that it accepts connections on.
  final List<SocketAddress>? announcementAddresses;

  /// The node alias that will be used when broadcasting announcements to the gossip network.
  ///
  /// The provided alias must be a valid UTF-8 string and no longer than 32 bytes in total.
  ///
  /// **Note**: We will only allow opening and accepting public channels if the `nodeAlias` and the
  /// `listeningAddresses` are set.
  final NodeAlias? nodeAlias;

  ///A list of peers that we allow to establish zero confirmation channels to us.
  ///
  ///Note: Allowing payments via zero-confirmation channels is potentially insecure if the funding transaction ends up never being confirmed on-chain. Zero-confirmation channels should therefore only be accepted from trusted peers.
  final List<PublicKey> trustedPeers0Conf;
  final BigInt probingLiquidityLimitMultiplier;

  ///The level at which we log messages.
  /// Any messages below this level will be excluded from the logs.
  ///
  final AnchorChannelsConfig? anchorChannelsConfig;

  /// Configuration options for payment routing and pathfinding.
  ///
  /// Setting the `SendingParameters` provides flexibility to customize how payments are routed,
  /// including setting limits on routing fees, CLTV expiry, and channel utilization.
  ///
  /// **Note:** If unset, default parameters will be used, and you will be able to override the
  /// parameters on a per-payment basis in the corresponding method calls.
  final SendingParameters? sendingParameters;

  const Config({
    required this.storageDirPath,
    required this.network,
    this.listeningAddresses,
    this.announcementAddresses,
    this.nodeAlias,
    required this.trustedPeers0Conf,
    required this.probingLiquidityLimitMultiplier,
    this.anchorChannelsConfig,
    this.sendingParameters,
  });

  static Future<Config> default_() =>
      core.instance.api.ldkAdapterTypesConfigDefault();

  @override
  int get hashCode =>
      storageDirPath.hashCode ^
      network.hashCode ^
      listeningAddresses.hashCode ^
      announcementAddresses.hashCode ^
      nodeAlias.hashCode ^
      trustedPeers0Conf.hashCode ^
      probingLiquidityLimitMultiplier.hashCode ^
      anchorChannelsConfig.hashCode ^
      sendingParameters.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          storageDirPath == other.storageDirPath &&
          network == other.network &&
          listeningAddresses == other.listeningAddresses &&
          announcementAddresses == other.announcementAddresses &&
          nodeAlias == other.nodeAlias &&
          trustedPeers0Conf == other.trustedPeers0Conf &&
          probingLiquidityLimitMultiplier ==
              other.probingLiquidityLimitMultiplier &&
          anchorChannelsConfig == other.anchorChannelsConfig &&
          sendingParameters == other.sendingParameters;
}

/// A Custom TLV entry.
class CustomTlvRecord {
  /// Type number.
  final BigInt typeNum;

  /// Serialized value.
  final Uint8List value;

  const CustomTlvRecord({
    required this.typeNum,
    required this.value,
  });

  @override
  int get hashCode => typeNum.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CustomTlvRecord &&
          runtimeType == other.runtimeType &&
          typeNum == other.typeNum &&
          value == other.value;
}

/// A unit of logging output with metadata to enable filtering by module path and line number.
class FfiLogRecord {
  /// The verbosity level of the message.
  final LogLevel level;

  /// The message body.
  final String args;

  /// The module path of the message.
  final String modulePath;

  /// The line containing the message.
  final int line;

  const FfiLogRecord({
    required this.level,
    required this.args,
    required this.modulePath,
    required this.line,
  });

  @override
  int get hashCode =>
      level.hashCode ^ args.hashCode ^ modulePath.hashCode ^ line.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiLogRecord &&
          runtimeType == other.runtimeType &&
          level == other.level &&
          args == other.args &&
          modulePath == other.modulePath &&
          line == other.line;
}

class LiquiditySourceConfig {
  final (SocketAddress, PublicKey, String?) lsps2Service;

  const LiquiditySourceConfig({
    required this.lsps2Service,
  });

  @override
  int get hashCode => lsps2Service.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LiquiditySourceConfig &&
          runtimeType == other.runtimeType &&
          lsps2Service == other.lsps2Service;
}

/// An enum representing the available verbosity levels of the logger.
///
enum LogLevel {
  /// Designates extremely verbose information, including gossip-induced messages
  ///
  gossip,

  /// Designates very low priority, often extremely verbose, information
  ///
  trace,

  /// Designates lower priority information
  ///
  debug,

  /// Designates useful information
  ///
  info,

  /// Designates hazardous situations
  ///
  warn,

  /// Designates very serious errors
  ///
  error,
  ;
}

/// A user-defined name for a node, which may be used when displaying the node in a graph.
///
/// Since node aliases are provided by third parties, they are a potential avenue for injection
/// attacks. Care must be taken when processing.
class NodeAlias {
  final U8Array32 field0;

  const NodeAlias({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeAlias &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Represents the status of the [`Node`].
class NodeStatus {
  /// Indicates whether the `Node` is running.
  final bool isRunning;

  /// Indicates whether the `Node` is listening for incoming connections on the addresses
  final bool isListening;

  /// The best block to which our Lightning wallet is currently synced.
  final BestBlock currentBestBlock;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully synced
  /// our Lightning wallet to the chain tip.
  ///
  /// Will be `None` if the wallet hasn't been synced yet.
  final BigInt? latestLightningWalletSyncTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully synced
  /// our on-chain wallet to the chain tip.
  ///
  /// Will be `None` if the wallet hasn't been synced yet.
  final BigInt? latestOnchainWalletSyncTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully update
  /// our fee rate cache.
  ///
  /// Will be `None` if the cache hasn't been updated yet.
  final BigInt? latestFeeRateCacheUpdateTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when the last rapid gossip sync
  /// (RGS) snapshot we successfully applied was generated.
  ///
  /// Will be `None` if RGS isn't configured or the snapshot hasn't been updated yet.
  final BigInt? latestRgsSnapshotTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last broadcasted a node
  /// announcement.
  ///
  /// Will be `None` if we have no public channels or we haven't broadcasted yet.
  final BigInt? latestNodeAnnouncementBroadcastTimestamp;

  /// The block height when we last archived closed channel monitor data.
  ///
  /// Will be `None` if we haven't archived any monitors of closed channels yet.
  final int? latestChannelMonitorArchivalHeight;

  const NodeStatus({
    required this.isRunning,
    required this.isListening,
    required this.currentBestBlock,
    this.latestLightningWalletSyncTimestamp,
    this.latestOnchainWalletSyncTimestamp,
    this.latestFeeRateCacheUpdateTimestamp,
    this.latestRgsSnapshotTimestamp,
    this.latestNodeAnnouncementBroadcastTimestamp,
    this.latestChannelMonitorArchivalHeight,
  });

  @override
  int get hashCode =>
      isRunning.hashCode ^
      isListening.hashCode ^
      currentBestBlock.hashCode ^
      latestLightningWalletSyncTimestamp.hashCode ^
      latestOnchainWalletSyncTimestamp.hashCode ^
      latestFeeRateCacheUpdateTimestamp.hashCode ^
      latestRgsSnapshotTimestamp.hashCode ^
      latestNodeAnnouncementBroadcastTimestamp.hashCode ^
      latestChannelMonitorArchivalHeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeStatus &&
          runtimeType == other.runtimeType &&
          isRunning == other.isRunning &&
          isListening == other.isListening &&
          currentBestBlock == other.currentBestBlock &&
          latestLightningWalletSyncTimestamp ==
              other.latestLightningWalletSyncTimestamp &&
          latestOnchainWalletSyncTimestamp ==
              other.latestOnchainWalletSyncTimestamp &&
          latestFeeRateCacheUpdateTimestamp ==
              other.latestFeeRateCacheUpdateTimestamp &&
          latestRgsSnapshotTimestamp == other.latestRgsSnapshotTimestamp &&
          latestNodeAnnouncementBroadcastTimestamp ==
              other.latestNodeAnnouncementBroadcastTimestamp &&
          latestChannelMonitorArchivalHeight ==
              other.latestChannelMonitorArchivalHeight;
}

/// Represents the direction of a payment.
///
enum PaymentDirection {
  /// The payment is inbound.
  inbound,

  /// The payment is outbound.
  outbound,
  ;
}

/// Represents the current status of a payment.
///
enum PaymentStatus {
  /// The payment is still pending.
  pending,

  /// The payment suceeded.
  succeeded,

  /// The payment failed.
  failed,
  ;
}

///A local, potentially user-provided, identifier of a channel.
///
/// By default, this will be randomly generated for the user to ensure local uniqueness.
///
class UserChannelId {
  final Uint8List data;

  const UserChannelId({
    required this.data,
  });

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserChannelId &&
          runtimeType == other.runtimeType &&
          data == other.data;
}
