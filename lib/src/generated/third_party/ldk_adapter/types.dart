// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../api/extensions.dart';
import '../../frb_generated.dart';
import '../../lib.dart';
import '../shared.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BalanceSource`, `ClosureReason`, `ConfirmationStatus`, `MaxTotalRoutingFeeLimit`, `PaymentFailureReason`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `try_from`, `try_from`, `try_from`

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
abstract class ChannelConfig implements RustOpaqueInterface {
  bool get acceptUnderpayingHtlcs;

  int get cltvExpiryDelta;

  BigInt get forceCloseAvoidanceMaxFeeSatoshis;

  int get forwardingFeeBaseMsat;

  int get forwardingFeeProportionalMillionths;

  MaxDustHtlcExposure get maxDustHtlcExposure;

  set acceptUnderpayingHtlcs(bool acceptUnderpayingHtlcs);

  set cltvExpiryDelta(int cltvExpiryDelta);

  set forceCloseAvoidanceMaxFeeSatoshis(
      BigInt forceCloseAvoidanceMaxFeeSatoshis);

  set forwardingFeeBaseMsat(int forwardingFeeBaseMsat);

  set forwardingFeeProportionalMillionths(
      int forwardingFeeProportionalMillionths);

  set maxDustHtlcExposure(MaxDustHtlcExposure maxDustHtlcExposure);

  /// Gets the total forwarding fee for a given amount in millisatoshis.
  Future<BigInt> calculateForwardingFee({required BigInt amountMsat});

  /// Creates a high-fee routing configuration.
  static Future<ChannelConfig> highFeeRouting() =>
      core.instance.api.ldkAdapterTypesChannelConfigHighFeeRouting();

  /// Creates a low-fee routing configuration.
  static Future<ChannelConfig> lowFeeRouting() =>
      core.instance.api.ldkAdapterTypesChannelConfigLowFeeRouting();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new ChannelConfig with default values.
  /// Creates a new ChannelConfig with all arguments specified.
  static Future<ChannelConfig> newInstance(
          {required int forwardingFeeProportionalMillionths,
          required int forwardingFeeBaseMsat,
          required int cltvExpiryDelta,
          required MaxDustHtlcExposure maxDustHtlcExposure,
          required BigInt forceCloseAvoidanceMaxFeeSatoshis,
          required bool acceptUnderpayingHtlcs}) =>
      core.instance.api.ldkAdapterTypesChannelConfigNew(
          forwardingFeeProportionalMillionths:
              forwardingFeeProportionalMillionths,
          forwardingFeeBaseMsat: forwardingFeeBaseMsat,
          cltvExpiryDelta: cltvExpiryDelta,
          maxDustHtlcExposure: maxDustHtlcExposure,
          forceCloseAvoidanceMaxFeeSatoshis: forceCloseAvoidanceMaxFeeSatoshis,
          acceptUnderpayingHtlcs: acceptUnderpayingHtlcs);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
abstract class ChannelDetails implements RustOpaqueInterface {
  ChannelId get channelId;

  BigInt get channelValueSats;

  int? get cltvExpiryDelta;

  ChannelConfig get config;

  int? get confirmations;

  int? get confirmationsRequired;

  int? get counterpartyForwardingInfoCltvExpiryDelta;

  int? get counterpartyForwardingInfoFeeBaseMsat;

  int? get counterpartyForwardingInfoFeeProportionalMillionths;

  PublicKey get counterpartyNodeId;

  BigInt? get counterpartyOutboundHtlcMaximumMsat;

  BigInt? get counterpartyOutboundHtlcMinimumMsat;

  BigInt get counterpartyUnspendablePunishmentReserve;

  int get feerateSatPer1000Weight;

  int? get forceCloseSpendDelay;

  OutPoint? get fundingTxo;

  BigInt get inboundCapacityMsat;

  BigInt? get inboundHtlcMaximumMsat;

  BigInt get inboundHtlcMinimumMsat;

  bool get isChannelReady;

  bool get isOutbound;

  bool get isUsable;

  BigInt get nextOutboundHtlcLimitMsat;

  BigInt get nextOutboundHtlcMinimumMsat;

  BigInt get outboundCapacityMsat;

  BigInt? get unspendablePunishmentReserve;

  UserChannelId get userChannelId;

  set channelId(ChannelId channelId);

  set channelValueSats(BigInt channelValueSats);

  set cltvExpiryDelta(int? cltvExpiryDelta);

  set config(ChannelConfig config);

  set confirmations(int? confirmations);

  set confirmationsRequired(int? confirmationsRequired);

  set counterpartyForwardingInfoCltvExpiryDelta(
      int? counterpartyForwardingInfoCltvExpiryDelta);

  set counterpartyForwardingInfoFeeBaseMsat(
      int? counterpartyForwardingInfoFeeBaseMsat);

  set counterpartyForwardingInfoFeeProportionalMillionths(
      int? counterpartyForwardingInfoFeeProportionalMillionths);

  set counterpartyNodeId(PublicKey counterpartyNodeId);

  set counterpartyOutboundHtlcMaximumMsat(
      BigInt? counterpartyOutboundHtlcMaximumMsat);

  set counterpartyOutboundHtlcMinimumMsat(
      BigInt? counterpartyOutboundHtlcMinimumMsat);

  set counterpartyUnspendablePunishmentReserve(
      BigInt counterpartyUnspendablePunishmentReserve);

  set feerateSatPer1000Weight(int feerateSatPer1000Weight);

  set forceCloseSpendDelay(int? forceCloseSpendDelay);

  set fundingTxo(OutPoint? fundingTxo);

  set inboundCapacityMsat(BigInt inboundCapacityMsat);

  set inboundHtlcMaximumMsat(BigInt? inboundHtlcMaximumMsat);

  set inboundHtlcMinimumMsat(BigInt inboundHtlcMinimumMsat);

  set isChannelReady(bool isChannelReady);

  set isOutbound(bool isOutbound);

  set isUsable(bool isUsable);

  set nextOutboundHtlcLimitMsat(BigInt nextOutboundHtlcLimitMsat);

  set nextOutboundHtlcMinimumMsat(BigInt nextOutboundHtlcMinimumMsat);

  set outboundCapacityMsat(BigInt outboundCapacityMsat);

  set unspendablePunishmentReserve(BigInt? unspendablePunishmentReserve);

  set userChannelId(UserChannelId userChannelId);

  /// Returns the balance ratio (outbound / total) as a percentage.
  Future<double> balanceRatioPercent();

  /// Checks if the channel can receive the specified amount in millisatoshis.
  Future<bool> canReceive({required BigInt amountMsat});

  /// Checks if the channel can send the specified amount in millisatoshis.
  Future<bool> canSend({required BigInt amountMsat});

  /// Returns the total channel capacity in satoshis.
  Future<BigInt> capacitySats();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new ChannelDetails (mainly for testing purposes).
  static Future<ChannelDetails> newInstance(
          {required ChannelId channelId,
          required PublicKey counterpartyNodeId,
          OutPoint? fundingTxo,
          required BigInt channelValueSats,
          BigInt? unspendablePunishmentReserve,
          required UserChannelId userChannelId,
          required int feerateSatPer1000Weight,
          required BigInt outboundCapacityMsat,
          required BigInt inboundCapacityMsat,
          required bool isOutbound,
          required bool isChannelReady,
          required bool isUsable,
          required ChannelConfig config}) =>
      core.instance.api.ldkAdapterTypesChannelDetailsNew(
          channelId: channelId,
          counterpartyNodeId: counterpartyNodeId,
          fundingTxo: fundingTxo,
          channelValueSats: channelValueSats,
          unspendablePunishmentReserve: unspendablePunishmentReserve,
          userChannelId: userChannelId,
          feerateSatPer1000Weight: feerateSatPer1000Weight,
          outboundCapacityMsat: outboundCapacityMsat,
          inboundCapacityMsat: inboundCapacityMsat,
          isOutbound: isOutbound,
          isChannelReady: isChannelReady,
          isUsable: isUsable,
          config: config);

  /// Returns the total available liquidity (inbound + outbound) in millisatoshis.
  Future<BigInt> totalLiquidityMsat();
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>
abstract class ChannelId implements RustOpaqueInterface {
  /// Returns the channel ID as bytes.
  Future<U8Array32> asBytes();

  /// Creates a new ChannelId from a byte slice.
  /// Returns None if the slice is not exactly 32 bytes.
  static Future<ChannelId?> fromBytes({required List<int> bytes}) =>
      core.instance.api.ldkAdapterTypesChannelIdFromBytes(bytes: bytes);

  /// Creates a new ChannelId from a 32-byte array.
  ///
  /// DON'T REMOVE THE COMMENT BELOW
  /// flutter_rust_bridge:sync
  factory ChannelId({required U8Array32 data}) =>
      core.instance.api.ldkAdapterTypesChannelIdNew(data: data);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>
abstract class Event implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>
abstract class LightningBalance implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>
abstract class MaxDustHtlcExposure implements RustOpaqueInterface {
  /// Creates a conservative fixed limit (1 million msat).
  static Future<MaxDustHtlcExposure> conservative() =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureConservative();

  /// Creates a default fee rate multiplier configuration.
  static Future<MaxDustHtlcExposure> defaultFeeRate() =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureDefaultFeeRate();

  /// Creates a new MaxDustHTLCExposure with a fee rate multiplier.
  static Future<MaxDustHtlcExposure> newFeeRateMultiplier(
          {required BigInt multiplier}) =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureNewFeeRateMultiplier(
          multiplier: multiplier);

  /// Creates a new MaxDustHTLCExposure with a fixed limit in millisatoshis.
  static Future<MaxDustHtlcExposure> newFixedLimit(
          {required BigInt limitMsat}) =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureNewFixedLimit(
          limitMsat: limitMsat);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>
abstract class PaymentDetails implements RustOpaqueInterface {
  BigInt? get amountMsat;

  PaymentDirection get direction;

  PaymentId get id;

  PaymentKind get kind;

  BigInt get latestUpdateTimestamp;

  PaymentStatus get status;

  set amountMsat(BigInt? amountMsat);

  set direction(PaymentDirection direction);

  set id(PaymentId id);

  set kind(PaymentKind kind);

  set latestUpdateTimestamp(BigInt latestUpdateTimestamp);

  set status(PaymentStatus status);

  /// Checks if the payment failed.
  Future<bool> isFailed();

  /// Checks if the payment is pending.
  Future<bool> isPending();

  /// Checks if the payment is successful.
  Future<bool> isSucceeded();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new PaymentDetails.
  static Future<PaymentDetails> newInstance(
          {required PaymentId id,
          required PaymentKind kind,
          BigInt? amountMsat,
          required PaymentDirection direction,
          required PaymentStatus status,
          required BigInt latestUpdateTimestamp}) =>
      core.instance.api.ldkAdapterTypesPaymentDetailsNew(
          id: id,
          kind: kind,
          amountMsat: amountMsat,
          direction: direction,
          status: status,
          latestUpdateTimestamp: latestUpdateTimestamp);

  /// Creates a new pending inbound payment.
  static Future<PaymentDetails> newInboundPending(
          {required PaymentId id,
          required PaymentKind kind,
          BigInt? amountMsat}) =>
      core.instance.api.ldkAdapterTypesPaymentDetailsNewInboundPending(
          id: id, kind: kind, amountMsat: amountMsat);

  /// Creates a new pending outbound payment.
  static Future<PaymentDetails> newOutboundPending(
          {required PaymentId id,
          required PaymentKind kind,
          BigInt? amountMsat}) =>
      core.instance.api.ldkAdapterTypesPaymentDetailsNewOutboundPending(
          id: id, kind: kind, amountMsat: amountMsat);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>
abstract class PaymentKind implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
abstract class PeerDetails implements RustOpaqueInterface {
  SocketAddress get address;

  bool get isConnected;

  PublicKey get nodeId;

  set address(SocketAddress address);

  set isConnected(bool isConnected);

  set nodeId(PublicKey nodeId);

  /// Checks if the peer is currently disconnected.
  Future<bool> isOffline();

  /// Checks if the peer is currently connected.
  Future<bool> isOnline();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new PeerDetails.
  static Future<PeerDetails> newInstance(
          {required PublicKey nodeId,
          required SocketAddress address,
          required bool isConnected}) =>
      core.instance.api.ldkAdapterTypesPeerDetailsNew(
          nodeId: nodeId, address: address, isConnected: isConnected);

  /// Creates a new connected peer.
  static Future<PeerDetails> newConnected(
          {required PublicKey nodeId, required SocketAddress address}) =>
      core.instance.api.ldkAdapterTypesPeerDetailsNewConnected(
          nodeId: nodeId, address: address);

  /// Creates a new disconnected peer.
  static Future<PeerDetails> newDisconnected(
          {required PublicKey nodeId, required SocketAddress address}) =>
      core.instance.api.ldkAdapterTypesPeerDetailsNewDisconnected(
          nodeId: nodeId, address: address);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>
abstract class PendingSweepBalance implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>
abstract class UserChannelId implements RustOpaqueInterface {
  /// Returns the data as a byte slice.
  Future<void> asBytes();

  /// Returns the data as a byte slice.
  Future<Uint8List> asVec();

  /// Creates a new UserChannelId from a string.
  static Future<UserChannelId> fromString({required String s}) =>
      core.instance.api.ldkAdapterTypesUserChannelIdFromString(s: s);

  /// Creates a new UserChannelId from a u64.
  static Future<UserChannelId> fromU64({required BigInt id}) =>
      core.instance.api.ldkAdapterTypesUserChannelIdFromU64(id: id);

  /// Creates a new UserChannelId from a byte vector.
  ///
  /// DON'T REMOVE THE COMMENT BELOW
  /// flutter_rust_bridge:sync
  factory UserChannelId({required List<int> data}) =>
      core.instance.api.ldkAdapterTypesUserChannelIdNew(data: data);
}

abstract class FfiLogWriter {
  /// Handle a log record.
  Future<void> log({required FfiLogRecord record});
}

/// Configuration options pertaining to 'Anchor' channels, i.e., channels for which the
/// `optionAnchorsZeroFeeHtlcTx` channel type is negotiated.
///
/// Prior to the introduction of Anchor channels, the on-chain fees paying for the transactions
/// issued on channel closure were pre-determined and locked-in at the time of the channel
/// opening. This required to estimate what fee rate would be sufficient to still have the
/// closing transactions be spendable on-chain (i.e., not be considered dust). This legacy
/// design of pre-anchor channels proved inadequate in the unpredictable, often turbulent, fee
/// markets we experience today.
///
/// In contrast, Anchor channels allow to determine an adequate fee rate *at the time of channel
/// closure*, making them much more robust in the face of fee spikes. In turn, they require to
/// maintain a reserve of on-chain funds to have the channel closure transactions confirmed
/// on-chain, at least if the channel counterparty can't be trusted to do this for us.
///
/// See [BOLT 3] for more technical details on Anchor channels.
///
///
/// ### Defaults
///
/// | Parameter                  | Value  |
/// |----------------------------|--------|
/// | `trustedPeersNoReserve` | []     |
/// | `perChannelReserveSats` | 25000  |
///
///
/// [BOLT 3]: https://github.com/lightning/bolts/blob/master/03-transactions.md#htlc-timeout-and-htlc-success-transactions
/// flutter_rust_bridge:unignore
class AnchorChannelsConfig {
  /// A list of peers that we trust to get the required channel closing transactions confirmed
  /// on-chain.
  ///
  /// Channels with these peers won't count towards the retained on-chain reserve and we won't
  /// take any action to get the required transactions confirmed ourselves.
  ///
  /// **Note:** Trusting the channel counterparty to take the necessary actions to get the
  /// required Anchor spending and HTLC transactions confirmed on-chain is potentially insecure
  /// as the channel may not be closed if they refuse to do so, potentially leaving the user
  /// funds stuck *or* even allow the counterparty to steal any in-flight funds after the
  /// corresponding HTLCs time out.
  /// flutter_rust_bridge:non_final
  List<PublicKey> trustedPeersNoReserve;

  /// The amount of satoshis per anchors-negotiated channel with an untrusted peer that we keep
  /// as an emergency reserve in our on-chain wallet.
  ///
  /// This allows for having the required Anchor output spending and HTLC transactions confirmed
  /// when the channel is closed.
  ///
  /// If the channel peer is not marked as trusted via trustedPeersNoReserve,
  /// we will always try to spend the Anchor
  /// outputs with *any* on-chain funds available, i.e., the total reserve value as well as any
  /// spendable funds available in the on-chain wallet. Therefore, this per-channel multiplier is
  /// really an emergency reserve that we maintain at all time to reduce reduce the risk of
  /// insufficient funds at time of a channel closure. To this end, we will refuse to open
  /// outbound or accept inbound channels if we don't have sufficient on-chain funds available to
  /// cover the additional reserve requirement.
  ///
  /// **Note:** Depending on the fee market at the time of closure, this reserve amount might or
  /// might not suffice to successfully spend the Anchor output and have the HTLC transactions
  /// confirmed on-chain, i.e., you may want to adjust this value accordingly.
  /// flutter_rust_bridge:non_final
  BigInt perChannelReserveSats;

  AnchorChannelsConfig({
    required this.trustedPeersNoReserve,
    required this.perChannelReserveSats,
  });

  /// Creates a new AnchorChannelsConfig.
  /// Creates a conservative AnchorChannelsConfig with no trusted peers and high reserve.
  static Future<AnchorChannelsConfig> conservative() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigConservative();

  static Future<AnchorChannelsConfig> default_() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigDefault();

  /// Checks if a peer is trusted (no reserve required).
  Future<bool> isPeerTrusted({required PublicKey peer}) => core.instance.api
      .ldkAdapterTypesAnchorChannelsConfigIsPeerTrusted(that: this, peer: peer);

  /// Creates a more aggressive AnchorChannelsConfig with lower reserve.
  static Future<AnchorChannelsConfig> lowReserve() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigLowReserve();

  /// Returns the number of trusted peers.
  Future<BigInt> trustedPeersCount() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigTrustedPeersCount(
        that: this,
      );

  /// Creates an AnchorChannelsConfig that trusts specific peers with no reserve.
  static Future<AnchorChannelsConfig> withTrustedPeers(
          {required List<PublicKey> trustedPeers}) =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigWithTrustedPeers(
          trustedPeers: trustedPeers);

  @override
  int get hashCode =>
      trustedPeersNoReserve.hashCode ^ perChannelReserveSats.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AnchorChannelsConfig &&
          runtimeType == other.runtimeType &&
          trustedPeersNoReserve == other.trustedPeersNoReserve &&
          perChannelReserveSats == other.perChannelReserveSats;
}

/// Options related to background syncing the Lightning and on-chain wallets.
///
/// ### Defaults
///
/// | Parameter                              | Value              |
/// |----------------------------------------|--------------------|
/// | `onchain_wallet_sync_interval_secs`    | 80                 |
/// | `lightning_wallet_sync_interval_secs`  | 30                 |
/// | `fee_rate_cache_update_interval_secs`  | 600                |
class BackgroundSyncConfig {
  /// The time in-between background sync attempts of the onchain wallet, in seconds.
  ///
  /// **Note:** A minimum of 10 seconds is enforced when background syncing is enabled.
  final BigInt onchainWalletSyncIntervalSecs;

  /// The time in-between background sync attempts of the LDK wallet, in seconds.
  ///
  /// **Note:** A minimum of 10 seconds is enforced when background syncing is enabled.
  final BigInt lightningWalletSyncIntervalSecs;

  /// The time in-between background update attempts to our fee rate cache, in seconds.
  ///
  /// **Note:** A minimum of 10 seconds is enforced when background syncing is enabled.
  final BigInt feeRateCacheUpdateIntervalSecs;

  const BackgroundSyncConfig({
    required this.onchainWalletSyncIntervalSecs,
    required this.lightningWalletSyncIntervalSecs,
    required this.feeRateCacheUpdateIntervalSecs,
  });

  @override
  int get hashCode =>
      onchainWalletSyncIntervalSecs.hashCode ^
      lightningWalletSyncIntervalSecs.hashCode ^
      feeRateCacheUpdateIntervalSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackgroundSyncConfig &&
          runtimeType == other.runtimeType &&
          onchainWalletSyncIntervalSecs ==
              other.onchainWalletSyncIntervalSecs &&
          lightningWalletSyncIntervalSecs ==
              other.lightningWalletSyncIntervalSecs &&
          feeRateCacheUpdateIntervalSecs ==
              other.feeRateCacheUpdateIntervalSecs;
}

/// Details of the known available balances returned by `node.listBalances`.
///
class BalanceDetails {
  /// The total balance of our on-chain wallet.
  final BigInt totalOnchainBalanceSats;

  /// The currently spendable balance of our on-chain wallet.
  final BigInt spendableOnchainBalanceSats;

  /// The total balance that we would be able to claim across all our Lightning channels.
  ///
  /// Note this excludes balances that we are unsure if we are able to claim (e.g., as we are
  final BigInt totalLightningBalanceSats;

  /// A detailed list of all known Lightning balances that would be claimable on channel closure.
  ///
  /// Note that less than the listed amounts are spendable over lightning as further reserve
  /// restrictions apply.
  final List<LightningBalance> lightningBalances;

  /// A detailed list of balances currently being swept from the Lightning to the on-chain
  /// wallet.
  ///
  /// These are balances resulting from channel closures that may have been encumbered by a
  /// delay, but are now being claimed and useable once sufficiently confirmed on-chain.
  ///
  /// Note that, depending on the sync status of the wallets, swept balances listed here might or
  /// might not already be accounted for in `totalOnchainBalanceSats`.
  final List<PendingSweepBalance> pendingBalancesFromChannelClosures;

  const BalanceDetails({
    required this.totalOnchainBalanceSats,
    required this.spendableOnchainBalanceSats,
    required this.totalLightningBalanceSats,
    required this.lightningBalances,
    required this.pendingBalancesFromChannelClosures,
  });

  @override
  int get hashCode =>
      totalOnchainBalanceSats.hashCode ^
      spendableOnchainBalanceSats.hashCode ^
      totalLightningBalanceSats.hashCode ^
      lightningBalances.hashCode ^
      pendingBalancesFromChannelClosures.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BalanceDetails &&
          runtimeType == other.runtimeType &&
          totalOnchainBalanceSats == other.totalOnchainBalanceSats &&
          spendableOnchainBalanceSats == other.spendableOnchainBalanceSats &&
          totalLightningBalanceSats == other.totalLightningBalanceSats &&
          lightningBalances == other.lightningBalances &&
          pendingBalancesFromChannelClosures ==
              other.pendingBalancesFromChannelClosures;
}

/// The best known block as identified by its hash and height.
class BestBlock {
  /// The block's hash
  final String blockHash;

  /// The height at which the block was confirmed.
  final int height;

  const BestBlock({
    required this.blockHash,
    required this.height,
  });

  @override
  int get hashCode => blockHash.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BestBlock &&
          runtimeType == other.runtimeType &&
          blockHash == other.blockHash &&
          height == other.height;
}

/// A Custom TLV entry.
class CustomTlvRecord {
  /// Type number.
  final BigInt typeNum;

  /// Serialized value.
  final Uint8List value;

  const CustomTlvRecord({
    required this.typeNum,
    required this.value,
  });

  /// Creates a new CustomTlvRecord from a string value.
  static Future<CustomTlvRecord> fromString(
          {required BigInt typeNum, required String value}) =>
      core.instance.api.ldkAdapterTypesCustomTlvRecordFromString(
          typeNum: typeNum, value: value);

  /// Creates a new CustomTlvRecord from a u64 value.
  static Future<CustomTlvRecord> fromU64(
          {required BigInt typeNum, required BigInt value}) =>
      core.instance.api.ldkAdapterTypesCustomTlvRecordFromU64(
          typeNum: typeNum, value: value);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new CustomTlvRecord.
  static Future<CustomTlvRecord> newInstance(
          {required BigInt typeNum, required List<int> value}) =>
      core.instance.api
          .ldkAdapterTypesCustomTlvRecordNew(typeNum: typeNum, value: value);

  /// Returns the value as a string if it's valid UTF-8.
  Future<String?> valueAsString() =>
      core.instance.api.ldkAdapterTypesCustomTlvRecordValueAsString(
        that: this,
      );

  @override
  int get hashCode => typeNum.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CustomTlvRecord &&
          runtimeType == other.runtimeType &&
          typeNum == other.typeNum &&
          value == other.value;
}

class ElectrumSyncConfig {
  /// Background sync configuration.
  ///
  /// If set to `Null`, background syncing is disabled.
  /// you must use `sync_wallets` to manually sync the wallets.
  final BackgroundSyncConfig? backgroundSyncConfig;

  const ElectrumSyncConfig({
    this.backgroundSyncConfig,
  });

  @override
  int get hashCode => backgroundSyncConfig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ElectrumSyncConfig &&
          runtimeType == other.runtimeType &&
          backgroundSyncConfig == other.backgroundSyncConfig;
}

class EsploraSyncConfig {
  /// Background sync configuration.
  ///
  /// If set to `Null`, background syncing is disabled.
  /// you must use `sync_wallets` to manually sync the wallets.
  final BackgroundSyncConfig? backgroundSyncConfig;

  const EsploraSyncConfig({
    this.backgroundSyncConfig,
  });

  @override
  int get hashCode => backgroundSyncConfig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EsploraSyncConfig &&
          runtimeType == other.runtimeType &&
          backgroundSyncConfig == other.backgroundSyncConfig;
}

/// A unit of logging output with metadata to enable filtering by module path and line number.
class FfiLogRecord {
  /// The verbosity level of the message.
  final LogLevel level;

  /// The message body.
  final String args;

  /// The module path of the message.
  final String modulePath;

  /// The line containing the message.
  final int line;

  const FfiLogRecord({
    required this.level,
    required this.args,
    required this.modulePath,
    required this.line,
  });

  /// Creates a new debug log record.
  static Future<FfiLogRecord> debug(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordDebug(
          args: args, modulePath: modulePath, line: line);

  /// Creates a new error log record.
  static Future<FfiLogRecord> error(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordError(
          args: args, modulePath: modulePath, line: line);

  /// Returns a formatted log message.
  Future<String> formatted() =>
      core.instance.api.ldkAdapterTypesFfiLogRecordFormatted(
        that: this,
      );

  /// Creates a new info log record.
  static Future<FfiLogRecord> info(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordInfo(
          args: args, modulePath: modulePath, line: line);

  /// Checks if this is an error log.
  Future<bool> isError() =>
      core.instance.api.ldkAdapterTypesFfiLogRecordIsError(
        that: this,
      );

  /// Checks if this is a warning log.
  Future<bool> isWarn() => core.instance.api.ldkAdapterTypesFfiLogRecordIsWarn(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new FfiLogRecord.
  static Future<FfiLogRecord> newInstance(
          {required LogLevel level,
          required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordNew(
          level: level, args: args, modulePath: modulePath, line: line);

  /// Creates a new trace log record.
  static Future<FfiLogRecord> trace(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordTrace(
          args: args, modulePath: modulePath, line: line);

  /// Creates a new warning log record.
  static Future<FfiLogRecord> warn(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordWarn(
          args: args, modulePath: modulePath, line: line);

  @override
  int get hashCode =>
      level.hashCode ^ args.hashCode ^ modulePath.hashCode ^ line.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiLogRecord &&
          runtimeType == other.runtimeType &&
          level == other.level &&
          args == other.args &&
          modulePath == other.modulePath &&
          line == other.line;
}

class LiquiditySourceConfig {
  final (SocketAddress, PublicKey, String?) lsps2Service;

  const LiquiditySourceConfig({
    required this.lsps2Service,
  });

  @override
  int get hashCode => lsps2Service.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LiquiditySourceConfig &&
          runtimeType == other.runtimeType &&
          lsps2Service == other.lsps2Service;
}

/// An enum representing the available verbosity levels of the logger.
///
enum LogLevel {
  /// Designates extremely verbose information, including gossip-induced messages
  ///
  gossip,

  /// Designates very low priority, often extremely verbose, information
  ///
  trace,

  /// Designates lower priority information
  ///
  debug,

  /// Designates useful information
  ///
  info,

  /// Designates hazardous situations
  ///
  warn,

  /// Designates very serious errors
  ///
  error,
  ;
}

/// Limits applying to how much fee we allow an LSP to deduct from the payment amount.
class LSPFeeLimits {
  /// The maximal total amount we allow any configured LSP withhold from us when forwarding the
  /// payment.
  final BigInt? maxTotalOpeningFeeMsat;

  /// The maximal proportional fee, in parts-per-million millisatoshi, we allow any configured
  /// LSP withhold from us when forwarding the payment.
  final BigInt? maxProportionalOpeningFeePpmMsat;

  const LSPFeeLimits({
    this.maxTotalOpeningFeeMsat,
    this.maxProportionalOpeningFeePpmMsat,
  });

  /// Creates conservative LSP fee limits.
  static Future<LSPFeeLimits> conservative() =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsConservative();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new LSPFeeLimits.
  static Future<LSPFeeLimits> newInstance(
          {BigInt? maxTotalOpeningFeeMsat,
          BigInt? maxProportionalOpeningFeePpmMsat}) =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsNew(
          maxTotalOpeningFeeMsat: maxTotalOpeningFeeMsat,
          maxProportionalOpeningFeePpmMsat: maxProportionalOpeningFeePpmMsat);

  /// Creates permissive LSP fee limits.
  static Future<LSPFeeLimits> permissive() =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsPermissive();

  /// Creates unlimited LSP fee limits (no limits).
  static Future<LSPFeeLimits> unlimited() =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsUnlimited();

  @override
  int get hashCode =>
      maxTotalOpeningFeeMsat.hashCode ^
      maxProportionalOpeningFeePpmMsat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LSPFeeLimits &&
          runtimeType == other.runtimeType &&
          maxTotalOpeningFeeMsat == other.maxTotalOpeningFeeMsat &&
          maxProportionalOpeningFeePpmMsat ==
              other.maxProportionalOpeningFeePpmMsat;
}

/// A user-defined name for a node, which may be used when displaying the node in a graph.
///
/// Since node aliases are provided by third parties, they are a potential avenue for injection
/// attacks. Care must be taken when processing.
class NodeAlias {
  final U8Array32 field0;

  const NodeAlias({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeAlias &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Represents the status of the [`Node`].
class NodeStatus {
  /// Indicates whether the `Node` is running.
  final bool isRunning;

  /// Indicates whether the `Node` is listening for incoming connections on the addresses
  final bool isListening;

  /// The best block to which our Lightning wallet is currently synced.
  final BestBlock currentBestBlock;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully synced
  /// our Lightning wallet to the chain tip.
  ///
  /// Will be `None` if the wallet hasn't been synced yet.
  final BigInt? latestLightningWalletSyncTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully synced
  /// our on-chain wallet to the chain tip.
  ///
  /// Will be `None` if the wallet hasn't been synced yet.
  final BigInt? latestOnchainWalletSyncTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully update
  /// our fee rate cache.
  ///
  /// Will be `None` if the cache hasn't been updated yet.
  final BigInt? latestFeeRateCacheUpdateTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when the last rapid gossip sync
  /// (RGS) snapshot we successfully applied was generated.
  ///
  /// Will be `None` if RGS isn't configured or the snapshot hasn't been updated yet.
  final BigInt? latestRgsSnapshotTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last broadcasted a node
  /// announcement.
  ///
  /// Will be `None` if we have no public channels or we haven't broadcasted yet.
  final BigInt? latestNodeAnnouncementBroadcastTimestamp;

  /// The block height when we last archived closed channel monitor data.
  ///
  /// Will be `None` if we haven't archived any monitors of closed channels yet.
  final int? latestChannelMonitorArchivalHeight;

  const NodeStatus({
    required this.isRunning,
    required this.isListening,
    required this.currentBestBlock,
    this.latestLightningWalletSyncTimestamp,
    this.latestOnchainWalletSyncTimestamp,
    this.latestFeeRateCacheUpdateTimestamp,
    this.latestRgsSnapshotTimestamp,
    this.latestNodeAnnouncementBroadcastTimestamp,
    this.latestChannelMonitorArchivalHeight,
  });

  @override
  int get hashCode =>
      isRunning.hashCode ^
      isListening.hashCode ^
      currentBestBlock.hashCode ^
      latestLightningWalletSyncTimestamp.hashCode ^
      latestOnchainWalletSyncTimestamp.hashCode ^
      latestFeeRateCacheUpdateTimestamp.hashCode ^
      latestRgsSnapshotTimestamp.hashCode ^
      latestNodeAnnouncementBroadcastTimestamp.hashCode ^
      latestChannelMonitorArchivalHeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeStatus &&
          runtimeType == other.runtimeType &&
          isRunning == other.isRunning &&
          isListening == other.isListening &&
          currentBestBlock == other.currentBestBlock &&
          latestLightningWalletSyncTimestamp ==
              other.latestLightningWalletSyncTimestamp &&
          latestOnchainWalletSyncTimestamp ==
              other.latestOnchainWalletSyncTimestamp &&
          latestFeeRateCacheUpdateTimestamp ==
              other.latestFeeRateCacheUpdateTimestamp &&
          latestRgsSnapshotTimestamp == other.latestRgsSnapshotTimestamp &&
          latestNodeAnnouncementBroadcastTimestamp ==
              other.latestNodeAnnouncementBroadcastTimestamp &&
          latestChannelMonitorArchivalHeight ==
              other.latestChannelMonitorArchivalHeight;
}

class OfferId {
  final U8Array32 field0;

  const OfferId({
    required this.field0,
  });

  /// Returns the offer ID as bytes.
  Future<void> asBytes() => core.instance.api.ldkAdapterTypesOfferIdAsBytes(
        that: this,
      );

  /// Creates a new OfferId from a byte slice.
  /// Returns None if the slice is not exactly 32 bytes.
  static Future<OfferId?> fromBytes({required List<int> bytes}) =>
      core.instance.api.ldkAdapterTypesOfferIdFromBytes(bytes: bytes);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new OfferId from a 32-byte array.
  static Future<OfferId> newInstance({required U8Array32 data}) =>
      core.instance.api.ldkAdapterTypesOfferIdNew(data: data);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OfferId &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Represents the direction of a payment.
///
enum PaymentDirection {
  /// The payment is inbound.
  inbound,

  /// The payment is outbound.
  outbound,
  ;
}

/// payment_secret type, use to authenticate sender to the receiver and tie MPP HTLCs together
///
class PaymentSecret {
  final U8Array32 data;

  const PaymentSecret({
    required this.data,
  });

  /// Returns the payment secret as bytes.
  Future<void> asBytes() =>
      core.instance.api.ldkAdapterTypesPaymentSecretAsBytes(
        that: this,
      );

  /// Creates a new PaymentSecret from a byte slice.
  /// Returns None if the slice is not exactly 32 bytes.
  static Future<PaymentSecret?> fromBytes({required List<int> bytes}) =>
      core.instance.api.ldkAdapterTypesPaymentSecretFromBytes(bytes: bytes);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new PaymentSecret from a 32-byte array.
  static Future<PaymentSecret> newInstance({required U8Array32 data}) =>
      core.instance.api.ldkAdapterTypesPaymentSecretNew(data: data);

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentSecret &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// Represents the current status of a payment.
///
enum PaymentStatus {
  /// The payment is still pending.
  pending,

  /// The payment suceeded.
  succeeded,

  /// The payment failed.
  failed,
  ;
}
