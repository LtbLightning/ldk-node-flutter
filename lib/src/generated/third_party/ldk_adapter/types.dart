// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import '../shared.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `MaxTotalRoutingFeeLimit`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `try_from`, `try_from`, `try_from`

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>>
abstract class AnchorChannelsConfig implements RustOpaqueInterface {
  /// Adds a trusted peer to the configuration.
  Future<void> addTrustedPeer({required PublicKey peer});

  BigInt get perChannelReserveSats;

  List<PublicKey> get trustedPeersNoReserve;

  set perChannelReserveSats(BigInt perChannelReserveSats);

  set trustedPeersNoReserve(List<PublicKey> trustedPeersNoReserve);

  /// Creates a conservative AnchorChannelsConfig with no trusted peers and high reserve.
  static Future<AnchorChannelsConfig> conservative() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigConservative();

  static Future<AnchorChannelsConfig> default_() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigDefault();

  /// Checks if a peer is trusted (no reserve required).
  Future<bool> isPeerTrusted({required PublicKey peer});

  /// Creates a more aggressive AnchorChannelsConfig with lower reserve.
  static Future<AnchorChannelsConfig> lowReserve() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigLowReserve();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new AnchorChannelsConfig.
  static Future<AnchorChannelsConfig> newInstance(
          {required List<PublicKey> trustedPeersNoReserve,
          required BigInt perChannelReserveSats}) =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigNew(
          trustedPeersNoReserve: trustedPeersNoReserve,
          perChannelReserveSats: perChannelReserveSats);

  /// Removes a trusted peer from the configuration.
  Future<void> removeTrustedPeer({required PublicKey peer});

  /// Returns the number of trusted peers.
  Future<BigInt> trustedPeersCount();

  /// Creates an AnchorChannelsConfig that trusts specific peers with no reserve.
  static Future<AnchorChannelsConfig> withTrustedPeers(
          {required List<PublicKey> trustedPeers}) =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigWithTrustedPeers(
          trustedPeers: trustedPeers);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
abstract class ChannelConfig implements RustOpaqueInterface {
  bool get acceptUnderpayingHtlcs;

  int get cltvExpiryDelta;

  BigInt get forceCloseAvoidanceMaxFeeSatoshis;

  int get forwardingFeeBaseMsat;

  int get forwardingFeeProportionalMillionths;

  MaxDustHtlcExposure get maxDustHtlcExposure;

  set acceptUnderpayingHtlcs(bool acceptUnderpayingHtlcs);

  set cltvExpiryDelta(int cltvExpiryDelta);

  set forceCloseAvoidanceMaxFeeSatoshis(
      BigInt forceCloseAvoidanceMaxFeeSatoshis);

  set forwardingFeeBaseMsat(int forwardingFeeBaseMsat);

  set forwardingFeeProportionalMillionths(
      int forwardingFeeProportionalMillionths);

  set maxDustHtlcExposure(MaxDustHtlcExposure maxDustHtlcExposure);

  /// Gets the total forwarding fee for a given amount in millisatoshis.
  Future<BigInt> calculateForwardingFee({required BigInt amountMsat});

  /// Creates a high-fee routing configuration.
  static Future<ChannelConfig> highFeeRouting() =>
      core.instance.api.ldkAdapterTypesChannelConfigHighFeeRouting();

  /// Creates a low-fee routing configuration.
  static Future<ChannelConfig> lowFeeRouting() =>
      core.instance.api.ldkAdapterTypesChannelConfigLowFeeRouting();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new ChannelConfig with default values.
  /// Creates a new ChannelConfig with all arguments specified.
  static Future<ChannelConfig> newInstance(
          {required int forwardingFeeProportionalMillionths,
          required int forwardingFeeBaseMsat,
          required int cltvExpiryDelta,
          required MaxDustHtlcExposure maxDustHtlcExposure,
          required BigInt forceCloseAvoidanceMaxFeeSatoshis,
          required bool acceptUnderpayingHtlcs}) =>
      core.instance.api.ldkAdapterTypesChannelConfigNew(
          forwardingFeeProportionalMillionths:
              forwardingFeeProportionalMillionths,
          forwardingFeeBaseMsat: forwardingFeeBaseMsat,
          cltvExpiryDelta: cltvExpiryDelta,
          maxDustHtlcExposure: maxDustHtlcExposure,
          forceCloseAvoidanceMaxFeeSatoshis: forceCloseAvoidanceMaxFeeSatoshis,
          acceptUnderpayingHtlcs: acceptUnderpayingHtlcs);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
abstract class ChannelDetails implements RustOpaqueInterface {
  ChannelId get channelId;

  BigInt get channelValueSats;

  int? get cltvExpiryDelta;

  ChannelConfig get config;

  int? get confirmations;

  int? get confirmationsRequired;

  int? get counterpartyForwardingInfoCltvExpiryDelta;

  int? get counterpartyForwardingInfoFeeBaseMsat;

  int? get counterpartyForwardingInfoFeeProportionalMillionths;

  PublicKey get counterpartyNodeId;

  BigInt? get counterpartyOutboundHtlcMaximumMsat;

  BigInt? get counterpartyOutboundHtlcMinimumMsat;

  BigInt get counterpartyUnspendablePunishmentReserve;

  int get feerateSatPer1000Weight;

  int? get forceCloseSpendDelay;

  OutPoint? get fundingTxo;

  BigInt get inboundCapacityMsat;

  BigInt? get inboundHtlcMaximumMsat;

  BigInt get inboundHtlcMinimumMsat;

  bool get isChannelReady;

  bool get isOutbound;

  bool get isUsable;

  BigInt get nextOutboundHtlcLimitMsat;

  BigInt get nextOutboundHtlcMinimumMsat;

  BigInt get outboundCapacityMsat;

  BigInt? get unspendablePunishmentReserve;

  UserChannelId get userChannelId;

  set channelId(ChannelId channelId);

  set channelValueSats(BigInt channelValueSats);

  set cltvExpiryDelta(int? cltvExpiryDelta);

  set config(ChannelConfig config);

  set confirmations(int? confirmations);

  set confirmationsRequired(int? confirmationsRequired);

  set counterpartyForwardingInfoCltvExpiryDelta(
      int? counterpartyForwardingInfoCltvExpiryDelta);

  set counterpartyForwardingInfoFeeBaseMsat(
      int? counterpartyForwardingInfoFeeBaseMsat);

  set counterpartyForwardingInfoFeeProportionalMillionths(
      int? counterpartyForwardingInfoFeeProportionalMillionths);

  set counterpartyNodeId(PublicKey counterpartyNodeId);

  set counterpartyOutboundHtlcMaximumMsat(
      BigInt? counterpartyOutboundHtlcMaximumMsat);

  set counterpartyOutboundHtlcMinimumMsat(
      BigInt? counterpartyOutboundHtlcMinimumMsat);

  set counterpartyUnspendablePunishmentReserve(
      BigInt counterpartyUnspendablePunishmentReserve);

  set feerateSatPer1000Weight(int feerateSatPer1000Weight);

  set forceCloseSpendDelay(int? forceCloseSpendDelay);

  set fundingTxo(OutPoint? fundingTxo);

  set inboundCapacityMsat(BigInt inboundCapacityMsat);

  set inboundHtlcMaximumMsat(BigInt? inboundHtlcMaximumMsat);

  set inboundHtlcMinimumMsat(BigInt inboundHtlcMinimumMsat);

  set isChannelReady(bool isChannelReady);

  set isOutbound(bool isOutbound);

  set isUsable(bool isUsable);

  set nextOutboundHtlcLimitMsat(BigInt nextOutboundHtlcLimitMsat);

  set nextOutboundHtlcMinimumMsat(BigInt nextOutboundHtlcMinimumMsat);

  set outboundCapacityMsat(BigInt outboundCapacityMsat);

  set unspendablePunishmentReserve(BigInt? unspendablePunishmentReserve);

  set userChannelId(UserChannelId userChannelId);

  /// Returns the balance ratio (outbound / total) as a percentage.
  Future<double> balanceRatioPercent();

  /// Checks if the channel can receive the specified amount in millisatoshis.
  Future<bool> canReceive({required BigInt amountMsat});

  /// Checks if the channel can send the specified amount in millisatoshis.
  Future<bool> canSend({required BigInt amountMsat});

  /// Returns the total channel capacity in satoshis.
  Future<BigInt> capacitySats();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new ChannelDetails (mainly for testing purposes).
  static Future<ChannelDetails> newInstance(
          {required ChannelId channelId,
          required PublicKey counterpartyNodeId,
          OutPoint? fundingTxo,
          required BigInt channelValueSats,
          BigInt? unspendablePunishmentReserve,
          required UserChannelId userChannelId,
          required int feerateSatPer1000Weight,
          required BigInt outboundCapacityMsat,
          required BigInt inboundCapacityMsat,
          required bool isOutbound,
          required bool isChannelReady,
          required bool isUsable,
          required ChannelConfig config}) =>
      core.instance.api.ldkAdapterTypesChannelDetailsNew(
          channelId: channelId,
          counterpartyNodeId: counterpartyNodeId,
          fundingTxo: fundingTxo,
          channelValueSats: channelValueSats,
          unspendablePunishmentReserve: unspendablePunishmentReserve,
          userChannelId: userChannelId,
          feerateSatPer1000Weight: feerateSatPer1000Weight,
          outboundCapacityMsat: outboundCapacityMsat,
          inboundCapacityMsat: inboundCapacityMsat,
          isOutbound: isOutbound,
          isChannelReady: isChannelReady,
          isUsable: isUsable,
          config: config);

  /// Returns the total available liquidity (inbound + outbound) in millisatoshis.
  Future<BigInt> totalLiquidityMsat();
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>
abstract class ChannelId implements RustOpaqueInterface {
  /// Returns the channel ID as bytes.
  Future<void> asBytes();

  U8Array32 get data;

  set data(U8Array32 data);

  /// Creates a new ChannelId from a byte slice.
  /// Returns None if the slice is not exactly 32 bytes.
  static Future<ChannelId?> fromBytes({required List<int> bytes}) =>
      core.instance.api.ldkAdapterTypesChannelIdFromBytes(bytes: bytes);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new ChannelId from a 32-byte array.
  static Future<ChannelId> newInstance({required U8Array32 data}) =>
      core.instance.api.ldkAdapterTypesChannelIdNew(data: data);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfirmationStatus>>
abstract class ConfirmationStatus implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>
abstract class MaxDustHtlcExposure implements RustOpaqueInterface {
  /// Creates a conservative fixed limit (1 million msat).
  static Future<MaxDustHtlcExposure> conservative() =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureConservative();

  /// Creates a default fee rate multiplier configuration.
  static Future<MaxDustHtlcExposure> defaultFeeRate() =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureDefaultFeeRate();

  /// Creates a new MaxDustHTLCExposure with a fee rate multiplier.
  static Future<MaxDustHtlcExposure> newFeeRateMultiplier(
          {required BigInt multiplier}) =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureNewFeeRateMultiplier(
          multiplier: multiplier);

  /// Creates a new MaxDustHTLCExposure with a fixed limit in millisatoshis.
  static Future<MaxDustHtlcExposure> newFixedLimit(
          {required BigInt limitMsat}) =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureNewFixedLimit(
          limitMsat: limitMsat);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
abstract class PeerDetails implements RustOpaqueInterface {
  SocketAddress get address;

  bool get isConnected;

  PublicKey get nodeId;

  set address(SocketAddress address);

  set isConnected(bool isConnected);

  set nodeId(PublicKey nodeId);

  /// Checks if the peer is currently disconnected.
  Future<bool> isOffline();

  /// Checks if the peer is currently connected.
  Future<bool> isOnline();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new PeerDetails.
  static Future<PeerDetails> newInstance(
          {required PublicKey nodeId,
          required SocketAddress address,
          required bool isConnected}) =>
      core.instance.api.ldkAdapterTypesPeerDetailsNew(
          nodeId: nodeId, address: address, isConnected: isConnected);

  /// Creates a new connected peer.
  static Future<PeerDetails> newConnected(
          {required PublicKey nodeId, required SocketAddress address}) =>
      core.instance.api.ldkAdapterTypesPeerDetailsNewConnected(
          nodeId: nodeId, address: address);

  /// Creates a new disconnected peer.
  static Future<PeerDetails> newDisconnected(
          {required PublicKey nodeId, required SocketAddress address}) =>
      core.instance.api.ldkAdapterTypesPeerDetailsNewDisconnected(
          nodeId: nodeId, address: address);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>
abstract class UserChannelId implements RustOpaqueInterface {
  /// Returns the data as a byte slice.
  Future<void> asBytes();

  Uint8List get data;

  set data(Uint8List data);

  /// Creates a new UserChannelId from a string.
  static Future<UserChannelId> fromString({required String s}) =>
      core.instance.api.ldkAdapterTypesUserChannelIdFromString(s: s);

  /// Creates a new UserChannelId from a u64.
  static Future<UserChannelId> fromU64({required BigInt id}) =>
      core.instance.api.ldkAdapterTypesUserChannelIdFromU64(id: id);

  /// Creates a new UserChannelId from a byte vector.
  factory UserChannelId({required List<int> data}) =>
      core.instance.api.ldkAdapterTypesUserChannelIdNew(data: data);
}

abstract class FfiLogWriter {
  /// Handle a log record.
  Future<void> log({required FfiLogRecord record});
}

/// Options related to background syncing the Lightning and on-chain wallets.
///
/// ### Defaults
///
/// | Parameter                              | Value              |
/// |----------------------------------------|--------------------|
/// | `onchain_wallet_sync_interval_secs`    | 80                 |
/// | `lightning_wallet_sync_interval_secs`  | 30                 |
/// | `fee_rate_cache_update_interval_secs`  | 600                |
class BackgroundSyncConfig {
  /// The time in-between background sync attempts of the onchain wallet, in seconds.
  ///
  /// **Note:** A minimum of 10 seconds is enforced when background syncing is enabled.
  final BigInt onchainWalletSyncIntervalSecs;

  /// The time in-between background sync attempts of the LDK wallet, in seconds.
  ///
  /// **Note:** A minimum of 10 seconds is enforced when background syncing is enabled.
  final BigInt lightningWalletSyncIntervalSecs;

  /// The time in-between background update attempts to our fee rate cache, in seconds.
  ///
  /// **Note:** A minimum of 10 seconds is enforced when background syncing is enabled.
  final BigInt feeRateCacheUpdateIntervalSecs;

  const BackgroundSyncConfig({
    required this.onchainWalletSyncIntervalSecs,
    required this.lightningWalletSyncIntervalSecs,
    required this.feeRateCacheUpdateIntervalSecs,
  });

  @override
  int get hashCode =>
      onchainWalletSyncIntervalSecs.hashCode ^
      lightningWalletSyncIntervalSecs.hashCode ^
      feeRateCacheUpdateIntervalSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BackgroundSyncConfig &&
          runtimeType == other.runtimeType &&
          onchainWalletSyncIntervalSecs ==
              other.onchainWalletSyncIntervalSecs &&
          lightningWalletSyncIntervalSecs ==
              other.lightningWalletSyncIntervalSecs &&
          feeRateCacheUpdateIntervalSecs ==
              other.feeRateCacheUpdateIntervalSecs;
}

/// Details of the known available balances returned by `node.listBalances`.
///
class BalanceDetails {
  /// The total balance of our on-chain wallet.
  final BigInt totalOnchainBalanceSats;

  /// The currently spendable balance of our on-chain wallet.
  final BigInt spendableOnchainBalanceSats;

  /// The total balance that we would be able to claim across all our Lightning channels.
  ///
  /// Note this excludes balances that we are unsure if we are able to claim (e.g., as we are
  final BigInt totalLightningBalanceSats;

  /// A detailed list of all known Lightning balances that would be claimable on channel closure.
  ///
  /// Note that less than the listed amounts are spendable over lightning as further reserve
  /// restrictions apply.
  final List<LightningBalance> lightningBalances;

  /// A detailed list of balances currently being swept from the Lightning to the on-chain
  /// wallet.
  ///
  /// These are balances resulting from channel closures that may have been encumbered by a
  /// delay, but are now being claimed and useable once sufficiently confirmed on-chain.
  ///
  /// Note that, depending on the sync status of the wallets, swept balances listed here might or
  /// might not already be accounted for in `totalOnchainBalanceSats`.
  final List<PendingSweepBalance> pendingBalancesFromChannelClosures;

  const BalanceDetails({
    required this.totalOnchainBalanceSats,
    required this.spendableOnchainBalanceSats,
    required this.totalLightningBalanceSats,
    required this.lightningBalances,
    required this.pendingBalancesFromChannelClosures,
  });

  @override
  int get hashCode =>
      totalOnchainBalanceSats.hashCode ^
      spendableOnchainBalanceSats.hashCode ^
      totalLightningBalanceSats.hashCode ^
      lightningBalances.hashCode ^
      pendingBalancesFromChannelClosures.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BalanceDetails &&
          runtimeType == other.runtimeType &&
          totalOnchainBalanceSats == other.totalOnchainBalanceSats &&
          spendableOnchainBalanceSats == other.spendableOnchainBalanceSats &&
          totalLightningBalanceSats == other.totalLightningBalanceSats &&
          lightningBalances == other.lightningBalances &&
          pendingBalancesFromChannelClosures ==
              other.pendingBalancesFromChannelClosures;
}

/// Indicates whether the balance is derived from a cooperative close, a force-close
/// (for holder or counterparty), or whether it is for an HTLC.
enum BalanceSource {
  /// The channel was force closed by the holder.
  holderForceClosed,

  /// The channel was force closed by the counterparty.
  counterpartyForceClosed,

  /// The channel was cooperatively closed.
  coopClose,

  /// This balance is the result of an HTLC.
  htlc,
  ;
}

/// The best known block as identified by its hash and height.
class BestBlock {
  /// The block's hash
  final String blockHash;

  /// The height at which the block was confirmed.
  final int height;

  const BestBlock({
    required this.blockHash,
    required this.height,
  });

  @override
  int get hashCode => blockHash.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BestBlock &&
          runtimeType == other.runtimeType &&
          blockHash == other.blockHash &&
          height == other.height;
}

@freezed
sealed class ChainDataSourceConfig with _$ChainDataSourceConfig {
  const ChainDataSourceConfig._();

  const factory ChainDataSourceConfig.esplora({
    required String serverUrl,
    EsploraSyncConfig? syncConfig,
  }) = ChainDataSourceConfig_Esplora;
  const factory ChainDataSourceConfig.electrum({
    required String serverUrl,
    ElectrumSyncConfig? syncConfig,
  }) = ChainDataSourceConfig_Electrum;
  const factory ChainDataSourceConfig.bitcoindRpc({
    required String rpcHost,
    required int rpcPort,
    required String rpcUser,
    required String rpcPassword,
  }) = ChainDataSourceConfig_BitcoindRpc;
}

@freezed
sealed class ClosureReason with _$ClosureReason {
  const ClosureReason._();

  /// Our peer provided a feerate which violated our required minimum (fetched from our
  /// `FeeEstimator`
  ///
  const factory ClosureReason.peerFeerateTooLow({
    required int peerFeerateSatPerKw,
    required int requiredFeerateSatPerKw,
  }) = ClosureReason_PeerFeerateTooLow;

  /// Closure generated from receiving a peer error message.
  ///
  /// Our counterparty may have broadcasted their latest commitment state, and we have
  /// as well.
  const factory ClosureReason.counterpartyForceClosed({
    /// The error which the peer sent us.
    ///
    /// Be careful about printing the peer_msg, a well-crafted message could exploit
    /// a security vulnerability in the terminal emulator or the logging subsystem.
    /// To be safe, use `Display` on `UntrustedString`
    ///
    /// [`UntrustedString`]: crate::util::string::UntrustedString
    required String peerMsg,
  }) = ClosureReason_CounterpartyForceClosed;

  /// Closure generated from [`ChannelManager::force_close_channel`], called by the user.
  ///
  /// [`ChannelManager::force_close_channel`]: crate::ln::channelmanager::ChannelManager::force_close_channel.
  const factory ClosureReason.holderForceClosed({
    bool? broadcastedLatestTxn,
  }) = ClosureReason_HolderForceClosed;

  /// The channel was closed after negotiating a cooperative close and we've now broadcasted
  /// the cooperative close transaction. Note the shutdown may have been initiated by us.
  ///
  /// This was only set in versions of LDK prior to 0.0.122.
  const factory ClosureReason.legacyCooperativeClosure() =
      ClosureReason_LegacyCooperativeClosure;

  /// The channel was closed after negotiating a cooperative close and we've now broadcasted
  /// the cooperative close transaction. This indicates that the shutdown was initiated by our
  /// counterparty.
  ///
  /// In rare cases where we initiated closure immediately prior to shutting down without
  /// persisting, this value may be provided for channels we initiated closure for.
  const factory ClosureReason.counterpartyInitiatedCooperativeClosure() =
      ClosureReason_CounterpartyInitiatedCooperativeClosure;

  /// The channel was closed after negotiating a cooperative close and we've now broadcasted
  /// the cooperative close transaction. This indicates that the shutdown was initiated by us.
  const factory ClosureReason.locallyInitiatedCooperativeClosure() =
      ClosureReason_LocallyInitiatedCooperativeClosure;

  /// A commitment transaction was confirmed on chain, closing the channel. Most likely this
  /// commitment transaction came from our counterparty, but it may also have come from
  /// a copy of our own `ChannelMonitor`.
  const factory ClosureReason.commitmentTxConfirmed() =
      ClosureReason_CommitmentTxConfirmed;

  /// The funding transaction failed to confirm in a timely manner on an inbound channel.
  const factory ClosureReason.fundingTimedOut() = ClosureReason_FundingTimedOut;

  /// Closure generated from processing an event, likely a HTLC forward/relay/reception.
  const factory ClosureReason.processingError({
    /// A developer-readable error message which we generated.
    required String err,
  }) = ClosureReason_ProcessingError;

  /// The peer disconnected prior to funding completing. In this case the spec mandates that we
  /// forget the channel entirely - we can attempt again if the peer reconnects.
  ///
  /// This includes cases where we restarted prior to funding completion, including prior to the
  /// initial [`ChannelMonitor`] persistence completing.
  ///
  /// In LDK versions prior to 0.0.107 this could also occur if we were unable to connect to the
  /// peer because of mutual incompatibility between us and our channel counterparty.
  ///
  /// [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
  const factory ClosureReason.disconnectedPeer() =
      ClosureReason_DisconnectedPeer;

  /// Closure generated from `ChannelManager::read` if the [`ChannelMonitor`] is newer than
  /// the [`ChannelManager`] deserialized.
  ///
  /// [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
  /// [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
  const factory ClosureReason.outdatedChannelManager() =
      ClosureReason_OutdatedChannelManager;

  /// The counterparty requested a cooperative close of a channel that had not been funded yet.
  /// The channel has been immediately closed.
  const factory ClosureReason.counterpartyCoopClosedUnfundedChannel() =
      ClosureReason_CounterpartyCoopClosedUnfundedChannel;

  /// Another channel in the same funding batch closed before the funding transaction
  /// was ready to be broadcast.
  const factory ClosureReason.fundingBatchClosure() =
      ClosureReason_FundingBatchClosure;

  /// One of our HTLCs timed out in a channel, causing us to force close the channel.
  const factory ClosureReason.htlCsTimedOut() = ClosureReason_HTLCsTimedOut;
}

/// Represents the configuration of an [Node] instance.
///
class Config {
  String storageDirPath;

  /// The used Bitcoin network.
  Network network;

  /// The IP address and TCP port the node will listen on.
  ///
  List<SocketAddress>? listeningAddresses;

  /// The addresses which the node will announce to the gossip network that it accepts connections on.
  final List<SocketAddress>? announcementAddresses;

  /// The node alias that will be used when broadcasting announcements to the gossip network.
  ///
  /// The provided alias must be a valid UTF-8 string and no longer than 32 bytes in total.
  ///
  /// **Note**: We will only allow opening and accepting public channels if the `nodeAlias` and the
  /// `listeningAddresses` are set.
  NodeAlias? nodeAlias;

  ///A list of peers that we allow to establish zero confirmation channels to us.
  ///
  ///Note: Allowing payments via zero-confirmation channels is potentially insecure if the funding transaction ends up never being confirmed on-chain. Zero-confirmation channels should therefore only be accepted from trusted peers.
  final List<PublicKey> trustedPeers0Conf;
  final BigInt probingLiquidityLimitMultiplier;

  ///The level at which we log messages.
  /// Any messages below this level will be excluded from the logs.
  ///
  final AnchorChannelsConfig? anchorChannelsConfig;

  /// Configuration options for payment routing and pathfinding.
  ///
  /// Setting the `SendingParameters` provides flexibility to customize how payments are routed,
  /// including setting limits on routing fees, CLTV expiry, and channel utilization.
  ///
  /// **Note:** If unset, default parameters will be used, and you will be able to override the
  /// parameters on a per-payment basis in the corresponding method calls.
  final SendingParameters? sendingParameters;

  Config({
    required this.storageDirPath,
    required this.network,
    this.listeningAddresses,
    this.announcementAddresses,
    this.nodeAlias,
    required this.trustedPeers0Conf,
    required this.probingLiquidityLimitMultiplier,
    this.anchorChannelsConfig,
    this.sendingParameters,
  });

  static Future<Config> default_() =>
      core.instance.api.ldkAdapterTypesConfigDefault();

  @override
  int get hashCode =>
      storageDirPath.hashCode ^
      network.hashCode ^
      listeningAddresses.hashCode ^
      announcementAddresses.hashCode ^
      nodeAlias.hashCode ^
      trustedPeers0Conf.hashCode ^
      probingLiquidityLimitMultiplier.hashCode ^
      anchorChannelsConfig.hashCode ^
      sendingParameters.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          storageDirPath == other.storageDirPath &&
          network == other.network &&
          listeningAddresses == other.listeningAddresses &&
          announcementAddresses == other.announcementAddresses &&
          nodeAlias == other.nodeAlias &&
          trustedPeers0Conf == other.trustedPeers0Conf &&
          probingLiquidityLimitMultiplier ==
              other.probingLiquidityLimitMultiplier &&
          anchorChannelsConfig == other.anchorChannelsConfig &&
          sendingParameters == other.sendingParameters;
}

/// A Custom TLV entry.
class CustomTlvRecord {
  /// Type number.
  final BigInt typeNum;

  /// Serialized value.
  final Uint8List value;

  const CustomTlvRecord({
    required this.typeNum,
    required this.value,
  });

  /// Creates a new CustomTlvRecord from a string value.
  static Future<CustomTlvRecord> fromString(
          {required BigInt typeNum, required String value}) =>
      core.instance.api.ldkAdapterTypesCustomTlvRecordFromString(
          typeNum: typeNum, value: value);

  /// Creates a new CustomTlvRecord from a u64 value.
  static Future<CustomTlvRecord> fromU64(
          {required BigInt typeNum, required BigInt value}) =>
      core.instance.api.ldkAdapterTypesCustomTlvRecordFromU64(
          typeNum: typeNum, value: value);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new CustomTlvRecord.
  static Future<CustomTlvRecord> newInstance(
          {required BigInt typeNum, required List<int> value}) =>
      core.instance.api
          .ldkAdapterTypesCustomTlvRecordNew(typeNum: typeNum, value: value);

  /// Returns the value as a string if it's valid UTF-8.
  Future<String?> valueAsString() =>
      core.instance.api.ldkAdapterTypesCustomTlvRecordValueAsString(
        that: this,
      );

  @override
  int get hashCode => typeNum.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CustomTlvRecord &&
          runtimeType == other.runtimeType &&
          typeNum == other.typeNum &&
          value == other.value;
}

class ElectrumSyncConfig {
  /// Background sync configuration.
  ///
  /// If set to `Null`, background syncing is disabled.
  /// you must use `sync_wallets` to manually sync the wallets.
  final BackgroundSyncConfig? backgroundSyncConfig;

  const ElectrumSyncConfig({
    this.backgroundSyncConfig,
  });

  @override
  int get hashCode => backgroundSyncConfig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ElectrumSyncConfig &&
          runtimeType == other.runtimeType &&
          backgroundSyncConfig == other.backgroundSyncConfig;
}

@freezed
sealed class EntropySourceConfig with _$EntropySourceConfig {
  const EntropySourceConfig._();

  const factory EntropySourceConfig.seedFile(
    String field0,
  ) = EntropySourceConfig_SeedFile;
  const factory EntropySourceConfig.seedBytes(
    U8Array64 field0,
  ) = EntropySourceConfig_SeedBytes;
  const factory EntropySourceConfig.bip39Mnemonic({
    required Mnemonic mnemonic,
    String? passphrase,
  }) = EntropySourceConfig_Bip39Mnemonic;
}

class EsploraSyncConfig {
  /// Background sync configuration.
  ///
  /// If set to `Null`, background syncing is disabled.
  /// you must use `sync_wallets` to manually sync the wallets.
  final BackgroundSyncConfig? backgroundSyncConfig;

  const EsploraSyncConfig({
    this.backgroundSyncConfig,
  });

  @override
  int get hashCode => backgroundSyncConfig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EsploraSyncConfig &&
          runtimeType == other.runtimeType &&
          backgroundSyncConfig == other.backgroundSyncConfig;
}

@freezed
sealed class Event with _$Event {
  const Event._();

  /// A payment for a previously-registered payment hash has been received.
  ///
  /// This needs to be manually claimed by supplying the correct preimage to `claimForHash`.
  ///
  /// If the the provided parameters don't match the expectations or the preimage can't be
  /// retrieved in time, should be failed-back via [`failForHash`].
  const factory Event.paymentClaimable({
    /// A local identifier used to track the payment.
    required PaymentId paymentId,

    /// The hash of the payment.
    required PaymentHash paymentHash,

    /// The value, in thousandths of a satoshi, that is claimable.
    required BigInt claimableAmountMsat,

    /// The block height at which this payment will be failed back and will no longer be
    /// eligible for claiming.
    int? claimDeadline,

    /// Custom TLV records attached to the payment
    required List<CustomTlvRecord> customRecords,
  }) = Event_PaymentClaimable;

  /// A sent payment was successful.
  const factory Event.paymentSuccessful({
    /// A local identifier used to track the payment.
    ///
    /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
    PaymentId? paymentId,

    /// The hash of the payment.
    required PaymentHash paymentHash,

    /// The total fee which was spent at intermediate hops in this payment.
    BigInt? feePaidMsat,

    /// The preimage of the payment hash, which can be used to claim the payment.
    PaymentPreimage? preimage,
  }) = Event_PaymentSuccessful;

  /// A sent payment has failed.
  const factory Event.paymentFailed({
    /// A local identifier used to track the payment.
    ///
    /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
    PaymentId? paymentId,

    /// The hash of the payment.
    PaymentHash? paymentHash,

    /// The reason why the payment failed.
    ///
    /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
    PaymentFailureReason? reason,
  }) = Event_PaymentFailed;

  /// A payment has been received.
  const factory Event.paymentReceived({
    /// A local identifier used to track the payment.
    ///
    /// Will only be `None` for events serialized with LDK Node v0.2.1 or prior.
    PaymentId? paymentId,

    /// The hash of the payment.
    required PaymentHash paymentHash,

    /// The value, in thousandths of a satoshi, that has been received.
    required BigInt amountMsat,

    /// Custom TLV records received on the payment
    required List<CustomTlvRecord> customRecords,
  }) = Event_PaymentReceived;

  /// A channel has been created and is pending confirmation on-chain.
  const factory Event.channelPending({
    /// The `channelId` of the channel.
    required ChannelId channelId,

    /// The `userChannelId` of the channel.
    required UserChannelId userChannelId,

    /// The `temporaryChannelId` this channel used to be known by during channel establishment.
    required ChannelId formerTemporaryChannelId,

    /// The `nodeId` of the channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The outpoint of the channel's funding transaction.
    required OutPoint fundingTxo,
  }) = Event_ChannelPending;

  /// A channel is ready to be used.
  const factory Event.channelReady({
    /// The `channelId` of the channel.
    required ChannelId channelId,

    /// The `userChannelId` of the channel.
    required UserChannelId userChannelId,

    /// The `nodeId` of the channel counterparty.
    ///
    /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
    PublicKey? counterpartyNodeId,
  }) = Event_ChannelReady;

  /// A channel has been closed.
  const factory Event.channelClosed({
    /// The `channelId` of the channel.
    required ChannelId channelId,

    /// The `userChannelId` of the channel.
    required UserChannelId userChannelId,

    /// The `nodeId` of the channel counterparty.
    ///
    /// This will be `None` for events serialized by LDK Node v0.1.0 and prior.
    PublicKey? counterpartyNodeId,

    /// This will be `None` for events serialized by LDK Node v0.2.1 and prior.
    ClosureReason? reason,
  }) = Event_ChannelClosed;
  const factory Event.paymentForwarded({
    /// The channel id of the incoming channel between the previous node and us.
    required ChannelId prevChannelId,

    /// The channel id of the outgoing channel between the next node and us.
    required ChannelId nextChannelId,

    /// The `user_channel_id` of the incoming channel between the previous node and us.
    UserChannelId? prevUserChannelId,

    /// The `user_channel_id` of the outgoing channel between the next node and us.
    UserChannelId? nextUserChannelId,

    /// The node id of the previous node.
    ///
    /// This is only null for HTLCs received prior to LDK Node v0.5 or for events serialized by
    /// versions prior to v0.5.
    PublicKey? prevNodeId,

    /// The node id of the next node.
    ///
    /// This is only null for HTLCs received prior to LDK Node v0.5 or for events serialized by
    /// versions prior to v0.5.
    PublicKey? nextNodeId,

    /// The total fee, in milli-satoshis, which was earned as a result of the payment.
    BigInt? totalFeeEarnedMsat,

    /// The share of the total fee, in milli-satoshis, which was withheld in addition to the
    /// forwarding fee.
    BigInt? skimmedFeeMsat,

    /// If this is `true`, the forwarded HTLC was claimed by our counterparty via an on-chain
    /// transaction.
    required bool claimFromOnchainTx,

    /// The final amount forwarded, in milli-satoshis, after the fee is deducted.
    BigInt? outboundAmountForwardedMsat,
  }) = Event_PaymentForwarded;
}

/// A unit of logging output with metadata to enable filtering by module path and line number.
class FfiLogRecord {
  /// The verbosity level of the message.
  final LogLevel level;

  /// The message body.
  final String args;

  /// The module path of the message.
  final String modulePath;

  /// The line containing the message.
  final int line;

  const FfiLogRecord({
    required this.level,
    required this.args,
    required this.modulePath,
    required this.line,
  });

  /// Creates a new debug log record.
  static Future<FfiLogRecord> debug(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordDebug(
          args: args, modulePath: modulePath, line: line);

  /// Creates a new error log record.
  static Future<FfiLogRecord> error(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordError(
          args: args, modulePath: modulePath, line: line);

  /// Returns a formatted log message.
  Future<String> formatted() =>
      core.instance.api.ldkAdapterTypesFfiLogRecordFormatted(
        that: this,
      );

  /// Creates a new info log record.
  static Future<FfiLogRecord> info(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordInfo(
          args: args, modulePath: modulePath, line: line);

  /// Checks if this is an error log.
  Future<bool> isError() =>
      core.instance.api.ldkAdapterTypesFfiLogRecordIsError(
        that: this,
      );

  /// Checks if this is a warning log.
  Future<bool> isWarn() => core.instance.api.ldkAdapterTypesFfiLogRecordIsWarn(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new FfiLogRecord.
  static Future<FfiLogRecord> newInstance(
          {required LogLevel level,
          required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordNew(
          level: level, args: args, modulePath: modulePath, line: line);

  /// Creates a new trace log record.
  static Future<FfiLogRecord> trace(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordTrace(
          args: args, modulePath: modulePath, line: line);

  /// Creates a new warning log record.
  static Future<FfiLogRecord> warn(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordWarn(
          args: args, modulePath: modulePath, line: line);

  @override
  int get hashCode =>
      level.hashCode ^ args.hashCode ^ modulePath.hashCode ^ line.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiLogRecord &&
          runtimeType == other.runtimeType &&
          level == other.level &&
          args == other.args &&
          modulePath == other.modulePath &&
          line == other.line;
}

@freezed
sealed class GossipSourceConfig with _$GossipSourceConfig {
  const GossipSourceConfig._();

  const factory GossipSourceConfig.p2PNetwork() = GossipSourceConfig_P2PNetwork;
  const factory GossipSourceConfig.rapidGossipSync(
    String field0,
  ) = GossipSourceConfig_RapidGossipSync;
}

@freezed
sealed class LightningBalance with _$LightningBalance {
  const LightningBalance._();

  /// The channel is not yet closed (or the commitment or closing transaction has not yet
  /// appeared in a block). The given balance is claimable (less on-chain fees) if the channel is
  /// force-closed now.
  const factory LightningBalance.claimableOnChannelClose({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
    /// required to do so.
    required BigInt amountSatoshis,

    /// The transaction fee we pay for the closing commitment transaction. This amount is not
    /// included in the `amount_satoshis` value.
    ///
    /// Note that if this channel is inbound (and thus our counterparty pays the commitment
    /// transaction fee) this value will be zero. For channels created prior to LDK Node 0.4
    /// the channel is always treated as outbound (and thus this value is never zero).
    required BigInt transactionFeeSatoshis,

    /// The amount of millisatoshis which has been burned to fees from HTLCs which are outbound
    /// from us and are related to a payment which was sent by us. This is the sum of the
    /// millisatoshis part of all HTLCs which are otherwise represented by
    /// This amount (rounded up to a whole satoshi value) will not be included in `amountSatoshis`.
    required BigInt outboundPaymentHtlcRoundedMsat,

    /// The amount of millisatoshis which has been burned to fees from HTLCs which are outbound
    /// from us and are related to a forwarded HTLC. This is the sum of the millisatoshis part
    /// of all HTLCs which are otherwise represented by
    /// This amount (rounded up to a whole satoshi value) will not be included in `amountSatoshis`.
    required BigInt outboundForwardedHtlcRoundedMsat,

    /// The amount of millisatoshis which has been burned to fees from HTLCs which are inbound
    /// to us and for which we know the preimage. This is the sum of the millisatoshis part of
    /// all HTLCs which would be represented by `lightningBalance.ContentiousClaimable` on
    /// channel close, but whose current value is included in `amountSatoshis`, as well as any
    /// dust HTLCs which would otherwise be represented the same.
    ///
    /// This amount (rounded up to a whole satoshi value) will not be included in `amountSatoshis`.
    required BigInt inboundClaimingHtlcRoundedMsat,

    /// The amount of millisatoshis which has been burned to fees from HTLCs which are inbound
    /// to us and for which we do not know the preimage. This is the sum of the millisatoshis
    /// part of all HTLCs which would be represented by
    /// `lightningBalance.MaybePreimageClaimableHTLC` on channel close, as well as any dust
    /// HTLCs which would otherwise be represented the same.
    ///
    /// This amount (rounded up to a whole satoshi value) will not be included in the
    /// counterparty's `amountSatoshis`.
    required BigInt inboundHtlcRoundedMsat,
  }) = LightningBalance_ClaimableOnChannelClose;

  /// The channel has been closed, and the given balance is ours but awaiting confirmations until
  /// we consider it spendable.
  const factory LightningBalance.claimableAwaitingConfirmations({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount available to claim, in satoshis, possibly excluding the on-chain fees which
    /// were spent in broadcasting the transaction.
    required BigInt amountSatoshis,

    /// The height at which an `event.SpendableOutputs` event will be generated for this
    /// amount.
    ///
    required int confirmationHeight,

    /// Whether this balance is a result of cooperative close, a force-close, or an HTLC.
    required BalanceSource source,
  }) = LightningBalance_ClaimableAwaitingConfirmations;

  /// The channel has been closed, and the given balance should be ours but awaiting spending
  /// transaction confirmation. If the spending transaction does not confirm in time, it is
  /// possible our counterparty can take the funds by broadcasting an HTLC timeout on-chain.
  ///
  /// Once the spending transaction confirms, before it has reached enough confirmations to be
  /// considered safe from chain reorganizations, the balance will instead be provided via
  /// `lightningBalance.claimableAwaitingConfirmations`.
  const factory LightningBalance.contentiousClaimable({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount available to claim, in satoshis, excluding the on-chain fees which will be
    /// required to do so.
    required BigInt amountSatoshis,

    /// The height at which the counterparty may be able to claim the balance if we have not
    /// done so.
    required int timeoutHeight,

    /// The payment hash that locks this HTLC.
    required PaymentHash paymentHash,

    /// The preimage that can be used to claim this HTLC.
    required PaymentPreimage paymentPreimage,
  }) = LightningBalance_ContentiousClaimable;

  /// HTLCs which we sent to our counterparty which are claimable after a timeout (less on-chain
  /// fees) if the counterparty does not know the preimage for the HTLCs. These are somewhat
  /// likely to be claimed by our counterparty before we do.
  const factory LightningBalance.maybeTimeoutClaimableHtlc({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
    /// which will be required to do so.
    required BigInt amountSatoshis,

    /// The height at which we will be able to claim the balance if our counterparty has not
    /// done so.
    required int claimableHeight,

    /// The payment hash whose preimage our counterparty needs to claim this HTLC.
    required PaymentHash paymentHash,

    ///
    required bool outboundPayment,
  }) = LightningBalance_MaybeTimeoutClaimableHTLC;

  /// HTLCs which we received from our counterparty which are claimable with a preimage which we
  /// do not currently have. This will only be claimable if we receive the preimage from the node
  /// to which we forwarded this HTLC before the timeout.
  const factory LightningBalance.maybePreimageClaimableHtlc({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount potentially available to claim, in satoshis, excluding the on-chain fees
    /// which will be required to do so.
    required BigInt amountSatoshis,

    /// The height at which our counterparty will be able to claim the balance if we have not
    /// yet received the preimage and claimed it ourselves.
    required int expiryHeight,

    /// The payment hash whose preimage we need to claim this HTLC.
    required PaymentHash paymentHash,
  }) = LightningBalance_MaybePreimageClaimableHTLC;

  /// The channel has been closed, and our counterparty broadcasted a revoked commitment
  /// transaction.
  ///
  /// Thus, we're able to claim all outputs in the commitment transaction, one of which has the
  /// following amount.
  const factory LightningBalance.counterpartyRevokedOutputClaimable({
    /// The identifier of the channel this balance belongs to.
    required ChannelId channelId,

    /// The identifier of our channel counterparty.
    required PublicKey counterpartyNodeId,

    /// The amount, in satoshis, of the output which we can claim.
    required BigInt amountSatoshis,
  }) = LightningBalance_CounterpartyRevokedOutputClaimable;
}

class LiquiditySourceConfig {
  final (SocketAddress, PublicKey, String?) lsps2Service;

  const LiquiditySourceConfig({
    required this.lsps2Service,
  });

  @override
  int get hashCode => lsps2Service.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LiquiditySourceConfig &&
          runtimeType == other.runtimeType &&
          lsps2Service == other.lsps2Service;
}

/// An enum representing the available verbosity levels of the logger.
///
enum LogLevel {
  /// Designates extremely verbose information, including gossip-induced messages
  ///
  gossip,

  /// Designates very low priority, often extremely verbose, information
  ///
  trace,

  /// Designates lower priority information
  ///
  debug,

  /// Designates useful information
  ///
  info,

  /// Designates hazardous situations
  ///
  warn,

  /// Designates very serious errors
  ///
  error,
  ;
}

/// Limits applying to how much fee we allow an LSP to deduct from the payment amount.
class LSPFeeLimits {
  /// The maximal total amount we allow any configured LSP withhold from us when forwarding the
  /// payment.
  final BigInt? maxTotalOpeningFeeMsat;

  /// The maximal proportional fee, in parts-per-million millisatoshi, we allow any configured
  /// LSP withhold from us when forwarding the payment.
  final BigInt? maxProportionalOpeningFeePpmMsat;

  const LSPFeeLimits({
    this.maxTotalOpeningFeeMsat,
    this.maxProportionalOpeningFeePpmMsat,
  });

  /// Creates conservative LSP fee limits.
  static Future<LSPFeeLimits> conservative() =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsConservative();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new LSPFeeLimits.
  static Future<LSPFeeLimits> newInstance(
          {BigInt? maxTotalOpeningFeeMsat,
          BigInt? maxProportionalOpeningFeePpmMsat}) =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsNew(
          maxTotalOpeningFeeMsat: maxTotalOpeningFeeMsat,
          maxProportionalOpeningFeePpmMsat: maxProportionalOpeningFeePpmMsat);

  /// Creates permissive LSP fee limits.
  static Future<LSPFeeLimits> permissive() =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsPermissive();

  /// Creates unlimited LSP fee limits (no limits).
  static Future<LSPFeeLimits> unlimited() =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsUnlimited();

  @override
  int get hashCode =>
      maxTotalOpeningFeeMsat.hashCode ^
      maxProportionalOpeningFeePpmMsat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LSPFeeLimits &&
          runtimeType == other.runtimeType &&
          maxTotalOpeningFeeMsat == other.maxTotalOpeningFeeMsat &&
          maxProportionalOpeningFeePpmMsat ==
              other.maxProportionalOpeningFeePpmMsat;
}

/// A user-defined name for a node, which may be used when displaying the node in a graph.
///
/// Since node aliases are provided by third parties, they are a potential avenue for injection
/// attacks. Care must be taken when processing.
class NodeAlias {
  final U8Array32 field0;

  const NodeAlias({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeAlias &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Represents the status of the [`Node`].
class NodeStatus {
  /// Indicates whether the `Node` is running.
  final bool isRunning;

  /// Indicates whether the `Node` is listening for incoming connections on the addresses
  final bool isListening;

  /// The best block to which our Lightning wallet is currently synced.
  final BestBlock currentBestBlock;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully synced
  /// our Lightning wallet to the chain tip.
  ///
  /// Will be `None` if the wallet hasn't been synced yet.
  final BigInt? latestLightningWalletSyncTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully synced
  /// our on-chain wallet to the chain tip.
  ///
  /// Will be `None` if the wallet hasn't been synced yet.
  final BigInt? latestOnchainWalletSyncTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully update
  /// our fee rate cache.
  ///
  /// Will be `None` if the cache hasn't been updated yet.
  final BigInt? latestFeeRateCacheUpdateTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when the last rapid gossip sync
  /// (RGS) snapshot we successfully applied was generated.
  ///
  /// Will be `None` if RGS isn't configured or the snapshot hasn't been updated yet.
  final BigInt? latestRgsSnapshotTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last broadcasted a node
  /// announcement.
  ///
  /// Will be `None` if we have no public channels or we haven't broadcasted yet.
  final BigInt? latestNodeAnnouncementBroadcastTimestamp;

  /// The block height when we last archived closed channel monitor data.
  ///
  /// Will be `None` if we haven't archived any monitors of closed channels yet.
  final int? latestChannelMonitorArchivalHeight;

  const NodeStatus({
    required this.isRunning,
    required this.isListening,
    required this.currentBestBlock,
    this.latestLightningWalletSyncTimestamp,
    this.latestOnchainWalletSyncTimestamp,
    this.latestFeeRateCacheUpdateTimestamp,
    this.latestRgsSnapshotTimestamp,
    this.latestNodeAnnouncementBroadcastTimestamp,
    this.latestChannelMonitorArchivalHeight,
  });

  @override
  int get hashCode =>
      isRunning.hashCode ^
      isListening.hashCode ^
      currentBestBlock.hashCode ^
      latestLightningWalletSyncTimestamp.hashCode ^
      latestOnchainWalletSyncTimestamp.hashCode ^
      latestFeeRateCacheUpdateTimestamp.hashCode ^
      latestRgsSnapshotTimestamp.hashCode ^
      latestNodeAnnouncementBroadcastTimestamp.hashCode ^
      latestChannelMonitorArchivalHeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeStatus &&
          runtimeType == other.runtimeType &&
          isRunning == other.isRunning &&
          isListening == other.isListening &&
          currentBestBlock == other.currentBestBlock &&
          latestLightningWalletSyncTimestamp ==
              other.latestLightningWalletSyncTimestamp &&
          latestOnchainWalletSyncTimestamp ==
              other.latestOnchainWalletSyncTimestamp &&
          latestFeeRateCacheUpdateTimestamp ==
              other.latestFeeRateCacheUpdateTimestamp &&
          latestRgsSnapshotTimestamp == other.latestRgsSnapshotTimestamp &&
          latestNodeAnnouncementBroadcastTimestamp ==
              other.latestNodeAnnouncementBroadcastTimestamp &&
          latestChannelMonitorArchivalHeight ==
              other.latestChannelMonitorArchivalHeight;
}

class OfferId {
  final U8Array32 field0;

  const OfferId({
    required this.field0,
  });

  /// Returns the offer ID as bytes.
  Future<void> asBytes() => core.instance.api.ldkAdapterTypesOfferIdAsBytes(
        that: this,
      );

  /// Creates a new OfferId from a byte slice.
  /// Returns None if the slice is not exactly 32 bytes.
  static Future<OfferId?> fromBytes({required List<int> bytes}) =>
      core.instance.api.ldkAdapterTypesOfferIdFromBytes(bytes: bytes);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new OfferId from a 32-byte array.
  static Future<OfferId> newInstance({required U8Array32 data}) =>
      core.instance.api.ldkAdapterTypesOfferIdNew(data: data);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OfferId &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Represents a payment.
class PaymentDetails {
  /// The identifier of this payment.
  final PaymentId id;

  /// The kind of the payment.
  final PaymentKind kind;

  /// The amount transferred.
  final BigInt? amountMsat;

  /// The direction of the payment.
  final PaymentDirection direction;

  /// The status of the payment.
  final PaymentStatus status;

  /// The timestamp, in seconds since start of the UNIX epoch, when this entry was last updated.
  final BigInt latestUpdateTimestamp;

  const PaymentDetails({
    required this.id,
    required this.kind,
    this.amountMsat,
    required this.direction,
    required this.status,
    required this.latestUpdateTimestamp,
  });

  /// Checks if the payment failed.
  Future<bool> isFailed() =>
      core.instance.api.ldkAdapterTypesPaymentDetailsIsFailed(
        that: this,
      );

  /// Checks if the payment is pending.
  Future<bool> isPending() =>
      core.instance.api.ldkAdapterTypesPaymentDetailsIsPending(
        that: this,
      );

  /// Checks if the payment is successful.
  Future<bool> isSucceeded() =>
      core.instance.api.ldkAdapterTypesPaymentDetailsIsSucceeded(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new PaymentDetails.
  static Future<PaymentDetails> newInstance(
          {required PaymentId id,
          required PaymentKind kind,
          BigInt? amountMsat,
          required PaymentDirection direction,
          required PaymentStatus status,
          required BigInt latestUpdateTimestamp}) =>
      core.instance.api.ldkAdapterTypesPaymentDetailsNew(
          id: id,
          kind: kind,
          amountMsat: amountMsat,
          direction: direction,
          status: status,
          latestUpdateTimestamp: latestUpdateTimestamp);

  /// Creates a new pending inbound payment.
  static Future<PaymentDetails> newInboundPending(
          {required PaymentId id,
          required PaymentKind kind,
          BigInt? amountMsat}) =>
      core.instance.api.ldkAdapterTypesPaymentDetailsNewInboundPending(
          id: id, kind: kind, amountMsat: amountMsat);

  /// Creates a new pending outbound payment.
  static Future<PaymentDetails> newOutboundPending(
          {required PaymentId id,
          required PaymentKind kind,
          BigInt? amountMsat}) =>
      core.instance.api.ldkAdapterTypesPaymentDetailsNewOutboundPending(
          id: id, kind: kind, amountMsat: amountMsat);

  @override
  int get hashCode =>
      id.hashCode ^
      kind.hashCode ^
      amountMsat.hashCode ^
      direction.hashCode ^
      status.hashCode ^
      latestUpdateTimestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentDetails &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          kind == other.kind &&
          amountMsat == other.amountMsat &&
          direction == other.direction &&
          status == other.status &&
          latestUpdateTimestamp == other.latestUpdateTimestamp;
}

/// Represents the direction of a payment.
///
enum PaymentDirection {
  /// The payment is inbound.
  inbound,

  /// The payment is outbound.
  outbound,
  ;
}

/// The reason the payment failed. Used in `Event.PaymentFailed`.
enum PaymentFailureReason {
  /// The intended recipient rejected our payment.
  recipientRejected,

  /// The user chose to abandon this payment by calling `channelManager.abandon_payment`.
  ///
  userAbandoned,

  /// We exhausted all of our retry attempts while trying to send the payment, or we
  /// exhausted the `Retry.Timeout` if the user set one. If at any point a retry
  /// attempt failed while being forwarded along the path, an `Event::PaymentPathFailed` will
  /// have come before this.
  ///
  retriesExhausted,

  /// The payment expired while retrying, based on the provided
  paymentExpired,

  /// We failed to find a route while retrying the payment.
  routeNotFound,

  /// This error should generally never happen. This likely means that there is a problem with
  /// your router.
  unexpectedError,

  ///An invoice was received that required unknown features.
  unknownRequiredFeatures,

  ///A Bolt12Invoice was not received in a reasonable amount of time.
  invoiceRequestExpired,

  ///An InvoiceRequest for the payment was rejected by the recipient.
  invoiceRequestRejected,

  ///A BlindedPath creation failed.
  blindedPathCreationFailed,
  ;
}

@freezed
sealed class PaymentKind with _$PaymentKind {
  const PaymentKind._();

  /// An on-chain payment.
  const factory PaymentKind.onchain({
    /// The transaction ID of the on-chain payment.
    required Txid txid,

    /// The status of the on-chain payment.
    required ConfirmationStatus status,
  }) = PaymentKind_Onchain;

  /// A [BOLT 11] payment.
  ///
  /// [BOLT 11]: https://github.com/lightning/bolts/blob/master/11-payment-encoding.md
  const factory PaymentKind.bolt11({
    /// The payment hash, i.e., the hash of the `preimage`.
    required PaymentHash hash,

    /// The pre-image used by the payment.
    PaymentPreimage? preimage,

    /// The secret used by the payment.
    PaymentSecret? secret,
  }) = PaymentKind_Bolt11;

  /// A [BOLT 11] payment intended to open an [LSPS 2] just-in-time channel.
  ///
  /// [BOLT 11]: https://github.com/lightning/bolts/blob/master/11-payment-encoding.md
  /// [LSPS 2]: https://github.com/BitcoinAndLightningLayerSpecs/lsp/blob/main/LSPS2/README.md
  const factory PaymentKind.bolt11Jit({
    /// The payment hash, i.e., the hash of the `preimage`.
    required PaymentHash hash,

    /// The pre-image used by the payment.
    PaymentPreimage? preimage,

    /// The secret used by the payment.
    PaymentSecret? secret,

    /// Limits applying to how much fee we allow an LSP to deduct from the payment amount.
    ///
    /// Allowing them to deduct this fee from the first inbound payment will pay for the LSP's
    /// channel opening fees.
    ///
    required LSPFeeLimits lspFeeLimits,

    /// The value, in thousands of a satoshi, that was deducted from this payment as an extra
    /// fee taken by our channel counterparty.
    ///
    /// Will only be `Some` once we received the payment. Will always be `None` for LDK Node
    /// v0.4 and prior.
    BigInt? counterpartySkimmedFeeMsat,
  }) = PaymentKind_Bolt11Jit;

  /// A spontaneous ("keysend") payment.
  const factory PaymentKind.spontaneous({
    /// The payment hash, i.e., the hash of the `preimage`.
    required PaymentHash hash,

    /// The pre-image used by the payment.
    PaymentPreimage? preimage,
  }) = PaymentKind_Spontaneous;

  /// A [BOLT 12] offer payment, i.e., a payment for an `Offer`.
  ///
  /// [BOLT 12]: https://github.com/lightning/bolts/blob/master/12-offer-encoding.md
  const factory PaymentKind.bolt12Offer({
    /// The payment hash, i.e., the hash of the `preimage`.
    PaymentHash? hash,

    /// The pre-image used by the payment.
    PaymentPreimage? preimage,

    /// The secret used by the payment.
    PaymentSecret? secret,

    /// The ID of the offer this payment is for.
    required OfferId offerId,

    /// The payer note for the payment.
    ///
    /// Truncated to `PAYER_NOTE_LIMIT` characters.
    ///
    /// This will always be `None` for payments serialized with version `v0.3.0`.
    String? payerNote,

    /// The quantity of an item requested in the offer.
    ///
    /// This will always be `None` for payments serialized with version `v0.3.0`.
    BigInt? quantity,
  }) = PaymentKind_Bolt12Offer;

  /// A [BOLT 12] 'refund' payment, i.e., a payment for a `Refund`.
  ///
  /// [BOLT 12]: https://github.com/lightning/bolts/blob/master/12-offer-encoding.md
  const factory PaymentKind.bolt12Refund({
    /// The payment hash, i.e., the hash of the `preimage`.
    PaymentHash? hash,

    /// The pre-image used by the payment.
    PaymentPreimage? preimage,

    /// The secret used by the payment.
    PaymentSecret? secret,

    ///
    /// This will always be `None` for payments serialized with version `v0.3.0`.
    String? payerNote,

    /// The quantity of an item that the refund is for.
    ///
    /// This will always be `None` for payments serialized with version `v0.3.0`.
    BigInt? quantity,
  }) = PaymentKind_Bolt12Refund;
}

/// payment_secret type, use to authenticate sender to the receiver and tie MPP HTLCs together
///
class PaymentSecret {
  final U8Array32 data;

  const PaymentSecret({
    required this.data,
  });

  /// Returns the payment secret as bytes.
  Future<void> asBytes() =>
      core.instance.api.ldkAdapterTypesPaymentSecretAsBytes(
        that: this,
      );

  /// Creates a new PaymentSecret from a byte slice.
  /// Returns None if the slice is not exactly 32 bytes.
  static Future<PaymentSecret?> fromBytes({required List<int> bytes}) =>
      core.instance.api.ldkAdapterTypesPaymentSecretFromBytes(bytes: bytes);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new PaymentSecret from a 32-byte array.
  static Future<PaymentSecret> newInstance({required U8Array32 data}) =>
      core.instance.api.ldkAdapterTypesPaymentSecretNew(data: data);

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentSecret &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// Represents the current status of a payment.
///
enum PaymentStatus {
  /// The payment is still pending.
  pending,

  /// The payment suceeded.
  succeeded,

  /// The payment failed.
  failed,
  ;
}

@freezed
sealed class PendingSweepBalance with _$PendingSweepBalance {
  const PendingSweepBalance._();

  /// The spendable output is about to be swept, but a spending transaction has yet to be generated and
  /// broadcast.
  const factory PendingSweepBalance.pendingBroadcast({
    /// The identifier of the channel this balance belongs to.
    ChannelId? channelId,

    /// The amount, in satoshis, of the output being swept.
    required BigInt amountSatoshis,
  }) = PendingSweepBalance_PendingBroadcast;

  /// A spending transaction has been generated and broadcast and is awaiting confirmation
  /// on-chain.
  const factory PendingSweepBalance.broadcastAwaitingConfirmation({
    /// The identifier of the channel this balance belongs to.
    ChannelId? channelId,

    /// The best height when we last broadcast a transaction spending the output being swept.
    required int latestBroadcastHeight,

    /// The identifier of the transaction spending the swept output we last broadcast.
    required Txid latestSpendingTxid,

    /// The amount, in satoshis, of the output being swept.
    required BigInt amountSatoshis,
  }) = PendingSweepBalance_BroadcastAwaitingConfirmation;

  /// A spending transaction has been confirmed on-chain and is awaiting threshold confirmations.
  ///
  /// It will be considered irrevocably confirmed after reaching [`ANTI_REORG_DELAY`].
  ///
  /// [`ANTI_REORG_DELAY`]: lightning::chain::channelmonitor::ANTI_REORG_DELAY
  const factory PendingSweepBalance.awaitingThresholdConfirmations({
    /// The identifier of the channel this balance belongs to.
    ChannelId? channelId,

    /// The identifier of the confirmed transaction spending the swept output.
    required Txid latestSpendingTxid,

    /// The hash of the block in which the spending transaction was confirmed.
    required String confirmationHash,

    /// The height at which the spending transaction was confirmed.
    required int confirmationHeight,

    /// The amount, in satoshis, of the output being swept.
    required BigInt amountSatoshis,
  }) = PendingSweepBalance_AwaitingThresholdConfirmations;
}
