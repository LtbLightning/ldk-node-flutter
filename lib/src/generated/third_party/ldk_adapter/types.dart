// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import '../shared.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BackgroundSyncConfig`, `BalanceSource`, `ClosureReason`, `ConfirmationStatus`, `ElectrumSyncConfig`, `EsploraSyncConfig`, `MaxTotalRoutingFeeLimit`, `PaymentFailureReason`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `hash`, `hash`, `try_from`, `try_from`, `try_from`

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>>
abstract class AnchorChannelsConfig implements RustOpaqueInterface {
  /// Adds a trusted peer to the configuration.
  Future<void> addTrustedPeer({required PublicKey peer});

  BigInt get perChannelReserveSats;

  List<PublicKey> get trustedPeersNoReserve;

  set perChannelReserveSats(BigInt perChannelReserveSats);

  set trustedPeersNoReserve(List<PublicKey> trustedPeersNoReserve);

  /// Creates a conservative AnchorChannelsConfig with no trusted peers and high reserve.
  static Future<AnchorChannelsConfig> conservative() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigConservative();

  static Future<AnchorChannelsConfig> default_() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigDefault();

  /// Checks if a peer is trusted (no reserve required).
  Future<bool> isPeerTrusted({required PublicKey peer});

  /// Creates a more aggressive AnchorChannelsConfig with lower reserve.
  static Future<AnchorChannelsConfig> lowReserve() =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigLowReserve();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new AnchorChannelsConfig.
  static Future<AnchorChannelsConfig> newInstance(
          {required List<PublicKey> trustedPeersNoReserve,
          required BigInt perChannelReserveSats}) =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigNew(
          trustedPeersNoReserve: trustedPeersNoReserve,
          perChannelReserveSats: perChannelReserveSats);

  /// Removes a trusted peer from the configuration.
  Future<void> removeTrustedPeer({required PublicKey peer});

  /// Returns the number of trusted peers.
  Future<BigInt> trustedPeersCount();

  /// Creates an AnchorChannelsConfig that trusts specific peers with no reserve.
  static Future<AnchorChannelsConfig> withTrustedPeers(
          {required List<PublicKey> trustedPeers}) =>
      core.instance.api.ldkAdapterTypesAnchorChannelsConfigWithTrustedPeers(
          trustedPeers: trustedPeers);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>>
abstract class ChainDataSourceConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
abstract class ChannelConfig implements RustOpaqueInterface {
  bool get acceptUnderpayingHtlcs;

  int get cltvExpiryDelta;

  BigInt get forceCloseAvoidanceMaxFeeSatoshis;

  int get forwardingFeeBaseMsat;

  int get forwardingFeeProportionalMillionths;

  MaxDustHtlcExposure get maxDustHtlcExposure;

  set acceptUnderpayingHtlcs(bool acceptUnderpayingHtlcs);

  set cltvExpiryDelta(int cltvExpiryDelta);

  set forceCloseAvoidanceMaxFeeSatoshis(
      BigInt forceCloseAvoidanceMaxFeeSatoshis);

  set forwardingFeeBaseMsat(int forwardingFeeBaseMsat);

  set forwardingFeeProportionalMillionths(
      int forwardingFeeProportionalMillionths);

  set maxDustHtlcExposure(MaxDustHtlcExposure maxDustHtlcExposure);

  /// Gets the total forwarding fee for a given amount in millisatoshis.
  Future<BigInt> calculateForwardingFee({required BigInt amountMsat});

  /// Creates a high-fee routing configuration.
  static Future<ChannelConfig> highFeeRouting() =>
      core.instance.api.ldkAdapterTypesChannelConfigHighFeeRouting();

  /// Creates a low-fee routing configuration.
  static Future<ChannelConfig> lowFeeRouting() =>
      core.instance.api.ldkAdapterTypesChannelConfigLowFeeRouting();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new ChannelConfig with default values.
  /// Creates a new ChannelConfig with all arguments specified.
  static Future<ChannelConfig> newInstance(
          {required int forwardingFeeProportionalMillionths,
          required int forwardingFeeBaseMsat,
          required int cltvExpiryDelta,
          required MaxDustHtlcExposure maxDustHtlcExposure,
          required BigInt forceCloseAvoidanceMaxFeeSatoshis,
          required bool acceptUnderpayingHtlcs}) =>
      core.instance.api.ldkAdapterTypesChannelConfigNew(
          forwardingFeeProportionalMillionths:
              forwardingFeeProportionalMillionths,
          forwardingFeeBaseMsat: forwardingFeeBaseMsat,
          cltvExpiryDelta: cltvExpiryDelta,
          maxDustHtlcExposure: maxDustHtlcExposure,
          forceCloseAvoidanceMaxFeeSatoshis: forceCloseAvoidanceMaxFeeSatoshis,
          acceptUnderpayingHtlcs: acceptUnderpayingHtlcs);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
abstract class ChannelDetails implements RustOpaqueInterface {
  ChannelId get channelId;

  BigInt get channelValueSats;

  int? get cltvExpiryDelta;

  ChannelConfig get config;

  int? get confirmations;

  int? get confirmationsRequired;

  int? get counterpartyForwardingInfoCltvExpiryDelta;

  int? get counterpartyForwardingInfoFeeBaseMsat;

  int? get counterpartyForwardingInfoFeeProportionalMillionths;

  PublicKey get counterpartyNodeId;

  BigInt? get counterpartyOutboundHtlcMaximumMsat;

  BigInt? get counterpartyOutboundHtlcMinimumMsat;

  BigInt get counterpartyUnspendablePunishmentReserve;

  int get feerateSatPer1000Weight;

  int? get forceCloseSpendDelay;

  OutPoint? get fundingTxo;

  BigInt get inboundCapacityMsat;

  BigInt? get inboundHtlcMaximumMsat;

  BigInt get inboundHtlcMinimumMsat;

  bool get isChannelReady;

  bool get isOutbound;

  bool get isUsable;

  BigInt get nextOutboundHtlcLimitMsat;

  BigInt get nextOutboundHtlcMinimumMsat;

  BigInt get outboundCapacityMsat;

  BigInt? get unspendablePunishmentReserve;

  UserChannelId get userChannelId;

  set channelId(ChannelId channelId);

  set channelValueSats(BigInt channelValueSats);

  set cltvExpiryDelta(int? cltvExpiryDelta);

  set config(ChannelConfig config);

  set confirmations(int? confirmations);

  set confirmationsRequired(int? confirmationsRequired);

  set counterpartyForwardingInfoCltvExpiryDelta(
      int? counterpartyForwardingInfoCltvExpiryDelta);

  set counterpartyForwardingInfoFeeBaseMsat(
      int? counterpartyForwardingInfoFeeBaseMsat);

  set counterpartyForwardingInfoFeeProportionalMillionths(
      int? counterpartyForwardingInfoFeeProportionalMillionths);

  set counterpartyNodeId(PublicKey counterpartyNodeId);

  set counterpartyOutboundHtlcMaximumMsat(
      BigInt? counterpartyOutboundHtlcMaximumMsat);

  set counterpartyOutboundHtlcMinimumMsat(
      BigInt? counterpartyOutboundHtlcMinimumMsat);

  set counterpartyUnspendablePunishmentReserve(
      BigInt counterpartyUnspendablePunishmentReserve);

  set feerateSatPer1000Weight(int feerateSatPer1000Weight);

  set forceCloseSpendDelay(int? forceCloseSpendDelay);

  set fundingTxo(OutPoint? fundingTxo);

  set inboundCapacityMsat(BigInt inboundCapacityMsat);

  set inboundHtlcMaximumMsat(BigInt? inboundHtlcMaximumMsat);

  set inboundHtlcMinimumMsat(BigInt inboundHtlcMinimumMsat);

  set isChannelReady(bool isChannelReady);

  set isOutbound(bool isOutbound);

  set isUsable(bool isUsable);

  set nextOutboundHtlcLimitMsat(BigInt nextOutboundHtlcLimitMsat);

  set nextOutboundHtlcMinimumMsat(BigInt nextOutboundHtlcMinimumMsat);

  set outboundCapacityMsat(BigInt outboundCapacityMsat);

  set unspendablePunishmentReserve(BigInt? unspendablePunishmentReserve);

  set userChannelId(UserChannelId userChannelId);

  /// Returns the balance ratio (outbound / total) as a percentage.
  Future<double> balanceRatioPercent();

  /// Checks if the channel can receive the specified amount in millisatoshis.
  Future<bool> canReceive({required BigInt amountMsat});

  /// Checks if the channel can send the specified amount in millisatoshis.
  Future<bool> canSend({required BigInt amountMsat});

  /// Returns the total channel capacity in satoshis.
  Future<BigInt> capacitySats();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new ChannelDetails (mainly for testing purposes).
  static Future<ChannelDetails> newInstance(
          {required ChannelId channelId,
          required PublicKey counterpartyNodeId,
          OutPoint? fundingTxo,
          required BigInt channelValueSats,
          BigInt? unspendablePunishmentReserve,
          required UserChannelId userChannelId,
          required int feerateSatPer1000Weight,
          required BigInt outboundCapacityMsat,
          required BigInt inboundCapacityMsat,
          required bool isOutbound,
          required bool isChannelReady,
          required bool isUsable,
          required ChannelConfig config}) =>
      core.instance.api.ldkAdapterTypesChannelDetailsNew(
          channelId: channelId,
          counterpartyNodeId: counterpartyNodeId,
          fundingTxo: fundingTxo,
          channelValueSats: channelValueSats,
          unspendablePunishmentReserve: unspendablePunishmentReserve,
          userChannelId: userChannelId,
          feerateSatPer1000Weight: feerateSatPer1000Weight,
          outboundCapacityMsat: outboundCapacityMsat,
          inboundCapacityMsat: inboundCapacityMsat,
          isOutbound: isOutbound,
          isChannelReady: isChannelReady,
          isUsable: isUsable,
          config: config);

  /// Returns the total available liquidity (inbound + outbound) in millisatoshis.
  Future<BigInt> totalLiquidityMsat();
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>>
abstract class EntropySourceConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>
abstract class Event implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>>
abstract class GossipSourceConfig implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>
abstract class LightningBalance implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>
abstract class MaxDustHtlcExposure implements RustOpaqueInterface {
  /// Creates a conservative fixed limit (1 million msat).
  static Future<MaxDustHtlcExposure> conservative() =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureConservative();

  /// Creates a default fee rate multiplier configuration.
  static Future<MaxDustHtlcExposure> defaultFeeRate() =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureDefaultFeeRate();

  /// Creates a new MaxDustHTLCExposure with a fee rate multiplier.
  static Future<MaxDustHtlcExposure> newFeeRateMultiplier(
          {required BigInt multiplier}) =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureNewFeeRateMultiplier(
          multiplier: multiplier);

  /// Creates a new MaxDustHTLCExposure with a fixed limit in millisatoshis.
  static Future<MaxDustHtlcExposure> newFixedLimit(
          {required BigInt limitMsat}) =>
      core.instance.api.ldkAdapterTypesMaxDustHtlcExposureNewFixedLimit(
          limitMsat: limitMsat);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>
abstract class PaymentDetails implements RustOpaqueInterface {
  BigInt? get amountMsat;

  PaymentDirection get direction;

  PaymentId get id;

  PaymentKind get kind;

  BigInt get latestUpdateTimestamp;

  PaymentStatus get status;

  set amountMsat(BigInt? amountMsat);

  set direction(PaymentDirection direction);

  set id(PaymentId id);

  set kind(PaymentKind kind);

  set latestUpdateTimestamp(BigInt latestUpdateTimestamp);

  set status(PaymentStatus status);

  /// Checks if the payment failed.
  Future<bool> isFailed();

  /// Checks if the payment is pending.
  Future<bool> isPending();

  /// Checks if the payment is successful.
  Future<bool> isSucceeded();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new PaymentDetails.
  static Future<PaymentDetails> newInstance(
          {required PaymentId id,
          required PaymentKind kind,
          BigInt? amountMsat,
          required PaymentDirection direction,
          required PaymentStatus status,
          required BigInt latestUpdateTimestamp}) =>
      core.instance.api.ldkAdapterTypesPaymentDetailsNew(
          id: id,
          kind: kind,
          amountMsat: amountMsat,
          direction: direction,
          status: status,
          latestUpdateTimestamp: latestUpdateTimestamp);

  /// Creates a new pending inbound payment.
  static Future<PaymentDetails> newInboundPending(
          {required PaymentId id,
          required PaymentKind kind,
          BigInt? amountMsat}) =>
      core.instance.api.ldkAdapterTypesPaymentDetailsNewInboundPending(
          id: id, kind: kind, amountMsat: amountMsat);

  /// Creates a new pending outbound payment.
  static Future<PaymentDetails> newOutboundPending(
          {required PaymentId id,
          required PaymentKind kind,
          BigInt? amountMsat}) =>
      core.instance.api.ldkAdapterTypesPaymentDetailsNewOutboundPending(
          id: id, kind: kind, amountMsat: amountMsat);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>
abstract class PaymentKind implements RustOpaqueInterface {}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
abstract class PeerDetails implements RustOpaqueInterface {
  SocketAddress get address;

  bool get isConnected;

  PublicKey get nodeId;

  set address(SocketAddress address);

  set isConnected(bool isConnected);

  set nodeId(PublicKey nodeId);

  /// Checks if the peer is currently disconnected.
  Future<bool> isOffline();

  /// Checks if the peer is currently connected.
  Future<bool> isOnline();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new PeerDetails.
  static Future<PeerDetails> newInstance(
          {required PublicKey nodeId,
          required SocketAddress address,
          required bool isConnected}) =>
      core.instance.api.ldkAdapterTypesPeerDetailsNew(
          nodeId: nodeId, address: address, isConnected: isConnected);

  /// Creates a new connected peer.
  static Future<PeerDetails> newConnected(
          {required PublicKey nodeId, required SocketAddress address}) =>
      core.instance.api.ldkAdapterTypesPeerDetailsNewConnected(
          nodeId: nodeId, address: address);

  /// Creates a new disconnected peer.
  static Future<PeerDetails> newDisconnected(
          {required PublicKey nodeId, required SocketAddress address}) =>
      core.instance.api.ldkAdapterTypesPeerDetailsNewDisconnected(
          nodeId: nodeId, address: address);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>
abstract class PendingSweepBalance implements RustOpaqueInterface {}

abstract class FfiLogWriter {
  /// Handle a log record.
  Future<void> log({required FfiLogRecord record});
}

/// Details of the known available balances returned by `node.listBalances`.
///
class BalanceDetails {
  /// The total balance of our on-chain wallet.
  final BigInt totalOnchainBalanceSats;

  /// The currently spendable balance of our on-chain wallet.
  final BigInt spendableOnchainBalanceSats;

  /// The total balance that we would be able to claim across all our Lightning channels.
  ///
  /// Note this excludes balances that we are unsure if we are able to claim (e.g., as we are
  final BigInt totalLightningBalanceSats;

  /// A detailed list of all known Lightning balances that would be claimable on channel closure.
  ///
  /// Note that less than the listed amounts are spendable over lightning as further reserve
  /// restrictions apply.
  final List<LightningBalance> lightningBalances;

  /// A detailed list of balances currently being swept from the Lightning to the on-chain
  /// wallet.
  ///
  /// These are balances resulting from channel closures that may have been encumbered by a
  /// delay, but are now being claimed and useable once sufficiently confirmed on-chain.
  ///
  /// Note that, depending on the sync status of the wallets, swept balances listed here might or
  /// might not already be accounted for in `totalOnchainBalanceSats`.
  final List<PendingSweepBalance> pendingBalancesFromChannelClosures;

  const BalanceDetails({
    required this.totalOnchainBalanceSats,
    required this.spendableOnchainBalanceSats,
    required this.totalLightningBalanceSats,
    required this.lightningBalances,
    required this.pendingBalancesFromChannelClosures,
  });

  @override
  int get hashCode =>
      totalOnchainBalanceSats.hashCode ^
      spendableOnchainBalanceSats.hashCode ^
      totalLightningBalanceSats.hashCode ^
      lightningBalances.hashCode ^
      pendingBalancesFromChannelClosures.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BalanceDetails &&
          runtimeType == other.runtimeType &&
          totalOnchainBalanceSats == other.totalOnchainBalanceSats &&
          spendableOnchainBalanceSats == other.spendableOnchainBalanceSats &&
          totalLightningBalanceSats == other.totalLightningBalanceSats &&
          lightningBalances == other.lightningBalances &&
          pendingBalancesFromChannelClosures ==
              other.pendingBalancesFromChannelClosures;
}

/// The best known block as identified by its hash and height.
class BestBlock {
  /// The block's hash
  final String blockHash;

  /// The height at which the block was confirmed.
  final int height;

  const BestBlock({
    required this.blockHash,
    required this.height,
  });

  @override
  int get hashCode => blockHash.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BestBlock &&
          runtimeType == other.runtimeType &&
          blockHash == other.blockHash &&
          height == other.height;
}

/// The global identifier of a channel.
///
/// Note that this will start out to be a temporary ID until channel funding negotiation is
/// finalized, at which point it will change to be a permanent global ID tied to the on-chain
/// funding transaction.
///
class ChannelId {
  final U8Array32 data;

  const ChannelId({
    required this.data,
  });

  /// Returns the channel ID as bytes.
  Future<void> asBytes() => core.instance.api.ldkAdapterTypesChannelIdAsBytes(
        that: this,
      );

  /// Creates a new ChannelId from a byte slice.
  /// Returns None if the slice is not exactly 32 bytes.
  static Future<ChannelId?> fromBytes({required List<int> bytes}) =>
      core.instance.api.ldkAdapterTypesChannelIdFromBytes(bytes: bytes);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new ChannelId from a 32-byte array.
  static Future<ChannelId> newInstance({required U8Array32 data}) =>
      core.instance.api.ldkAdapterTypesChannelIdNew(data: data);

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelId &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// Represents the configuration of an [Node] instance.
///
class Config {
  final String storageDirPath;

  /// The used Bitcoin network.
  final Network network;

  /// The IP address and TCP port the node will listen on.
  ///
  final List<SocketAddress>? listeningAddresses;

  /// The addresses which the node will announce to the gossip network that it accepts connections on.
  final List<SocketAddress>? announcementAddresses;

  /// The node alias that will be used when broadcasting announcements to the gossip network.
  ///
  /// The provided alias must be a valid UTF-8 string and no longer than 32 bytes in total.
  ///
  /// **Note**: We will only allow opening and accepting public channels if the `nodeAlias` and the
  /// `listeningAddresses` are set.
  final NodeAlias? nodeAlias;

  ///A list of peers that we allow to establish zero confirmation channels to us.
  ///
  ///Note: Allowing payments via zero-confirmation channels is potentially insecure if the funding transaction ends up never being confirmed on-chain. Zero-confirmation channels should therefore only be accepted from trusted peers.
  final List<PublicKey> trustedPeers0Conf;
  final BigInt probingLiquidityLimitMultiplier;

  ///The level at which we log messages.
  /// Any messages below this level will be excluded from the logs.
  ///
  final AnchorChannelsConfig? anchorChannelsConfig;

  /// Configuration options for payment routing and pathfinding.
  ///
  /// Setting the `SendingParameters` provides flexibility to customize how payments are routed,
  /// including setting limits on routing fees, CLTV expiry, and channel utilization.
  ///
  /// **Note:** If unset, default parameters will be used, and you will be able to override the
  /// parameters on a per-payment basis in the corresponding method calls.
  final SendingParameters? sendingParameters;

  const Config({
    required this.storageDirPath,
    required this.network,
    this.listeningAddresses,
    this.announcementAddresses,
    this.nodeAlias,
    required this.trustedPeers0Conf,
    required this.probingLiquidityLimitMultiplier,
    this.anchorChannelsConfig,
    this.sendingParameters,
  });

  static Future<Config> default_() =>
      core.instance.api.ldkAdapterTypesConfigDefault();

  @override
  int get hashCode =>
      storageDirPath.hashCode ^
      network.hashCode ^
      listeningAddresses.hashCode ^
      announcementAddresses.hashCode ^
      nodeAlias.hashCode ^
      trustedPeers0Conf.hashCode ^
      probingLiquidityLimitMultiplier.hashCode ^
      anchorChannelsConfig.hashCode ^
      sendingParameters.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Config &&
          runtimeType == other.runtimeType &&
          storageDirPath == other.storageDirPath &&
          network == other.network &&
          listeningAddresses == other.listeningAddresses &&
          announcementAddresses == other.announcementAddresses &&
          nodeAlias == other.nodeAlias &&
          trustedPeers0Conf == other.trustedPeers0Conf &&
          probingLiquidityLimitMultiplier ==
              other.probingLiquidityLimitMultiplier &&
          anchorChannelsConfig == other.anchorChannelsConfig &&
          sendingParameters == other.sendingParameters;
}

/// A Custom TLV entry.
class CustomTlvRecord {
  /// Type number.
  final BigInt typeNum;

  /// Serialized value.
  final Uint8List value;

  const CustomTlvRecord({
    required this.typeNum,
    required this.value,
  });

  /// Creates a new CustomTlvRecord from a string value.
  static Future<CustomTlvRecord> fromString(
          {required BigInt typeNum, required String value}) =>
      core.instance.api.ldkAdapterTypesCustomTlvRecordFromString(
          typeNum: typeNum, value: value);

  /// Creates a new CustomTlvRecord from a u64 value.
  static Future<CustomTlvRecord> fromU64(
          {required BigInt typeNum, required BigInt value}) =>
      core.instance.api.ldkAdapterTypesCustomTlvRecordFromU64(
          typeNum: typeNum, value: value);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new CustomTlvRecord.
  static Future<CustomTlvRecord> newInstance(
          {required BigInt typeNum, required List<int> value}) =>
      core.instance.api
          .ldkAdapterTypesCustomTlvRecordNew(typeNum: typeNum, value: value);

  /// Returns the value as a string if it's valid UTF-8.
  Future<String?> valueAsString() =>
      core.instance.api.ldkAdapterTypesCustomTlvRecordValueAsString(
        that: this,
      );

  @override
  int get hashCode => typeNum.hashCode ^ value.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CustomTlvRecord &&
          runtimeType == other.runtimeType &&
          typeNum == other.typeNum &&
          value == other.value;
}

/// A unit of logging output with metadata to enable filtering by module path and line number.
class FfiLogRecord {
  /// The verbosity level of the message.
  final LogLevel level;

  /// The message body.
  final String args;

  /// The module path of the message.
  final String modulePath;

  /// The line containing the message.
  final int line;

  const FfiLogRecord({
    required this.level,
    required this.args,
    required this.modulePath,
    required this.line,
  });

  /// Creates a new debug log record.
  static Future<FfiLogRecord> debug(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordDebug(
          args: args, modulePath: modulePath, line: line);

  /// Creates a new error log record.
  static Future<FfiLogRecord> error(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordError(
          args: args, modulePath: modulePath, line: line);

  /// Returns a formatted log message.
  Future<String> formatted() =>
      core.instance.api.ldkAdapterTypesFfiLogRecordFormatted(
        that: this,
      );

  /// Creates a new info log record.
  static Future<FfiLogRecord> info(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordInfo(
          args: args, modulePath: modulePath, line: line);

  /// Checks if this is an error log.
  Future<bool> isError() =>
      core.instance.api.ldkAdapterTypesFfiLogRecordIsError(
        that: this,
      );

  /// Checks if this is a warning log.
  Future<bool> isWarn() => core.instance.api.ldkAdapterTypesFfiLogRecordIsWarn(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new FfiLogRecord.
  static Future<FfiLogRecord> newInstance(
          {required LogLevel level,
          required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordNew(
          level: level, args: args, modulePath: modulePath, line: line);

  /// Creates a new trace log record.
  static Future<FfiLogRecord> trace(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordTrace(
          args: args, modulePath: modulePath, line: line);

  /// Creates a new warning log record.
  static Future<FfiLogRecord> warn(
          {required String args,
          required String modulePath,
          required int line}) =>
      core.instance.api.ldkAdapterTypesFfiLogRecordWarn(
          args: args, modulePath: modulePath, line: line);

  @override
  int get hashCode =>
      level.hashCode ^ args.hashCode ^ modulePath.hashCode ^ line.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiLogRecord &&
          runtimeType == other.runtimeType &&
          level == other.level &&
          args == other.args &&
          modulePath == other.modulePath &&
          line == other.line;
}

class LiquiditySourceConfig {
  final (SocketAddress, PublicKey, String?) lsps2Service;

  const LiquiditySourceConfig({
    required this.lsps2Service,
  });

  @override
  int get hashCode => lsps2Service.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LiquiditySourceConfig &&
          runtimeType == other.runtimeType &&
          lsps2Service == other.lsps2Service;
}

/// An enum representing the available verbosity levels of the logger.
///
enum LogLevel {
  /// Designates extremely verbose information, including gossip-induced messages
  ///
  gossip,

  /// Designates very low priority, often extremely verbose, information
  ///
  trace,

  /// Designates lower priority information
  ///
  debug,

  /// Designates useful information
  ///
  info,

  /// Designates hazardous situations
  ///
  warn,

  /// Designates very serious errors
  ///
  error,
  ;
}

/// Limits applying to how much fee we allow an LSP to deduct from the payment amount.
class LSPFeeLimits {
  /// The maximal total amount we allow any configured LSP withhold from us when forwarding the
  /// payment.
  final BigInt? maxTotalOpeningFeeMsat;

  /// The maximal proportional fee, in parts-per-million millisatoshi, we allow any configured
  /// LSP withhold from us when forwarding the payment.
  final BigInt? maxProportionalOpeningFeePpmMsat;

  const LSPFeeLimits({
    this.maxTotalOpeningFeeMsat,
    this.maxProportionalOpeningFeePpmMsat,
  });

  /// Creates conservative LSP fee limits.
  static Future<LSPFeeLimits> conservative() =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsConservative();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new LSPFeeLimits.
  static Future<LSPFeeLimits> newInstance(
          {BigInt? maxTotalOpeningFeeMsat,
          BigInt? maxProportionalOpeningFeePpmMsat}) =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsNew(
          maxTotalOpeningFeeMsat: maxTotalOpeningFeeMsat,
          maxProportionalOpeningFeePpmMsat: maxProportionalOpeningFeePpmMsat);

  /// Creates permissive LSP fee limits.
  static Future<LSPFeeLimits> permissive() =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsPermissive();

  /// Creates unlimited LSP fee limits (no limits).
  static Future<LSPFeeLimits> unlimited() =>
      core.instance.api.ldkAdapterTypesLspFeeLimitsUnlimited();

  @override
  int get hashCode =>
      maxTotalOpeningFeeMsat.hashCode ^
      maxProportionalOpeningFeePpmMsat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LSPFeeLimits &&
          runtimeType == other.runtimeType &&
          maxTotalOpeningFeeMsat == other.maxTotalOpeningFeeMsat &&
          maxProportionalOpeningFeePpmMsat ==
              other.maxProportionalOpeningFeePpmMsat;
}

/// A user-defined name for a node, which may be used when displaying the node in a graph.
///
/// Since node aliases are provided by third parties, they are a potential avenue for injection
/// attacks. Care must be taken when processing.
class NodeAlias {
  final U8Array32 field0;

  const NodeAlias({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeAlias &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Represents the status of the [`Node`].
class NodeStatus {
  /// Indicates whether the `Node` is running.
  final bool isRunning;

  /// Indicates whether the `Node` is listening for incoming connections on the addresses
  final bool isListening;

  /// The best block to which our Lightning wallet is currently synced.
  final BestBlock currentBestBlock;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully synced
  /// our Lightning wallet to the chain tip.
  ///
  /// Will be `None` if the wallet hasn't been synced yet.
  final BigInt? latestLightningWalletSyncTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully synced
  /// our on-chain wallet to the chain tip.
  ///
  /// Will be `None` if the wallet hasn't been synced yet.
  final BigInt? latestOnchainWalletSyncTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last successfully update
  /// our fee rate cache.
  ///
  /// Will be `None` if the cache hasn't been updated yet.
  final BigInt? latestFeeRateCacheUpdateTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when the last rapid gossip sync
  /// (RGS) snapshot we successfully applied was generated.
  ///
  /// Will be `None` if RGS isn't configured or the snapshot hasn't been updated yet.
  final BigInt? latestRgsSnapshotTimestamp;

  /// The timestamp, in seconds since start of the UNIX epoch, when we last broadcasted a node
  /// announcement.
  ///
  /// Will be `None` if we have no public channels or we haven't broadcasted yet.
  final BigInt? latestNodeAnnouncementBroadcastTimestamp;

  /// The block height when we last archived closed channel monitor data.
  ///
  /// Will be `None` if we haven't archived any monitors of closed channels yet.
  final int? latestChannelMonitorArchivalHeight;

  const NodeStatus({
    required this.isRunning,
    required this.isListening,
    required this.currentBestBlock,
    this.latestLightningWalletSyncTimestamp,
    this.latestOnchainWalletSyncTimestamp,
    this.latestFeeRateCacheUpdateTimestamp,
    this.latestRgsSnapshotTimestamp,
    this.latestNodeAnnouncementBroadcastTimestamp,
    this.latestChannelMonitorArchivalHeight,
  });

  @override
  int get hashCode =>
      isRunning.hashCode ^
      isListening.hashCode ^
      currentBestBlock.hashCode ^
      latestLightningWalletSyncTimestamp.hashCode ^
      latestOnchainWalletSyncTimestamp.hashCode ^
      latestFeeRateCacheUpdateTimestamp.hashCode ^
      latestRgsSnapshotTimestamp.hashCode ^
      latestNodeAnnouncementBroadcastTimestamp.hashCode ^
      latestChannelMonitorArchivalHeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeStatus &&
          runtimeType == other.runtimeType &&
          isRunning == other.isRunning &&
          isListening == other.isListening &&
          currentBestBlock == other.currentBestBlock &&
          latestLightningWalletSyncTimestamp ==
              other.latestLightningWalletSyncTimestamp &&
          latestOnchainWalletSyncTimestamp ==
              other.latestOnchainWalletSyncTimestamp &&
          latestFeeRateCacheUpdateTimestamp ==
              other.latestFeeRateCacheUpdateTimestamp &&
          latestRgsSnapshotTimestamp == other.latestRgsSnapshotTimestamp &&
          latestNodeAnnouncementBroadcastTimestamp ==
              other.latestNodeAnnouncementBroadcastTimestamp &&
          latestChannelMonitorArchivalHeight ==
              other.latestChannelMonitorArchivalHeight;
}

class OfferId {
  final U8Array32 field0;

  const OfferId({
    required this.field0,
  });

  /// Returns the offer ID as bytes.
  Future<void> asBytes() => core.instance.api.ldkAdapterTypesOfferIdAsBytes(
        that: this,
      );

  /// Creates a new OfferId from a byte slice.
  /// Returns None if the slice is not exactly 32 bytes.
  static Future<OfferId?> fromBytes({required List<int> bytes}) =>
      core.instance.api.ldkAdapterTypesOfferIdFromBytes(bytes: bytes);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new OfferId from a 32-byte array.
  static Future<OfferId> newInstance({required U8Array32 data}) =>
      core.instance.api.ldkAdapterTypesOfferIdNew(data: data);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OfferId &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

/// Represents the direction of a payment.
///
enum PaymentDirection {
  /// The payment is inbound.
  inbound,

  /// The payment is outbound.
  outbound,
  ;
}

/// payment_secret type, use to authenticate sender to the receiver and tie MPP HTLCs together
///
class PaymentSecret {
  final U8Array32 data;

  const PaymentSecret({
    required this.data,
  });

  /// Returns the payment secret as bytes.
  Future<void> asBytes() =>
      core.instance.api.ldkAdapterTypesPaymentSecretAsBytes(
        that: this,
      );

  /// Creates a new PaymentSecret from a byte slice.
  /// Returns None if the slice is not exactly 32 bytes.
  static Future<PaymentSecret?> fromBytes({required List<int> bytes}) =>
      core.instance.api.ldkAdapterTypesPaymentSecretFromBytes(bytes: bytes);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new PaymentSecret from a 32-byte array.
  static Future<PaymentSecret> newInstance({required U8Array32 data}) =>
      core.instance.api.ldkAdapterTypesPaymentSecretNew(data: data);

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaymentSecret &&
          runtimeType == other.runtimeType &&
          data == other.data;
}

/// Represents the current status of a payment.
///
enum PaymentStatus {
  /// The payment is still pending.
  pending,

  /// The payment suceeded.
  succeeded,

  /// The payment failed.
  failed,
  ;
}

///A local, potentially user-provided, identifier of a channel.
///
/// By default, this will be randomly generated for the user to ensure local uniqueness.
///
class UserChannelId {
  final Uint8List data;

  const UserChannelId({
    required this.data,
  });

  /// Returns the data as a byte slice.
  Future<void> asBytes() =>
      core.instance.api.ldkAdapterTypesUserChannelIdAsBytes(
        that: this,
      );

  /// Creates a new UserChannelId from a string.
  static Future<UserChannelId> fromString({required String s}) =>
      core.instance.api.ldkAdapterTypesUserChannelIdFromString(s: s);

  /// Creates a new UserChannelId from a u64.
  static Future<UserChannelId> fromU64({required BigInt id}) =>
      core.instance.api.ldkAdapterTypesUserChannelIdFromU64(id: id);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Creates a new UserChannelId from a byte vector.
  static Future<UserChannelId> newInstance({required List<int> data}) =>
      core.instance.api.ldkAdapterTypesUserChannelIdNew(data: data);

  @override
  int get hashCode => data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserChannelId &&
          runtimeType == other.runtimeType &&
          data == other.data;
}
