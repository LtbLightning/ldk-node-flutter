// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import '../shared.dart';
import 'bolt11.dart';
import 'bolt12.dart';
import 'graph.dart';
import 'on_chain.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'spontaneous.dart';
import 'types.dart';
import 'unified_qr.dart';

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>
abstract class Node implements RustOpaqueInterface {
  static Future<Bolt11Payment> bolt11Payment({required Node ptr}) =>
      core.instance.api.ldkAdapterNodeNodeBolt11Payment(ptr: ptr);

  static Future<Bolt12Payment> bolt12Payment({required Node ptr}) =>
      core.instance.api.ldkAdapterNodeNodeBolt12Payment(ptr: ptr);

  Future<void> closeChannel(
      {required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId});

  Future<Config> config();

  Future<void> connect(
      {required PublicKey nodeId,
      required SocketAddress address,
      required bool persist});

  Future<void> disconnect({required PublicKey counterpartyNodeId});

  Future<void> eventHandled();

  Future<Uint8List> exportPathfindingScores();

  Future<void> forceCloseChannel(
      {required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId});

  Future<BalanceDetails> listBalances();

  Future<List<ChannelDetails>> listChannels();

  Future<List<PaymentDetails>> listPayments();

  Future<List<PaymentDetails>> listPaymentsWithFilter(
      {required PaymentDirection paymentDirection});

  Future<List<PeerDetails>> listPeers();

  Future<List<SocketAddress>?> listeningAddresses();

  static Future<NetworkGraph> networkGraph({required Node ptr}) =>
      core.instance.api.ldkAdapterNodeNodeNetworkGraph(ptr: ptr);

  Future<Event?> nextEvent();

  Future<Event> nextEventAsync();

  Future<PublicKey> nodeId();

  static Future<OnChainPayment> onChainPayment({required Node ptr}) =>
      core.instance.api.ldkAdapterNodeNodeOnChainPayment(ptr: ptr);

  Future<UserChannelId> openAnnouncedChannel(
      {required SocketAddress socketAddress,
      required PublicKey nodeId,
      required BigInt channelAmountSats,
      BigInt? pushToCounterpartyMsat,
      ChannelConfig? channelConfig});

  Future<UserChannelId> openChannel(
      {required SocketAddress socketAddress,
      required PublicKey nodeId,
      required BigInt channelAmountSats,
      BigInt? pushToCounterpartyMsat,
      ChannelConfig? channelConfig});

  Future<PaymentDetails?> payment({required PaymentId paymentId});

  Future<void> removePayment({required PaymentId paymentId});

  Future<String> signMessage({required List<int> msg});

  static Future<SpontaneousPayment> spontaneousPayment({required Node ptr}) =>
      core.instance.api.ldkAdapterNodeNodeSpontaneousPayment(ptr: ptr);

  Future<void> start();

  Future<NodeStatus> status();

  Future<void> stop();

  /// When background sync is left as Null, you can use this to sync manually.
  Future<void> syncWallets();

  static Future<UnifiedQrPayment> unifiedQrPayment({required Node ptr}) =>
      core.instance.api.ldkAdapterNodeNodeUnifiedQrPayment(ptr: ptr);

  Future<void> updateChannelConfig(
      {required UserChannelId userChannelId,
      required PublicKey counterpartyNodeId,
      required ChannelConfig channelConfig});

  Future<bool> verifySignature(
      {required List<int> msg,
      required String sig,
      required PublicKey publicKey});

  Future<Event> waitNextEvent();
}
