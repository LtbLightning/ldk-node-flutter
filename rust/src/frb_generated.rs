// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::builder::*;
use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.4.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 968713453;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__bolt11__ffi_bolt_11_payment_claim_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    payment_hash: impl CstDecode<crate::api::types::PaymentHash>,
    claimable_amount_msat: impl CstDecode<u64>,
    preimage: impl CstDecode<crate::api::types::PaymentPreimage>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_claim_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            let api_claimable_amount_msat = claimable_amount_msat.cst_decode();
            let api_preimage = preimage.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt11::FfiBolt11Payment::claim_for_hash(
                        &api_that,
                        api_payment_hash,
                        api_claimable_amount_msat,
                        api_preimage,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_fail_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    payment_hash: impl CstDecode<crate::api::types::PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_fail_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt11::FfiBolt11Payment::fail_for_hash(
                        &api_that,
                        api_payment_hash,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt11::FfiBolt11Payment::receive(
                        &api_that,
                        api_amount_msat,
                        api_description,
                        api_expiry_secs,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_receive_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    payment_hash: impl CstDecode<crate::api::types::PaymentHash>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_receive_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt11::FfiBolt11Payment::receive_for_hash(
                        &api_that,
                        api_payment_hash,
                        api_amount_msat,
                        api_description,
                        api_expiry_secs,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt11::FfiBolt11Payment::receive_variable_amount(
                        &api_that,
                        api_description,
                        api_expiry_secs,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    payment_hash: impl CstDecode<crate::api::types::PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_receive_variable_amount_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok =
                        crate::api::bolt11::FfiBolt11Payment::receive_variable_amount_for_hash(
                            &api_that,
                            api_description,
                            api_expiry_secs,
                            api_payment_hash,
                        )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_proportional_lsp_fee_limit_ppm_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ffi_bolt_11_payment_receive_variable_amount_via_jit_channel", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_description = description.cst_decode();let api_expiry_secs = expiry_secs.cst_decode();let api_max_proportional_lsp_fee_limit_ppm_msat = max_proportional_lsp_fee_limit_ppm_msat.cst_decode(); move |context|  {
                    transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move ||  {
                         let output_ok = crate::api::bolt11::FfiBolt11Payment::receive_variable_amount_via_jit_channel(&api_that, api_description, api_expiry_secs, api_max_proportional_lsp_fee_limit_ppm_msat)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_receive_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_total_lsp_fee_limit_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_receive_via_jit_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_max_total_lsp_fee_limit_msat = max_total_lsp_fee_limit_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt11::FfiBolt11Payment::receive_via_jit_channel(
                        &api_that,
                        api_amount_msat,
                        api_description,
                        api_expiry_secs,
                        api_max_total_lsp_fee_limit_msat,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    invoice: impl CstDecode<crate::api::bolt11::Bolt11Invoice>,
    sending_parameters: impl CstDecode<Option<crate::api::types::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt11::FfiBolt11Payment::send(
                        &api_that,
                        api_invoice,
                        api_sending_parameters,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_send_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    invoice: impl CstDecode<crate::api::bolt11::Bolt11Invoice>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_send_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok =
                        crate::api::bolt11::FfiBolt11Payment::send_probes(&api_that, api_invoice)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_send_probes_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    invoice: impl CstDecode<crate::api::bolt11::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_send_probes_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt11::FfiBolt11Payment::send_probes_using_amount(
                        &api_that,
                        api_invoice,
                        api_amount_msat,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt11__ffi_bolt_11_payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt11::FfiBolt11Payment>,
    invoice: impl CstDecode<crate::api::bolt11::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
    sending_parameters: impl CstDecode<Option<crate::api::types::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_11_payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt11::FfiBolt11Payment::send_using_amount(
                        &api_that,
                        api_invoice,
                        api_amount_msat,
                        api_sending_parameters,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ffi_bolt_12_payment_initiate_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::FfiBolt12Payment>,
    amount_msat: impl CstDecode<u64>,
    expiry_secs: impl CstDecode<u32>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_12_payment_initiate_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt12::FfiBolt12Payment::initiate_refund(
                        &api_that,
                        api_amount_msat,
                        api_expiry_secs,
                        api_quantity,
                        api_payer_note,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ffi_bolt_12_payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::FfiBolt12Payment>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<Option<u32>>,
    quantity: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_12_payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_quantity = quantity.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt12::FfiBolt12Payment::receive(
                        &api_that,
                        api_amount_msat,
                        api_description,
                        api_expiry_secs,
                        api_quantity,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ffi_bolt_12_payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::FfiBolt12Payment>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_12_payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt12::FfiBolt12Payment::receive_variable_amount(
                        &api_that,
                        api_description,
                        api_expiry_secs,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ffi_bolt_12_payment_request_refund_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::FfiBolt12Payment>,
    refund: impl CstDecode<crate::api::bolt12::Refund>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_12_payment_request_refund_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_refund = refund.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt12::FfiBolt12Payment::request_refund_payment(
                        &api_that, api_refund,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ffi_bolt_12_payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::FfiBolt12Payment>,
    offer: impl CstDecode<crate::api::bolt12::Offer>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_12_payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offer = offer.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt12::FfiBolt12Payment::send(
                        &api_that,
                        api_offer,
                        api_quantity,
                        api_payer_note,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__bolt12__ffi_bolt_12_payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::bolt12::FfiBolt12Payment>,
    offer: impl CstDecode<crate::api::bolt12::Offer>,
    amount_msat: impl CstDecode<u64>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_bolt_12_payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offer = offer.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::bolt12::FfiBolt12Payment::send_using_amount(
                        &api_that,
                        api_offer,
                        api_amount_msat,
                        api_quantity,
                        api_payer_note,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__builder__FfiBuilder_auto_accessor_get_opaque_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FfiBuilder_auto_accessor_get_opaque",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.opaque.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__builder__FfiBuilder_auto_accessor_set_opaque_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>,
    >,
    opaque: impl CstDecode<RustOpaqueNom<ldk_node::Builder>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FfiBuilder_auto_accessor_set_opaque",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_opaque = opaque.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.opaque = api_opaque;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__builder__FfiBuilder_build_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<FfiBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FfiBuilder_build",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiBuilderError>((move || {
                    let output_ok = crate::api::builder::FfiBuilder::build(api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__builder__FfiBuilder_build_with_fs_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<FfiBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FfiBuilder_build_with_fs_store",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiBuilderError>((move || {
                    let output_ok = crate::api::builder::FfiBuilder::build_with_fs_store(api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__builder__FfiBuilder_build_with_vss_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>,
    >,
    vss_url: impl CstDecode<String>,
    store_id: impl CstDecode<String>,
    lnurl_auth_server_url: impl CstDecode<String>,
    fixed_headers: impl CstDecode<std::collections::HashMap<String, String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FfiBuilder_build_with_vss_store",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_vss_url = vss_url.cst_decode();
            let api_store_id = store_id.cst_decode();
            let api_lnurl_auth_server_url = lnurl_auth_server_url.cst_decode();
            let api_fixed_headers = fixed_headers.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiBuilderError>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::builder::FfiBuilder::build_with_vss_store(
                        &*api_that_guard,
                        api_vss_url,
                        api_store_id,
                        api_lnurl_auth_server_url,
                        api_fixed_headers,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__builder__FfiBuilder_build_with_vss_store_and_fixed_headers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>,
    >,
    vss_url: impl CstDecode<String>,
    store_id: impl CstDecode<String>,
    fixed_headers: impl CstDecode<std::collections::HashMap<String, String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FfiBuilder_build_with_vss_store_and_fixed_headers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_vss_url = vss_url.cst_decode();
            let api_store_id = store_id.cst_decode();
            let api_fixed_headers = fixed_headers.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiBuilderError>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::builder::FfiBuilder::build_with_vss_store_and_fixed_headers(
                            &*api_that_guard,
                            api_vss_url,
                            api_store_id,
                            api_fixed_headers,
                        )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__builder__FfiBuilder_create_builder_impl(
    config: impl CstDecode<crate::api::types::Config>,
    chain_data_source_config: impl CstDecode<Option<crate::api::types::ChainDataSourceConfig>>,
    entropy_source_config: impl CstDecode<Option<crate::api::types::EntropySourceConfig>>,
    gossip_source_config: impl CstDecode<Option<crate::api::types::GossipSourceConfig>>,
    liquidity_source_config: impl CstDecode<Option<crate::api::types::LiquiditySourceConfig>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "FfiBuilder_create_builder",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_config = config.cst_decode();
            let api_chain_data_source_config = chain_data_source_config.cst_decode();
            let api_entropy_source_config = entropy_source_config.cst_decode();
            let api_gossip_source_config = gossip_source_config.cst_decode();
            let api_liquidity_source_config = liquidity_source_config.cst_decode();
            transform_result_dco::<_, _, crate::utils::error::FfiBuilderError>((move || {
                let output_ok = crate::api::builder::FfiBuilder::create_builder(
                    api_config,
                    api_chain_data_source_config,
                    api_entropy_source_config,
                    api_gossip_source_config,
                    api_liquidity_source_config,
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__builder__ffi_mnemonic_generate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_mnemonic_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::builder::FfiMnemonic::generate())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__graph__ffi_network_graph_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::graph::FfiNetworkGraph>,
    short_channel_id: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_network_graph_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_short_channel_id = short_channel_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::graph::FfiNetworkGraph::channel(
                            &api_that,
                            api_short_channel_id,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__graph__ffi_network_graph_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::graph::FfiNetworkGraph>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_network_graph_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::graph::FfiNetworkGraph::list_channels(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__graph__ffi_network_graph_list_nodes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::graph::FfiNetworkGraph>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_network_graph_list_nodes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::graph::FfiNetworkGraph::list_nodes(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__graph__ffi_network_graph_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::graph::FfiNetworkGraph>,
    node_id: impl CstDecode<crate::api::graph::NodeId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_network_graph_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok =
                        crate::api::graph::FfiNetworkGraph::node(&api_that, api_node_id)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_bolt11_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_bolt11_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::bolt11_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_bolt12_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_bolt12_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::bolt12_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    user_channel_id: impl CstDecode<crate::api::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::close_channel(
                        &api_that,
                        api_user_channel_id,
                        api_counterparty_node_id,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::config(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_connect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
    address: impl CstDecode<crate::api::types::SocketAddress>,
    persist: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_connect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            let api_persist = persist.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::connect(
                        &api_that,
                        api_node_id,
                        api_address,
                        api_persist,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_disconnect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_disconnect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok =
                        crate::api::node::FfiNode::disconnect(&api_that, api_counterparty_node_id)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_event_handled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_event_handled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::node::FfiNode::event_handled(&api_that);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_force_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    user_channel_id: impl CstDecode<crate::api::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_force_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::force_close_channel(
                        &api_that,
                        api_user_channel_id,
                        api_counterparty_node_id,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_list_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_list_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::list_balances(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::list_channels(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_list_payments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_list_payments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::list_payments(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_list_payments_with_filter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    payment_direction: impl CstDecode<crate::api::types::PaymentDirection>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_list_payments_with_filter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_direction = payment_direction.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::list_payments_with_filter(
                            &api_that,
                            api_payment_direction,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_list_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_list_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::list_peers(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_listening_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_listening_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::node::FfiNode::listening_addresses(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_network_graph_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_network_graph",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::network_graph(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::next_event(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_next_event_async_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_next_event_async",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let output_ok = Result::<_, ()>::Ok(
                            crate::api::node::FfiNode::next_event_async(&api_that).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_node_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_node_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::node_id(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_on_chain_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_on_chain_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::on_chain_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_open_announced_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    socket_address: impl CstDecode<crate::api::types::SocketAddress>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    channel_config: impl CstDecode<Option<crate::api::types::ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_open_announced_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_socket_address = socket_address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::open_announced_channel(
                        &api_that,
                        api_socket_address,
                        api_node_id,
                        api_channel_amount_sats,
                        api_push_to_counterparty_msat,
                        api_channel_config,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_open_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    socket_address: impl CstDecode<crate::api::types::SocketAddress>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    channel_config: impl CstDecode<Option<crate::api::types::ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_open_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_socket_address = socket_address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::open_channel(
                        &api_that,
                        api_socket_address,
                        api_node_id,
                        api_channel_amount_sats,
                        api_push_to_counterparty_msat,
                        api_channel_config,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    payment_id: impl CstDecode<crate::api::types::PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::node::FfiNode::payment(
                        &api_that,
                        api_payment_id,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_remove_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    payment_id: impl CstDecode<crate::api::types::PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_remove_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok =
                        crate::api::node::FfiNode::remove_payment(&api_that, api_payment_id)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_sign_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    msg: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_sign_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::node::FfiNode::sign_message(
                        &api_that, api_msg,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_spontaneous_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_spontaneous_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::node::FfiNode::spontaneous_payment(api_ptr),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::start(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::status(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_stop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_stop",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::stop(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_sync_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_sync_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::sync_wallets(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_unified_qr_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_unified_qr_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::node::FfiNode::unified_qr_payment(api_ptr),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_update_channel_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    user_channel_id: impl CstDecode<crate::api::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<crate::api::types::PublicKey>,
    channel_config: impl CstDecode<crate::api::types::ChannelConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_update_channel_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::update_channel_config(
                        &api_that,
                        api_user_channel_id,
                        api_counterparty_node_id,
                        api_channel_config,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_verify_signature_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
    msg: impl CstDecode<Vec<u8>>,
    sig: impl CstDecode<String>,
    public_key: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_verify_signature",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            let api_sig = sig.cst_decode();
            let api_public_key = public_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::node::FfiNode::verify_signature(
                        &api_that,
                        api_msg,
                        api_sig,
                        api_public_key,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__node__ffi_node_wait_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::node::FfiNode>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_node_wait_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::node::FfiNode::wait_next_event(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__on_chain__ffi_on_chain_payment_new_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::on_chain::FfiOnChainPayment>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_on_chain_payment_new_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok =
                        crate::api::on_chain::FfiOnChainPayment::new_address(&api_that)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__on_chain__ffi_on_chain_payment_send_all_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::on_chain::FfiOnChainPayment>,
    address: impl CstDecode<crate::api::types::Address>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_on_chain_payment_send_all_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::on_chain::FfiOnChainPayment::send_all_to_address(
                        &api_that,
                        api_address,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__on_chain__ffi_on_chain_payment_send_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::on_chain::FfiOnChainPayment>,
    address: impl CstDecode<crate::api::types::Address>,
    amount_sats: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_on_chain_payment_send_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::on_chain::FfiOnChainPayment::send_to_address(
                        &api_that,
                        api_address,
                        api_amount_sats,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__spontaneous__ffi_spontaneous_payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::spontaneous::FfiSpontaneousPayment>,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
    sending_parameters: impl CstDecode<Option<crate::api::types::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_spontaneous_payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::spontaneous::FfiSpontaneousPayment::send(
                        &api_that,
                        api_amount_msat,
                        api_node_id,
                        api_sending_parameters,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__spontaneous__ffi_spontaneous_payment_send_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::spontaneous::FfiSpontaneousPayment>,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<crate::api::types::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_spontaneous_payment_send_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::spontaneous::FfiSpontaneousPayment::send_probes(
                        &api_that,
                        api_amount_msat,
                        api_node_id,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__types__anchor_channels_config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "anchor_channels_config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::types::AnchorChannelsConfig::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::Config::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__unified_qr__ffi_unified_qr_payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::unified_qr::FfiUnifiedQrPayment>,
    amount_sats: impl CstDecode<u64>,
    message: impl CstDecode<String>,
    expiry_sec: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_unified_qr_payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            let api_message = message.cst_decode();
            let api_expiry_sec = expiry_sec.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok = crate::api::unified_qr::FfiUnifiedQrPayment::receive(
                        &api_that,
                        api_amount_sats,
                        api_message,
                        api_expiry_sec,
                    )?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}
fn wire__crate__api__unified_qr__ffi_unified_qr_payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::unified_qr::FfiUnifiedQrPayment>,
    uri_str: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_unified_qr_payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_uri_str = uri_str.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::utils::error::FfiNodeError>((move || {
                    let output_ok =
                        crate::api::unified_qr::FfiUnifiedQrPayment::send(&api_that, api_uri_str)?;
                    Ok(output_ok)
                })(
                ))
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<crate::api::types::BalanceSource> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::BalanceSource {
        match self {
            0 => crate::api::types::BalanceSource::HolderForceClosed,
            1 => crate::api::types::BalanceSource::CounterpartyForceClosed,
            2 => crate::api::types::BalanceSource::CoopClose,
            3 => crate::api::types::BalanceSource::Htlc,
            _ => unreachable!("Invalid variant for BalanceSource: {}", self),
        }
    }
}
impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::utils::error::FfiBuilderError> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::utils::error::FfiBuilderError {
        match self {
            0 => crate::utils::error::FfiBuilderError::InvalidNodeAlias,
            1 => crate::utils::error::FfiBuilderError::SocketAddressParseError,
            2 => crate::utils::error::FfiBuilderError::InvalidSeedBytes,
            3 => crate::utils::error::FfiBuilderError::InvalidSeedFile,
            4 => crate::utils::error::FfiBuilderError::InvalidSystemTime,
            5 => crate::utils::error::FfiBuilderError::InvalidChannelMonitor,
            6 => crate::utils::error::FfiBuilderError::InvalidListeningAddress,
            7 => crate::utils::error::FfiBuilderError::ReadFailed,
            8 => crate::utils::error::FfiBuilderError::WriteFailed,
            9 => crate::utils::error::FfiBuilderError::StoragePathAccessFailed,
            10 => crate::utils::error::FfiBuilderError::KVStoreSetupFailed,
            11 => crate::utils::error::FfiBuilderError::WalletSetupFailed,
            12 => crate::utils::error::FfiBuilderError::LoggerSetupFailed,
            13 => crate::utils::error::FfiBuilderError::InvalidPublicKey,
            _ => unreachable!("Invalid variant for FfiBuilderError: {}", self),
        }
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::api::types::LogLevel> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::LogLevel {
        match self {
            0 => crate::api::types::LogLevel::Gossip,
            1 => crate::api::types::LogLevel::Trace,
            2 => crate::api::types::LogLevel::Debug,
            3 => crate::api::types::LogLevel::Info,
            4 => crate::api::types::LogLevel::Warn,
            5 => crate::api::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::Network> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Network {
        match self {
            0 => crate::api::types::Network::Bitcoin,
            1 => crate::api::types::Network::Testnet,
            2 => crate::api::types::Network::Signet,
            3 => crate::api::types::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentDirection> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentDirection {
        match self {
            0 => crate::api::types::PaymentDirection::Inbound,
            1 => crate::api::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentFailureReason> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentFailureReason {
        match self {
            0 => crate::api::types::PaymentFailureReason::RecipientRejected,
            1 => crate::api::types::PaymentFailureReason::UserAbandoned,
            2 => crate::api::types::PaymentFailureReason::RetriesExhausted,
            3 => crate::api::types::PaymentFailureReason::PaymentExpired,
            4 => crate::api::types::PaymentFailureReason::RouteNotFound,
            5 => crate::api::types::PaymentFailureReason::UnexpectedError,
            6 => crate::api::types::PaymentFailureReason::UnknownRequiredFeatures,
            7 => crate::api::types::PaymentFailureReason::InvoiceRequestExpired,
            8 => crate::api::types::PaymentFailureReason::InvoiceRequestRejected,
            _ => unreachable!("Invalid variant for PaymentFailureReason: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::PaymentStatus> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::PaymentStatus {
        match self {
            0 => crate::api::types::PaymentStatus::Pending,
            1 => crate::api::types::PaymentStatus::Succeeded,
            2 => crate::api::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for FfiBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::Builder> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::Node> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::graph::NetworkGraph> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::Bolt11Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::Bolt12Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::OnchainPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::SpontaneousPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<ldk_node::payment::UnifiedQrPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::types::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return crate::api::types::Address { s: var_s };
    }
}

impl SseDecode for crate::api::types::AnchorChannelsConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_trustedPeersNoReserve =
            <Vec<crate::api::types::PublicKey>>::sse_decode(deserializer);
        let mut var_perChannelReserveSats = <u64>::sse_decode(deserializer);
        return crate::api::types::AnchorChannelsConfig {
            trusted_peers_no_reserve: var_trustedPeersNoReserve,
            per_channel_reserve_sats: var_perChannelReserveSats,
        };
    }
}

impl SseDecode for crate::api::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_totalOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_spendableOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_totalLightningBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_lightningBalances =
            <Vec<crate::api::types::LightningBalance>>::sse_decode(deserializer);
        let mut var_pendingBalancesFromChannelClosures =
            <Vec<crate::api::types::PendingSweepBalance>>::sse_decode(deserializer);
        return crate::api::types::BalanceDetails {
            total_onchain_balance_sats: var_totalOnchainBalanceSats,
            spendable_onchain_balance_sats: var_spendableOnchainBalanceSats,
            total_lightning_balance_sats: var_totalLightningBalanceSats,
            lightning_balances: var_lightningBalances,
            pending_balances_from_channel_closures: var_pendingBalancesFromChannelClosures,
        };
    }
}

impl SseDecode for crate::api::types::BalanceSource {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::BalanceSource::HolderForceClosed,
            1 => crate::api::types::BalanceSource::CounterpartyForceClosed,
            2 => crate::api::types::BalanceSource::CoopClose,
            3 => crate::api::types::BalanceSource::Htlc,
            _ => unreachable!("Invalid variant for BalanceSource: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blockHash = <String>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        return crate::api::types::BestBlock {
            block_hash: var_blockHash,
            height: var_height,
        };
    }
}

impl SseDecode for crate::api::bolt11::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_signedRawInvoice = <String>::sse_decode(deserializer);
        return crate::api::bolt11::Bolt11Invoice {
            signed_raw_invoice: var_signedRawInvoice,
        };
    }
}

impl SseDecode for crate::api::bolt12::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::bolt12::Bolt12Invoice { data: var_data };
    }
}

impl SseDecode for crate::utils::error::Bolt12ParseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::utils::error::Bolt12ParseError::InvalidContinuation;
            }
            1 => {
                return crate::utils::error::Bolt12ParseError::InvalidBech32Hrp;
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::utils::error::Bolt12ParseError::Bech32(var_field0);
            }
            3 => {
                let mut var_field0 = <crate::utils::error::DecodeError>::sse_decode(deserializer);
                return crate::utils::error::Bolt12ParseError::Decode(var_field0);
            }
            4 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::utils::error::Bolt12ParseError::InvalidSemantics(var_field0);
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::utils::error::Bolt12ParseError::InvalidSignature(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::types::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_serverUrl = <String>::sse_decode(deserializer);
                let mut var_syncConfig =
                    <Option<crate::api::types::EsploraSyncConfig>>::sse_decode(deserializer);
                return crate::api::types::ChainDataSourceConfig::Esplora {
                    server_url: var_serverUrl,
                    sync_config: var_syncConfig,
                };
            }
            1 => {
                let mut var_rpcHost = <String>::sse_decode(deserializer);
                let mut var_rpcPort = <u16>::sse_decode(deserializer);
                let mut var_rpcUser = <String>::sse_decode(deserializer);
                let mut var_rpcPassword = <String>::sse_decode(deserializer);
                return crate::api::types::ChainDataSourceConfig::BitcoindRpc {
                    rpc_host: var_rpcHost,
                    rpc_port: var_rpcPort,
                    rpc_user: var_rpcUser,
                    rpc_password: var_rpcPassword,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_forwardingFeeProportionalMillionths = <u32>::sse_decode(deserializer);
        let mut var_forwardingFeeBaseMsat = <u32>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_maxDustHtlcExposure =
            <crate::api::types::MaxDustHTLCExposure>::sse_decode(deserializer);
        let mut var_forceCloseAvoidanceMaxFeeSatoshis = <u64>::sse_decode(deserializer);
        let mut var_acceptUnderpayingHtlcs = <bool>::sse_decode(deserializer);
        return crate::api::types::ChannelConfig {
            forwarding_fee_proportional_millionths: var_forwardingFeeProportionalMillionths,
            forwarding_fee_base_msat: var_forwardingFeeBaseMsat,
            cltv_expiry_delta: var_cltvExpiryDelta,
            max_dust_htlc_exposure: var_maxDustHtlcExposure,
            force_close_avoidance_max_fee_satoshis: var_forceCloseAvoidanceMaxFeeSatoshis,
            accept_underpaying_htlcs: var_acceptUnderpayingHtlcs,
        };
    }
}

impl SseDecode for crate::api::types::ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
        let mut var_counterpartyNodeId = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_fundingTxo = <Option<crate::api::types::OutPoint>>::sse_decode(deserializer);
        let mut var_channelValueSats = <u64>::sse_decode(deserializer);
        let mut var_unspendablePunishmentReserve = <Option<u64>>::sse_decode(deserializer);
        let mut var_userChannelId = <crate::api::types::UserChannelId>::sse_decode(deserializer);
        let mut var_feerateSatPer1000Weight = <u32>::sse_decode(deserializer);
        let mut var_outboundCapacityMsat = <u64>::sse_decode(deserializer);
        let mut var_inboundCapacityMsat = <u64>::sse_decode(deserializer);
        let mut var_confirmationsRequired = <Option<u32>>::sse_decode(deserializer);
        let mut var_confirmations = <Option<u32>>::sse_decode(deserializer);
        let mut var_isOutbound = <bool>::sse_decode(deserializer);
        let mut var_isChannelReady = <bool>::sse_decode(deserializer);
        let mut var_isUsable = <bool>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <Option<u16>>::sse_decode(deserializer);
        let mut var_counterpartyUnspendablePunishmentReserve = <u64>::sse_decode(deserializer);
        let mut var_counterpartyOutboundHtlcMinimumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_counterpartyOutboundHtlcMaximumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_counterpartyForwardingInfoFeeBaseMsat = <Option<u32>>::sse_decode(deserializer);
        let mut var_counterpartyForwardingInfoFeeProportionalMillionths =
            <Option<u32>>::sse_decode(deserializer);
        let mut var_counterpartyForwardingInfoCltvExpiryDelta =
            <Option<u16>>::sse_decode(deserializer);
        let mut var_nextOutboundHtlcLimitMsat = <u64>::sse_decode(deserializer);
        let mut var_nextOutboundHtlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_forceCloseSpendDelay = <Option<u16>>::sse_decode(deserializer);
        let mut var_inboundHtlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_inboundHtlcMaximumMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_config = <crate::api::types::ChannelConfig>::sse_decode(deserializer);
        return crate::api::types::ChannelDetails {
            channel_id: var_channelId,
            counterparty_node_id: var_counterpartyNodeId,
            funding_txo: var_fundingTxo,
            channel_value_sats: var_channelValueSats,
            unspendable_punishment_reserve: var_unspendablePunishmentReserve,
            user_channel_id: var_userChannelId,
            feerate_sat_per_1000_weight: var_feerateSatPer1000Weight,
            outbound_capacity_msat: var_outboundCapacityMsat,
            inbound_capacity_msat: var_inboundCapacityMsat,
            confirmations_required: var_confirmationsRequired,
            confirmations: var_confirmations,
            is_outbound: var_isOutbound,
            is_channel_ready: var_isChannelReady,
            is_usable: var_isUsable,
            cltv_expiry_delta: var_cltvExpiryDelta,
            counterparty_unspendable_punishment_reserve:
                var_counterpartyUnspendablePunishmentReserve,
            counterparty_outbound_htlc_minimum_msat: var_counterpartyOutboundHtlcMinimumMsat,
            counterparty_outbound_htlc_maximum_msat: var_counterpartyOutboundHtlcMaximumMsat,
            counterparty_forwarding_info_fee_base_msat: var_counterpartyForwardingInfoFeeBaseMsat,
            counterparty_forwarding_info_fee_proportional_millionths:
                var_counterpartyForwardingInfoFeeProportionalMillionths,
            counterparty_forwarding_info_cltv_expiry_delta:
                var_counterpartyForwardingInfoCltvExpiryDelta,
            next_outbound_htlc_limit_msat: var_nextOutboundHtlcLimitMsat,
            next_outbound_htlc_minimum_msat: var_nextOutboundHtlcMinimumMsat,
            force_close_spend_delay: var_forceCloseSpendDelay,
            inbound_htlc_minimum_msat: var_inboundHtlcMinimumMsat,
            inbound_htlc_maximum_msat: var_inboundHtlcMaximumMsat,
            config: var_config,
        };
    }
}

impl SseDecode for crate::api::types::ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::ChannelId { data: var_data };
    }
}

impl SseDecode for crate::api::graph::ChannelInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodeOne = <crate::api::graph::NodeId>::sse_decode(deserializer);
        let mut var_oneToTwo =
            <Option<crate::api::graph::ChannelUpdateInfo>>::sse_decode(deserializer);
        let mut var_nodeTwo = <crate::api::graph::NodeId>::sse_decode(deserializer);
        let mut var_twoToOne =
            <Option<crate::api::graph::ChannelUpdateInfo>>::sse_decode(deserializer);
        let mut var_capacitySats = <Option<u64>>::sse_decode(deserializer);
        return crate::api::graph::ChannelInfo {
            node_one: var_nodeOne,
            one_to_two: var_oneToTwo,
            node_two: var_nodeTwo,
            two_to_one: var_twoToOne,
            capacity_sats: var_capacitySats,
        };
    }
}

impl SseDecode for crate::api::graph::ChannelUpdateInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdate = <u32>::sse_decode(deserializer);
        let mut var_enabled = <bool>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_htlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_htlcMaximumMsat = <u64>::sse_decode(deserializer);
        let mut var_fees = <crate::api::graph::RoutingFees>::sse_decode(deserializer);
        return crate::api::graph::ChannelUpdateInfo {
            last_update: var_lastUpdate,
            enabled: var_enabled,
            cltv_expiry_delta: var_cltvExpiryDelta,
            htlc_minimum_msat: var_htlcMinimumMsat,
            htlc_maximum_msat: var_htlcMaximumMsat,
            fees: var_fees,
        };
    }
}

impl SseDecode for crate::api::types::ClosureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_peerFeerateSatPerKw = <u32>::sse_decode(deserializer);
                let mut var_requiredFeerateSatPerKw = <u32>::sse_decode(deserializer);
                return crate::api::types::ClosureReason::PeerFeerateTooLow {
                    peer_feerate_sat_per_kw: var_peerFeerateSatPerKw,
                    required_feerate_sat_per_kw: var_requiredFeerateSatPerKw,
                };
            }
            1 => {
                let mut var_peerMsg = <String>::sse_decode(deserializer);
                return crate::api::types::ClosureReason::CounterpartyForceClosed {
                    peer_msg: var_peerMsg,
                };
            }
            2 => {
                let mut var_broadcastedLatestTxn = <Option<bool>>::sse_decode(deserializer);
                return crate::api::types::ClosureReason::HolderForceClosed {
                    broadcasted_latest_txn: var_broadcastedLatestTxn,
                };
            }
            3 => {
                return crate::api::types::ClosureReason::LegacyCooperativeClosure;
            }
            4 => {
                return crate::api::types::ClosureReason::CounterpartyInitiatedCooperativeClosure;
            }
            5 => {
                return crate::api::types::ClosureReason::LocallyInitiatedCooperativeClosure;
            }
            6 => {
                return crate::api::types::ClosureReason::CommitmentTxConfirmed;
            }
            7 => {
                return crate::api::types::ClosureReason::FundingTimedOut;
            }
            8 => {
                let mut var_err = <String>::sse_decode(deserializer);
                return crate::api::types::ClosureReason::ProcessingError { err: var_err };
            }
            9 => {
                return crate::api::types::ClosureReason::DisconnectedPeer;
            }
            10 => {
                return crate::api::types::ClosureReason::OutdatedChannelManager;
            }
            11 => {
                return crate::api::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel;
            }
            12 => {
                return crate::api::types::ClosureReason::FundingBatchClosure;
            }
            13 => {
                return crate::api::types::ClosureReason::HTLCsTimedOut;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_storageDirPath = <String>::sse_decode(deserializer);
        let mut var_logDirPath = <Option<String>>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Network>::sse_decode(deserializer);
        let mut var_listeningAddresses =
            <Option<Vec<crate::api::types::SocketAddress>>>::sse_decode(deserializer);
        let mut var_nodeAlias = <Option<crate::api::types::NodeAlias>>::sse_decode(deserializer);
        let mut var_trustedPeers0Conf =
            <Vec<crate::api::types::PublicKey>>::sse_decode(deserializer);
        let mut var_probingLiquidityLimitMultiplier = <u64>::sse_decode(deserializer);
        let mut var_logLevel = <crate::api::types::LogLevel>::sse_decode(deserializer);
        let mut var_anchorChannelsConfig =
            <Option<crate::api::types::AnchorChannelsConfig>>::sse_decode(deserializer);
        let mut var_sendingParameters =
            <Option<crate::api::types::SendingParameters>>::sse_decode(deserializer);
        return crate::api::types::Config {
            storage_dir_path: var_storageDirPath,
            log_dir_path: var_logDirPath,
            network: var_network,
            listening_addresses: var_listeningAddresses,
            node_alias: var_nodeAlias,
            trusted_peers_0conf: var_trustedPeers0Conf,
            probing_liquidity_limit_multiplier: var_probingLiquidityLimitMultiplier,
            log_level: var_logLevel,
            anchor_channels_config: var_anchorChannelsConfig,
            sending_parameters: var_sendingParameters,
        };
    }
}

impl SseDecode for crate::utils::error::DecodeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::utils::error::DecodeError::UnknownVersion;
            }
            1 => {
                return crate::utils::error::DecodeError::UnknownRequiredFeature;
            }
            2 => {
                return crate::utils::error::DecodeError::InvalidValue;
            }
            3 => {
                return crate::utils::error::DecodeError::ShortRead;
            }
            4 => {
                return crate::utils::error::DecodeError::BadLengthDescriptor;
            }
            5 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::utils::error::DecodeError::Io(var_field0);
            }
            6 => {
                return crate::utils::error::DecodeError::UnsupportedCompression;
            }
            7 => {
                return crate::utils::error::DecodeError::DangerousValue;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::SeedFile(var_field0);
            }
            1 => {
                let mut var_field0 = <[u8; 64]>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::SeedBytes(var_field0);
            }
            2 => {
                let mut var_mnemonic = <crate::api::builder::FfiMnemonic>::sse_decode(deserializer);
                let mut var_passphrase = <Option<String>>::sse_decode(deserializer);
                return crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                    mnemonic: var_mnemonic,
                    passphrase: var_passphrase,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::EsploraSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_onchainWalletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_lightningWalletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_feeRateCacheUpdateIntervalSecs = <u64>::sse_decode(deserializer);
        return crate::api::types::EsploraSyncConfig {
            onchain_wallet_sync_interval_secs: var_onchainWalletSyncIntervalSecs,
            lightning_wallet_sync_interval_secs: var_lightningWalletSyncIntervalSecs,
            fee_rate_cache_update_interval_secs: var_feeRateCacheUpdateIntervalSecs,
        };
    }
}

impl SseDecode for crate::api::types::Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_paymentId = <crate::api::types::PaymentId>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_claimableAmountMsat = <u64>::sse_decode(deserializer);
                let mut var_claimDeadline = <Option<u32>>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentClaimable {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    claimable_amount_msat: var_claimableAmountMsat,
                    claim_deadline: var_claimDeadline,
                };
            }
            1 => {
                let mut var_paymentId =
                    <Option<crate::api::types::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_feePaidMsat = <Option<u64>>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentSuccessful {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    fee_paid_msat: var_feePaidMsat,
                };
            }
            2 => {
                let mut var_paymentId =
                    <Option<crate::api::types::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <Option<crate::api::types::PaymentHash>>::sse_decode(deserializer);
                let mut var_reason =
                    <Option<crate::api::types::PaymentFailureReason>>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentFailed {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    reason: var_reason,
                };
            }
            3 => {
                let mut var_paymentId =
                    <Option<crate::api::types::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_amountMsat = <u64>::sse_decode(deserializer);
                return crate::api::types::Event::PaymentReceived {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    amount_msat: var_amountMsat,
                };
            }
            4 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_formerTemporaryChannelId =
                    <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_fundingTxo = <crate::api::types::OutPoint>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelPending {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    former_temporary_channel_id: var_formerTemporaryChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    funding_txo: var_fundingTxo,
                };
            }
            5 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <Option<crate::api::types::PublicKey>>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelReady {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                };
            }
            6 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId =
                    <crate::api::types::UserChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <Option<crate::api::types::PublicKey>>::sse_decode(deserializer);
                let mut var_reason =
                    <Option<crate::api::types::ClosureReason>>::sse_decode(deserializer);
                return crate::api::types::Event::ChannelClosed {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    reason: var_reason,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::bolt11::FfiBolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<ldk_node::payment::Bolt11Payment>>::sse_decode(deserializer);
        return crate::api::bolt11::FfiBolt11Payment { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::bolt12::FfiBolt12Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<ldk_node::payment::Bolt12Payment>>::sse_decode(deserializer);
        return crate::api::bolt12::FfiBolt12Payment { opaque: var_opaque };
    }
}

impl SseDecode for crate::utils::error::FfiBuilderError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::utils::error::FfiBuilderError::InvalidNodeAlias,
            1 => crate::utils::error::FfiBuilderError::SocketAddressParseError,
            2 => crate::utils::error::FfiBuilderError::InvalidSeedBytes,
            3 => crate::utils::error::FfiBuilderError::InvalidSeedFile,
            4 => crate::utils::error::FfiBuilderError::InvalidSystemTime,
            5 => crate::utils::error::FfiBuilderError::InvalidChannelMonitor,
            6 => crate::utils::error::FfiBuilderError::InvalidListeningAddress,
            7 => crate::utils::error::FfiBuilderError::ReadFailed,
            8 => crate::utils::error::FfiBuilderError::WriteFailed,
            9 => crate::utils::error::FfiBuilderError::StoragePathAccessFailed,
            10 => crate::utils::error::FfiBuilderError::KVStoreSetupFailed,
            11 => crate::utils::error::FfiBuilderError::WalletSetupFailed,
            12 => crate::utils::error::FfiBuilderError::LoggerSetupFailed,
            13 => crate::utils::error::FfiBuilderError::InvalidPublicKey,
            _ => unreachable!("Invalid variant for FfiBuilderError: {}", inner),
        };
    }
}

impl SseDecode for crate::api::builder::FfiMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_seedPhrase = <String>::sse_decode(deserializer);
        return crate::api::builder::FfiMnemonic {
            seed_phrase: var_seedPhrase,
        };
    }
}

impl SseDecode for crate::api::graph::FfiNetworkGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<ldk_node::graph::NetworkGraph>>::sse_decode(deserializer);
        return crate::api::graph::FfiNetworkGraph { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::node::FfiNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque = <RustOpaqueNom<ldk_node::Node>>::sse_decode(deserializer);
        return crate::api::node::FfiNode { opaque: var_opaque };
    }
}

impl SseDecode for crate::utils::error::FfiNodeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::utils::error::FfiNodeError::InvalidTxid;
            }
            1 => {
                return crate::utils::error::FfiNodeError::AlreadyRunning;
            }
            2 => {
                return crate::utils::error::FfiNodeError::NotRunning;
            }
            3 => {
                return crate::utils::error::FfiNodeError::OnchainTxCreationFailed;
            }
            4 => {
                return crate::utils::error::FfiNodeError::ConnectionFailed;
            }
            5 => {
                return crate::utils::error::FfiNodeError::InvoiceCreationFailed;
            }
            6 => {
                return crate::utils::error::FfiNodeError::PaymentSendingFailed;
            }
            7 => {
                return crate::utils::error::FfiNodeError::ProbeSendingFailed;
            }
            8 => {
                return crate::utils::error::FfiNodeError::ChannelCreationFailed;
            }
            9 => {
                return crate::utils::error::FfiNodeError::ChannelClosingFailed;
            }
            10 => {
                return crate::utils::error::FfiNodeError::ChannelConfigUpdateFailed;
            }
            11 => {
                return crate::utils::error::FfiNodeError::PersistenceFailed;
            }
            12 => {
                return crate::utils::error::FfiNodeError::WalletOperationFailed;
            }
            13 => {
                return crate::utils::error::FfiNodeError::OnchainTxSigningFailed;
            }
            14 => {
                return crate::utils::error::FfiNodeError::MessageSigningFailed;
            }
            15 => {
                return crate::utils::error::FfiNodeError::TxSyncFailed;
            }
            16 => {
                return crate::utils::error::FfiNodeError::GossipUpdateFailed;
            }
            17 => {
                return crate::utils::error::FfiNodeError::InvalidAddress;
            }
            18 => {
                return crate::utils::error::FfiNodeError::InvalidSocketAddress;
            }
            19 => {
                return crate::utils::error::FfiNodeError::InvalidPublicKey;
            }
            20 => {
                return crate::utils::error::FfiNodeError::InvalidSecretKey;
            }
            21 => {
                return crate::utils::error::FfiNodeError::InvalidPaymentHash;
            }
            22 => {
                return crate::utils::error::FfiNodeError::InvalidPaymentPreimage;
            }
            23 => {
                return crate::utils::error::FfiNodeError::InvalidPaymentSecret;
            }
            24 => {
                return crate::utils::error::FfiNodeError::InvalidAmount;
            }
            25 => {
                return crate::utils::error::FfiNodeError::InvalidInvoice;
            }
            26 => {
                return crate::utils::error::FfiNodeError::InvalidChannelId;
            }
            27 => {
                return crate::utils::error::FfiNodeError::InvalidNetwork;
            }
            28 => {
                return crate::utils::error::FfiNodeError::DuplicatePayment;
            }
            29 => {
                return crate::utils::error::FfiNodeError::InsufficientFunds;
            }
            30 => {
                return crate::utils::error::FfiNodeError::FeerateEstimationUpdateFailed;
            }
            31 => {
                return crate::utils::error::FfiNodeError::LiquidityRequestFailed;
            }
            32 => {
                return crate::utils::error::FfiNodeError::LiquiditySourceUnavailable;
            }
            33 => {
                return crate::utils::error::FfiNodeError::LiquidityFeeTooHigh;
            }
            34 => {
                return crate::utils::error::FfiNodeError::InvalidPaymentId;
            }
            35 => {
                let mut var_field0 = <crate::utils::error::DecodeError>::sse_decode(deserializer);
                return crate::utils::error::FfiNodeError::Decode(var_field0);
            }
            36 => {
                let mut var_field0 =
                    <crate::utils::error::Bolt12ParseError>::sse_decode(deserializer);
                return crate::utils::error::FfiNodeError::Bolt12Parse(var_field0);
            }
            37 => {
                return crate::utils::error::FfiNodeError::InvoiceRequestCreationFailed;
            }
            38 => {
                return crate::utils::error::FfiNodeError::OfferCreationFailed;
            }
            39 => {
                return crate::utils::error::FfiNodeError::RefundCreationFailed;
            }
            40 => {
                return crate::utils::error::FfiNodeError::FeerateEstimationUpdateTimeout;
            }
            41 => {
                return crate::utils::error::FfiNodeError::WalletOperationTimeout;
            }
            42 => {
                return crate::utils::error::FfiNodeError::TxSyncTimeout;
            }
            43 => {
                return crate::utils::error::FfiNodeError::GossipUpdateTimeout;
            }
            44 => {
                return crate::utils::error::FfiNodeError::InvalidOfferId;
            }
            45 => {
                return crate::utils::error::FfiNodeError::InvalidNodeId;
            }
            46 => {
                return crate::utils::error::FfiNodeError::InvalidOffer;
            }
            47 => {
                return crate::utils::error::FfiNodeError::InvalidRefund;
            }
            48 => {
                return crate::utils::error::FfiNodeError::UnsupportedCurrency;
            }
            49 => {
                return crate::utils::error::FfiNodeError::UriParameterParsingFailed;
            }
            50 => {
                return crate::utils::error::FfiNodeError::InvalidUri;
            }
            51 => {
                return crate::utils::error::FfiNodeError::InvalidQuantity;
            }
            52 => {
                return crate::utils::error::FfiNodeError::InvalidNodeAlias;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::on_chain::FfiOnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<ldk_node::payment::OnchainPayment>>::sse_decode(deserializer);
        return crate::api::on_chain::FfiOnChainPayment { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::spontaneous::FfiSpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<ldk_node::payment::SpontaneousPayment>>::sse_decode(deserializer);
        return crate::api::spontaneous::FfiSpontaneousPayment { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::unified_qr::FfiUnifiedQrPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_opaque =
            <RustOpaqueNom<ldk_node::payment::UnifiedQrPayment>>::sse_decode(deserializer);
        return crate::api::unified_qr::FfiUnifiedQrPayment { opaque: var_opaque };
    }
}

impl SseDecode for crate::api::types::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::GossipSourceConfig::P2PNetwork;
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::types::GossipSourceConfig::RapidGossipSync(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::types::LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_transactionFeeSatoshis = <u64>::sse_decode(deserializer);
                let mut var_outboundPaymentHtlcRoundedMsat = <u64>::sse_decode(deserializer);
                let mut var_outboundForwardedHtlcRoundedMsat = <u64>::sse_decode(deserializer);
                let mut var_inboundClaimingHtlcRoundedMsat = <u64>::sse_decode(deserializer);
                let mut var_inboundHtlcRoundedMsat = <u64>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::ClaimableOnChannelClose {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    transaction_fee_satoshis: var_transactionFeeSatoshis,
                    outbound_payment_htlc_rounded_msat: var_outboundPaymentHtlcRoundedMsat,
                    outbound_forwarded_htlc_rounded_msat: var_outboundForwardedHtlcRoundedMsat,
                    inbound_claiming_htlc_rounded_msat: var_inboundClaimingHtlcRoundedMsat,
                    inbound_htlc_rounded_msat: var_inboundHtlcRoundedMsat,
                };
            }
            1 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_confirmationHeight = <u32>::sse_decode(deserializer);
                let mut var_source = <crate::api::types::BalanceSource>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::ClaimableAwaitingConfirmations {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    confirmation_height: var_confirmationHeight,
                    source: var_source,
                };
            }
            2 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_timeoutHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_paymentPreimage =
                    <crate::api::types::PaymentPreimage>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::ContentiousClaimable {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    timeout_height: var_timeoutHeight,
                    payment_hash: var_paymentHash,
                    payment_preimage: var_paymentPreimage,
                };
            }
            3 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_claimableHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_outboundPayment = <bool>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    claimable_height: var_claimableHeight,
                    payment_hash: var_paymentHash,
                    outbound_payment: var_outboundPayment,
                };
            }
            4 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_expiryHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash =
                    <crate::api::types::PaymentHash>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::MaybePreimageClaimableHTLC {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    expiry_height: var_expiryHeight,
                    payment_hash: var_paymentHash,
                };
            }
            5 => {
                let mut var_channelId = <crate::api::types::ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId =
                    <crate::api::types::PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lsps2Service = <(
            crate::api::types::SocketAddress,
            crate::api::types::PublicKey,
            Option<String>,
        )>::sse_decode(deserializer);
        return crate::api::types::LiquiditySourceConfig {
            lsps2_service: var_lsps2Service,
        };
    }
}

impl SseDecode for Vec<crate::api::types::ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::ChannelDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::LightningBalance>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::graph::NodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::graph::NodeId>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PaymentDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PeerDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PendingSweepBalance>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::PublicKey>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::types::SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::types::SocketAddress>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::LogLevel::Gossip,
            1 => crate::api::types::LogLevel::Trace,
            2 => crate::api::types::LogLevel::Debug,
            3 => crate::api::types::LogLevel::Info,
            4 => crate::api::types::LogLevel::Warn,
            5 => crate::api::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::LSPFeeLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxTotalOpeningFeeMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_maxProportionalOpeningFeePpmMsat = <Option<u64>>::sse_decode(deserializer);
        return crate::api::types::LSPFeeLimits {
            max_total_opening_fee_msat: var_maxTotalOpeningFeeMsat,
            max_proportional_opening_fee_ppm_msat: var_maxProportionalOpeningFeePpmMsat,
        };
    }
}

impl SseDecode for crate::api::types::MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(var_field0);
            }
            1 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::MaxTotalRoutingFeeLimit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::MaxTotalRoutingFeeLimit::NoFeeCap;
            }
            1 => {
                let mut var_amountMsat = <u64>::sse_decode(deserializer);
                return crate::api::types::MaxTotalRoutingFeeLimit::FeeCap {
                    amount_msat: var_amountMsat,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Network::Bitcoin,
            1 => crate::api::types::Network::Testnet,
            2 => crate::api::types::Network::Signet,
            3 => crate::api::types::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::NodeAlias {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::NodeAlias(var_field0);
    }
}

impl SseDecode for crate::api::graph::NodeAnnouncementInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdate = <u32>::sse_decode(deserializer);
        let mut var_alias = <String>::sse_decode(deserializer);
        let mut var_addresses = <Vec<crate::api::types::SocketAddress>>::sse_decode(deserializer);
        return crate::api::graph::NodeAnnouncementInfo {
            last_update: var_lastUpdate,
            alias: var_alias,
            addresses: var_addresses,
        };
    }
}

impl SseDecode for crate::api::graph::NodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_compressed = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::graph::NodeId {
            compressed: var_compressed,
        };
    }
}

impl SseDecode for crate::api::graph::NodeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channels = <Vec<u64>>::sse_decode(deserializer);
        let mut var_announcementInfo =
            <Option<crate::api::graph::NodeAnnouncementInfo>>::sse_decode(deserializer);
        return crate::api::graph::NodeInfo {
            channels: var_channels,
            announcement_info: var_announcementInfo,
        };
    }
}

impl SseDecode for crate::api::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isRunning = <bool>::sse_decode(deserializer);
        let mut var_isListening = <bool>::sse_decode(deserializer);
        let mut var_currentBestBlock = <crate::api::types::BestBlock>::sse_decode(deserializer);
        let mut var_latestLightningWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestOnchainWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestFeeRateCacheUpdateTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestRgsSnapshotTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestNodeAnnouncementBroadcastTimestamp =
            <Option<u64>>::sse_decode(deserializer);
        let mut var_latestChannelMonitorArchivalHeight = <Option<u32>>::sse_decode(deserializer);
        return crate::api::types::NodeStatus {
            is_running: var_isRunning,
            is_listening: var_isListening,
            current_best_block: var_currentBestBlock,
            latest_lightning_wallet_sync_timestamp: var_latestLightningWalletSyncTimestamp,
            latest_onchain_wallet_sync_timestamp: var_latestOnchainWalletSyncTimestamp,
            latest_fee_rate_cache_update_timestamp: var_latestFeeRateCacheUpdateTimestamp,
            latest_rgs_snapshot_timestamp: var_latestRgsSnapshotTimestamp,
            latest_node_announcement_broadcast_timestamp:
                var_latestNodeAnnouncementBroadcastTimestamp,
            latest_channel_monitor_archival_height: var_latestChannelMonitorArchivalHeight,
        };
    }
}

impl SseDecode for crate::api::bolt12::Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return crate::api::bolt12::Offer { s: var_s };
    }
}

impl SseDecode for crate::api::types::OfferId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::OfferId(var_field0);
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::AnchorChannelsConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::AnchorChannelsConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChainDataSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChannelConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ChannelId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::graph::ChannelInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::graph::ChannelInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::graph::ChannelUpdateInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::graph::ChannelUpdateInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::ClosureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::ClosureReason>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::EntropySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::EsploraSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::EsploraSyncConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::Event>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::GossipSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::LiquiditySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::MaxTotalRoutingFeeLimit> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::MaxTotalRoutingFeeLimit>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::NodeAlias> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::NodeAlias>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::graph::NodeAnnouncementInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::graph::NodeAnnouncementInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::graph::NodeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::graph::NodeInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::OutPoint>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentDetails>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentFailureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentFailureReason>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentHash> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentHash>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentPreimage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentPreimage>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PaymentSecret>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::PublicKey>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::SendingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::SendingParameters>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u16>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::api::types::SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::api::types::SocketAddress>>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <crate::api::types::Txid>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return crate::api::types::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for crate::api::types::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <crate::api::types::PaymentId>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::PaymentKind>::sse_decode(deserializer);
        let mut var_amountMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_direction = <crate::api::types::PaymentDirection>::sse_decode(deserializer);
        let mut var_status = <crate::api::types::PaymentStatus>::sse_decode(deserializer);
        let mut var_latestUpdateTimestamp = <u64>::sse_decode(deserializer);
        return crate::api::types::PaymentDetails {
            id: var_id,
            kind: var_kind,
            amount_msat: var_amountMsat,
            direction: var_direction,
            status: var_status,
            latest_update_timestamp: var_latestUpdateTimestamp,
        };
    }
}

impl SseDecode for crate::api::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentDirection::Inbound,
            1 => crate::api::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PaymentFailureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentFailureReason::RecipientRejected,
            1 => crate::api::types::PaymentFailureReason::UserAbandoned,
            2 => crate::api::types::PaymentFailureReason::RetriesExhausted,
            3 => crate::api::types::PaymentFailureReason::PaymentExpired,
            4 => crate::api::types::PaymentFailureReason::RouteNotFound,
            5 => crate::api::types::PaymentFailureReason::UnexpectedError,
            6 => crate::api::types::PaymentFailureReason::UnknownRequiredFeatures,
            7 => crate::api::types::PaymentFailureReason::InvoiceRequestExpired,
            8 => crate::api::types::PaymentFailureReason::InvoiceRequestRejected,
            _ => unreachable!("Invalid variant for PaymentFailureReason: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentHash { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentId(var_field0);
    }
}

impl SseDecode for crate::api::types::PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::types::PaymentKind::Onchain;
            }
            1 => {
                let mut var_hash = <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Bolt11 {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                };
            }
            2 => {
                let mut var_hash = <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
                let mut var_lspFeeLimits =
                    <crate::api::types::LSPFeeLimits>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Bolt11Jit {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                    lsp_fee_limits: var_lspFeeLimits,
                };
            }
            3 => {
                let mut var_hash = <crate::api::types::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Spontaneous {
                    hash: var_hash,
                    preimage: var_preimage,
                };
            }
            4 => {
                let mut var_hash =
                    <Option<crate::api::types::PaymentHash>>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
                let mut var_offerId = <crate::api::types::OfferId>::sse_decode(deserializer);
                let mut var_payerNote = <Option<String>>::sse_decode(deserializer);
                let mut var_quantity = <Option<u64>>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Bolt12Offer {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                    offer_id: var_offerId,
                    payer_note: var_payerNote,
                    quantity: var_quantity,
                };
            }
            5 => {
                let mut var_hash =
                    <Option<crate::api::types::PaymentHash>>::sse_decode(deserializer);
                let mut var_preimage =
                    <Option<crate::api::types::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<crate::api::types::PaymentSecret>>::sse_decode(deserializer);
                let mut var_payerNote = <Option<String>>::sse_decode(deserializer);
                let mut var_quantity = <Option<u64>>::sse_decode(deserializer);
                return crate::api::types::PaymentKind::Bolt12Refund {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                    payer_note: var_payerNote,
                    quantity: var_quantity,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentPreimage { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return crate::api::types::PaymentSecret { data: var_data };
    }
}

impl SseDecode for crate::api::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::PaymentStatus::Pending,
            1 => crate::api::types::PaymentStatus::Succeeded,
            2 => crate::api::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodeId = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_address = <crate::api::types::SocketAddress>::sse_decode(deserializer);
        let mut var_isConnected = <bool>::sse_decode(deserializer);
        return crate::api::types::PeerDetails {
            node_id: var_nodeId,
            address: var_address,
            is_connected: var_isConnected,
        };
    }
}

impl SseDecode for crate::api::types::PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_channelId =
                    <Option<crate::api::types::ChannelId>>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::PendingSweepBalance::PendingBroadcast {
                    channel_id: var_channelId,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            1 => {
                let mut var_channelId =
                    <Option<crate::api::types::ChannelId>>::sse_decode(deserializer);
                let mut var_latestBroadcastHeight = <u32>::sse_decode(deserializer);
                let mut var_latestSpendingTxid =
                    <crate::api::types::Txid>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                    channel_id: var_channelId,
                    latest_broadcast_height: var_latestBroadcastHeight,
                    latest_spending_txid: var_latestSpendingTxid,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            2 => {
                let mut var_channelId =
                    <Option<crate::api::types::ChannelId>>::sse_decode(deserializer);
                let mut var_latestSpendingTxid =
                    <crate::api::types::Txid>::sse_decode(deserializer);
                let mut var_confirmationHash = <String>::sse_decode(deserializer);
                let mut var_confirmationHeight = <u32>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return crate::api::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                    channel_id: var_channelId,
                    latest_spending_txid: var_latestSpendingTxid,
                    confirmation_hash: var_confirmationHash,
                    confirmation_height: var_confirmationHeight,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hex = <String>::sse_decode(deserializer);
        return crate::api::types::PublicKey { hex: var_hex };
    }
}

impl SseDecode for crate::api::unified_qr::QrPaymentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_txid = <crate::api::types::Txid>::sse_decode(deserializer);
                return crate::api::unified_qr::QrPaymentResult::Onchain { txid: var_txid };
            }
            1 => {
                let mut var_paymentId = <crate::api::types::PaymentId>::sse_decode(deserializer);
                return crate::api::unified_qr::QrPaymentResult::Bolt11 {
                    payment_id: var_paymentId,
                };
            }
            2 => {
                let mut var_paymentId = <crate::api::types::PaymentId>::sse_decode(deserializer);
                return crate::api::unified_qr::QrPaymentResult::Bolt12 {
                    payment_id: var_paymentId,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode
    for (
        crate::api::types::SocketAddress,
        crate::api::types::PublicKey,
        Option<String>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <crate::api::types::SocketAddress>::sse_decode(deserializer);
        let mut var_field1 = <crate::api::types::PublicKey>::sse_decode(deserializer);
        let mut var_field2 = <Option<String>>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::bolt12::Refund {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return crate::api::bolt12::Refund { s: var_s };
    }
}

impl SseDecode for crate::api::graph::RoutingFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_baseMsat = <u32>::sse_decode(deserializer);
        let mut var_proportionalMillionths = <u32>::sse_decode(deserializer);
        return crate::api::graph::RoutingFees {
            base_msat: var_baseMsat,
            proportional_millionths: var_proportionalMillionths,
        };
    }
}

impl SseDecode for crate::api::types::SendingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxTotalRoutingFeeMsat =
            <Option<crate::api::types::MaxTotalRoutingFeeLimit>>::sse_decode(deserializer);
        let mut var_maxTotalCltvExpiryDelta = <Option<u32>>::sse_decode(deserializer);
        let mut var_maxPathCount = <Option<u8>>::sse_decode(deserializer);
        let mut var_maxChannelSaturationPowerOfHalf = <Option<u8>>::sse_decode(deserializer);
        return crate::api::types::SendingParameters {
            max_total_routing_fee_msat: var_maxTotalRoutingFeeMsat,
            max_total_cltv_expiry_delta: var_maxTotalCltvExpiryDelta,
            max_path_count: var_maxPathCount,
            max_channel_saturation_power_of_half: var_maxChannelSaturationPowerOfHalf,
        };
    }
}

impl SseDecode for crate::api::types::SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_addr = <[u8; 4]>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::TcpIpV4 {
                    addr: var_addr,
                    port: var_port,
                };
            }
            1 => {
                let mut var_addr = <[u8; 16]>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::TcpIpV6 {
                    addr: var_addr,
                    port: var_port,
                };
            }
            2 => {
                let mut var_field0 = <[u8; 12]>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::OnionV2(var_field0);
            }
            3 => {
                let mut var_ed25519Pubkey = <[u8; 32]>::sse_decode(deserializer);
                let mut var_checksum = <u16>::sse_decode(deserializer);
                let mut var_version = <u8>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::OnionV3 {
                    ed25519_pubkey: var_ed25519Pubkey,
                    checksum: var_checksum,
                    version: var_version,
                    port: var_port,
                };
            }
            4 => {
                let mut var_addr = <String>::sse_decode(deserializer);
                let mut var_port = <u16>::sse_decode(deserializer);
                return crate::api::types::SocketAddress::Hostname {
                    addr: var_addr,
                    port: var_port,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::types::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        return crate::api::types::Txid { hash: var_hash };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for [u8; 12] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 16] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::api::types::UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::types::UserChannelId { data: var_data };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<FfiBuilder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<FfiBuilder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<FfiBuilder>> for FfiBuilder {
    fn into_into_dart(self) -> FrbWrapper<FfiBuilder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Address {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Address {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Address> for crate::api::types::Address {
    fn into_into_dart(self) -> crate::api::types::Address {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::AnchorChannelsConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.trusted_peers_no_reserve.into_into_dart().into_dart(),
            self.per_channel_reserve_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::AnchorChannelsConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::AnchorChannelsConfig>
    for crate::api::types::AnchorChannelsConfig
{
    fn into_into_dart(self) -> crate::api::types::AnchorChannelsConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BalanceDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.total_onchain_balance_sats.into_into_dart().into_dart(),
            self.spendable_onchain_balance_sats
                .into_into_dart()
                .into_dart(),
            self.total_lightning_balance_sats
                .into_into_dart()
                .into_dart(),
            self.lightning_balances.into_into_dart().into_dart(),
            self.pending_balances_from_channel_closures
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::BalanceDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BalanceDetails>
    for crate::api::types::BalanceDetails
{
    fn into_into_dart(self) -> crate::api::types::BalanceDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BalanceSource {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::HolderForceClosed => 0.into_dart(),
            Self::CounterpartyForceClosed => 1.into_dart(),
            Self::CoopClose => 2.into_dart(),
            Self::Htlc => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::BalanceSource
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BalanceSource>
    for crate::api::types::BalanceSource
{
    fn into_into_dart(self) -> crate::api::types::BalanceSource {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BestBlock {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.block_hash.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::BestBlock {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BestBlock>
    for crate::api::types::BestBlock
{
    fn into_into_dart(self) -> crate::api::types::BestBlock {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt11::Bolt11Invoice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.signed_raw_invoice.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bolt11::Bolt11Invoice
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt11::Bolt11Invoice>
    for crate::api::bolt11::Bolt11Invoice
{
    fn into_into_dart(self) -> crate::api::bolt11::Bolt11Invoice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt12::Bolt12Invoice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bolt12::Bolt12Invoice
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt12::Bolt12Invoice>
    for crate::api::bolt12::Bolt12Invoice
{
    fn into_into_dart(self) -> crate::api::bolt12::Bolt12Invoice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::utils::error::Bolt12ParseError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::utils::error::Bolt12ParseError::InvalidContinuation => {
                [0.into_dart()].into_dart()
            }
            crate::utils::error::Bolt12ParseError::InvalidBech32Hrp => [1.into_dart()].into_dart(),
            crate::utils::error::Bolt12ParseError::Bech32(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::Bolt12ParseError::Decode(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::Bolt12ParseError::InvalidSemantics(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::Bolt12ParseError::InvalidSignature(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::utils::error::Bolt12ParseError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::utils::error::Bolt12ParseError>
    for crate::utils::error::Bolt12ParseError
{
    fn into_into_dart(self) -> crate::utils::error::Bolt12ParseError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChainDataSourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::ChainDataSourceConfig::Esplora {
                server_url,
                sync_config,
            } => [
                0.into_dart(),
                server_url.into_into_dart().into_dart(),
                sync_config.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::ChainDataSourceConfig::BitcoindRpc {
                rpc_host,
                rpc_port,
                rpc_user,
                rpc_password,
            } => [
                1.into_dart(),
                rpc_host.into_into_dart().into_dart(),
                rpc_port.into_into_dart().into_dart(),
                rpc_user.into_into_dart().into_dart(),
                rpc_password.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChainDataSourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChainDataSourceConfig>
    for crate::api::types::ChainDataSourceConfig
{
    fn into_into_dart(self) -> crate::api::types::ChainDataSourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.forwarding_fee_proportional_millionths
                .into_into_dart()
                .into_dart(),
            self.forwarding_fee_base_msat.into_into_dart().into_dart(),
            self.cltv_expiry_delta.into_into_dart().into_dart(),
            self.max_dust_htlc_exposure.into_into_dart().into_dart(),
            self.force_close_avoidance_max_fee_satoshis
                .into_into_dart()
                .into_dart(),
            self.accept_underpaying_htlcs.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChannelConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelConfig>
    for crate::api::types::ChannelConfig
{
    fn into_into_dart(self) -> crate::api::types::ChannelConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.channel_id.into_into_dart().into_dart(),
            self.counterparty_node_id.into_into_dart().into_dart(),
            self.funding_txo.into_into_dart().into_dart(),
            self.channel_value_sats.into_into_dart().into_dart(),
            self.unspendable_punishment_reserve
                .into_into_dart()
                .into_dart(),
            self.user_channel_id.into_into_dart().into_dart(),
            self.feerate_sat_per_1000_weight
                .into_into_dart()
                .into_dart(),
            self.outbound_capacity_msat.into_into_dart().into_dart(),
            self.inbound_capacity_msat.into_into_dart().into_dart(),
            self.confirmations_required.into_into_dart().into_dart(),
            self.confirmations.into_into_dart().into_dart(),
            self.is_outbound.into_into_dart().into_dart(),
            self.is_channel_ready.into_into_dart().into_dart(),
            self.is_usable.into_into_dart().into_dart(),
            self.cltv_expiry_delta.into_into_dart().into_dart(),
            self.counterparty_unspendable_punishment_reserve
                .into_into_dart()
                .into_dart(),
            self.counterparty_outbound_htlc_minimum_msat
                .into_into_dart()
                .into_dart(),
            self.counterparty_outbound_htlc_maximum_msat
                .into_into_dart()
                .into_dart(),
            self.counterparty_forwarding_info_fee_base_msat
                .into_into_dart()
                .into_dart(),
            self.counterparty_forwarding_info_fee_proportional_millionths
                .into_into_dart()
                .into_dart(),
            self.counterparty_forwarding_info_cltv_expiry_delta
                .into_into_dart()
                .into_dart(),
            self.next_outbound_htlc_limit_msat
                .into_into_dart()
                .into_dart(),
            self.next_outbound_htlc_minimum_msat
                .into_into_dart()
                .into_dart(),
            self.force_close_spend_delay.into_into_dart().into_dart(),
            self.inbound_htlc_minimum_msat.into_into_dart().into_dart(),
            self.inbound_htlc_maximum_msat.into_into_dart().into_dart(),
            self.config.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChannelDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelDetails>
    for crate::api::types::ChannelDetails
{
    fn into_into_dart(self) -> crate::api::types::ChannelDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChannelId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::ChannelId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChannelId>
    for crate::api::types::ChannelId
{
    fn into_into_dart(self) -> crate::api::types::ChannelId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::ChannelInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.node_one.into_into_dart().into_dart(),
            self.one_to_two.into_into_dart().into_dart(),
            self.node_two.into_into_dart().into_dart(),
            self.two_to_one.into_into_dart().into_dart(),
            self.capacity_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::graph::ChannelInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::ChannelInfo>
    for crate::api::graph::ChannelInfo
{
    fn into_into_dart(self) -> crate::api::graph::ChannelInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::ChannelUpdateInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.last_update.into_into_dart().into_dart(),
            self.enabled.into_into_dart().into_dart(),
            self.cltv_expiry_delta.into_into_dart().into_dart(),
            self.htlc_minimum_msat.into_into_dart().into_dart(),
            self.htlc_maximum_msat.into_into_dart().into_dart(),
            self.fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::graph::ChannelUpdateInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::ChannelUpdateInfo>
    for crate::api::graph::ChannelUpdateInfo
{
    fn into_into_dart(self) -> crate::api::graph::ChannelUpdateInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ClosureReason {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::ClosureReason::PeerFeerateTooLow {
                peer_feerate_sat_per_kw,
                required_feerate_sat_per_kw,
            } => [
                0.into_dart(),
                peer_feerate_sat_per_kw.into_into_dart().into_dart(),
                required_feerate_sat_per_kw.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::ClosureReason::CounterpartyForceClosed { peer_msg } => {
                [1.into_dart(), peer_msg.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::HolderForceClosed {
                broadcasted_latest_txn,
            } => [
                2.into_dart(),
                broadcasted_latest_txn.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::ClosureReason::LegacyCooperativeClosure => {
                [3.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::CounterpartyInitiatedCooperativeClosure => {
                [4.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::LocallyInitiatedCooperativeClosure => {
                [5.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::CommitmentTxConfirmed => [6.into_dart()].into_dart(),
            crate::api::types::ClosureReason::FundingTimedOut => [7.into_dart()].into_dart(),
            crate::api::types::ClosureReason::ProcessingError { err } => {
                [8.into_dart(), err.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::DisconnectedPeer => [9.into_dart()].into_dart(),
            crate::api::types::ClosureReason::OutdatedChannelManager => {
                [10.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel => {
                [11.into_dart()].into_dart()
            }
            crate::api::types::ClosureReason::FundingBatchClosure => [12.into_dart()].into_dart(),
            crate::api::types::ClosureReason::HTLCsTimedOut => [13.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ClosureReason
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ClosureReason>
    for crate::api::types::ClosureReason
{
    fn into_into_dart(self) -> crate::api::types::ClosureReason {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Config {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.storage_dir_path.into_into_dart().into_dart(),
            self.log_dir_path.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.listening_addresses.into_into_dart().into_dart(),
            self.node_alias.into_into_dart().into_dart(),
            self.trusted_peers_0conf.into_into_dart().into_dart(),
            self.probing_liquidity_limit_multiplier
                .into_into_dart()
                .into_dart(),
            self.log_level.into_into_dart().into_dart(),
            self.anchor_channels_config.into_into_dart().into_dart(),
            self.sending_parameters.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Config {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Config> for crate::api::types::Config {
    fn into_into_dart(self) -> crate::api::types::Config {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::utils::error::DecodeError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::utils::error::DecodeError::UnknownVersion => [0.into_dart()].into_dart(),
            crate::utils::error::DecodeError::UnknownRequiredFeature => [1.into_dart()].into_dart(),
            crate::utils::error::DecodeError::InvalidValue => [2.into_dart()].into_dart(),
            crate::utils::error::DecodeError::ShortRead => [3.into_dart()].into_dart(),
            crate::utils::error::DecodeError::BadLengthDescriptor => [4.into_dart()].into_dart(),
            crate::utils::error::DecodeError::Io(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::DecodeError::UnsupportedCompression => [6.into_dart()].into_dart(),
            crate::utils::error::DecodeError::DangerousValue => [7.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::utils::error::DecodeError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::utils::error::DecodeError>
    for crate::utils::error::DecodeError
{
    fn into_into_dart(self) -> crate::utils::error::DecodeError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::EntropySourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::EntropySourceConfig::SeedFile(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::EntropySourceConfig::SeedBytes(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                mnemonic,
                passphrase,
            } => [
                2.into_dart(),
                mnemonic.into_into_dart().into_dart(),
                passphrase.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::EntropySourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::EntropySourceConfig>
    for crate::api::types::EntropySourceConfig
{
    fn into_into_dart(self) -> crate::api::types::EntropySourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::EsploraSyncConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.onchain_wallet_sync_interval_secs
                .into_into_dart()
                .into_dart(),
            self.lightning_wallet_sync_interval_secs
                .into_into_dart()
                .into_dart(),
            self.fee_rate_cache_update_interval_secs
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::EsploraSyncConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::EsploraSyncConfig>
    for crate::api::types::EsploraSyncConfig
{
    fn into_into_dart(self) -> crate::api::types::EsploraSyncConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Event {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::Event::PaymentClaimable {
                payment_id,
                payment_hash,
                claimable_amount_msat,
                claim_deadline,
            } => [
                0.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                claimable_amount_msat.into_into_dart().into_dart(),
                claim_deadline.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::PaymentSuccessful {
                payment_id,
                payment_hash,
                fee_paid_msat,
            } => [
                1.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                fee_paid_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::PaymentFailed {
                payment_id,
                payment_hash,
                reason,
            } => [
                2.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                reason.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::PaymentReceived {
                payment_id,
                payment_hash,
                amount_msat,
            } => [
                3.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                amount_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelPending {
                channel_id,
                user_channel_id,
                former_temporary_channel_id,
                counterparty_node_id,
                funding_txo,
            } => [
                4.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                former_temporary_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                funding_txo.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelReady {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => [
                5.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::Event::ChannelClosed {
                channel_id,
                user_channel_id,
                counterparty_node_id,
                reason,
            } => [
                6.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                reason.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Event {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Event> for crate::api::types::Event {
    fn into_into_dart(self) -> crate::api::types::Event {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt11::FfiBolt11Payment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bolt11::FfiBolt11Payment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt11::FfiBolt11Payment>
    for crate::api::bolt11::FfiBolt11Payment
{
    fn into_into_dart(self) -> crate::api::bolt11::FfiBolt11Payment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt12::FfiBolt12Payment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::bolt12::FfiBolt12Payment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt12::FfiBolt12Payment>
    for crate::api::bolt12::FfiBolt12Payment
{
    fn into_into_dart(self) -> crate::api::bolt12::FfiBolt12Payment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::utils::error::FfiBuilderError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::InvalidNodeAlias => 0.into_dart(),
            Self::SocketAddressParseError => 1.into_dart(),
            Self::InvalidSeedBytes => 2.into_dart(),
            Self::InvalidSeedFile => 3.into_dart(),
            Self::InvalidSystemTime => 4.into_dart(),
            Self::InvalidChannelMonitor => 5.into_dart(),
            Self::InvalidListeningAddress => 6.into_dart(),
            Self::ReadFailed => 7.into_dart(),
            Self::WriteFailed => 8.into_dart(),
            Self::StoragePathAccessFailed => 9.into_dart(),
            Self::KVStoreSetupFailed => 10.into_dart(),
            Self::WalletSetupFailed => 11.into_dart(),
            Self::LoggerSetupFailed => 12.into_dart(),
            Self::InvalidPublicKey => 13.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::utils::error::FfiBuilderError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::utils::error::FfiBuilderError>
    for crate::utils::error::FfiBuilderError
{
    fn into_into_dart(self) -> crate::utils::error::FfiBuilderError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::builder::FfiMnemonic {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.seed_phrase.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::builder::FfiMnemonic
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::builder::FfiMnemonic>
    for crate::api::builder::FfiMnemonic
{
    fn into_into_dart(self) -> crate::api::builder::FfiMnemonic {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::FfiNetworkGraph {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::graph::FfiNetworkGraph
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::FfiNetworkGraph>
    for crate::api::graph::FfiNetworkGraph
{
    fn into_into_dart(self) -> crate::api::graph::FfiNetworkGraph {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::node::FfiNode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::node::FfiNode {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::node::FfiNode> for crate::api::node::FfiNode {
    fn into_into_dart(self) -> crate::api::node::FfiNode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::utils::error::FfiNodeError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::utils::error::FfiNodeError::InvalidTxid => [0.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::AlreadyRunning => [1.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::NotRunning => [2.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::OnchainTxCreationFailed => {
                [3.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::ConnectionFailed => [4.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvoiceCreationFailed => [5.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::PaymentSendingFailed => [6.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::ProbeSendingFailed => [7.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::ChannelCreationFailed => [8.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::ChannelClosingFailed => [9.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::ChannelConfigUpdateFailed => {
                [10.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::PersistenceFailed => [11.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::WalletOperationFailed => {
                [12.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::OnchainTxSigningFailed => {
                [13.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::MessageSigningFailed => [14.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::TxSyncFailed => [15.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::GossipUpdateFailed => [16.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidAddress => [17.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidSocketAddress => [18.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidPublicKey => [19.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidSecretKey => [20.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidPaymentHash => [21.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidPaymentPreimage => {
                [22.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::InvalidPaymentSecret => [23.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidAmount => [24.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidInvoice => [25.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidChannelId => [26.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidNetwork => [27.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::DuplicatePayment => [28.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InsufficientFunds => [29.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::FeerateEstimationUpdateFailed => {
                [30.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::LiquidityRequestFailed => {
                [31.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::LiquiditySourceUnavailable => {
                [32.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::LiquidityFeeTooHigh => [33.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidPaymentId => [34.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::Decode(field0) => {
                [35.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::Bolt12Parse(field0) => {
                [36.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::InvoiceRequestCreationFailed => {
                [37.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::OfferCreationFailed => [38.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::RefundCreationFailed => [39.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::FeerateEstimationUpdateTimeout => {
                [40.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::WalletOperationTimeout => {
                [41.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::TxSyncTimeout => [42.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::GossipUpdateTimeout => [43.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidOfferId => [44.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidNodeId => [45.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidOffer => [46.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidRefund => [47.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::UnsupportedCurrency => [48.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::UriParameterParsingFailed => {
                [49.into_dart()].into_dart()
            }
            crate::utils::error::FfiNodeError::InvalidUri => [50.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidQuantity => [51.into_dart()].into_dart(),
            crate::utils::error::FfiNodeError::InvalidNodeAlias => [52.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::utils::error::FfiNodeError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::utils::error::FfiNodeError>
    for crate::utils::error::FfiNodeError
{
    fn into_into_dart(self) -> crate::utils::error::FfiNodeError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::on_chain::FfiOnChainPayment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::on_chain::FfiOnChainPayment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::on_chain::FfiOnChainPayment>
    for crate::api::on_chain::FfiOnChainPayment
{
    fn into_into_dart(self) -> crate::api::on_chain::FfiOnChainPayment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::spontaneous::FfiSpontaneousPayment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::spontaneous::FfiSpontaneousPayment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::spontaneous::FfiSpontaneousPayment>
    for crate::api::spontaneous::FfiSpontaneousPayment
{
    fn into_into_dart(self) -> crate::api::spontaneous::FfiSpontaneousPayment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::unified_qr::FfiUnifiedQrPayment {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.opaque.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::unified_qr::FfiUnifiedQrPayment
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::unified_qr::FfiUnifiedQrPayment>
    for crate::api::unified_qr::FfiUnifiedQrPayment
{
    fn into_into_dart(self) -> crate::api::unified_qr::FfiUnifiedQrPayment {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::GossipSourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::GossipSourceConfig::P2PNetwork => [0.into_dart()].into_dart(),
            crate::api::types::GossipSourceConfig::RapidGossipSync(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::GossipSourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::GossipSourceConfig>
    for crate::api::types::GossipSourceConfig
{
    fn into_into_dart(self) -> crate::api::types::GossipSourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LightningBalance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::LightningBalance::ClaimableOnChannelClose {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                transaction_fee_satoshis,
                outbound_payment_htlc_rounded_msat,
                outbound_forwarded_htlc_rounded_msat,
                inbound_claiming_htlc_rounded_msat,
                inbound_htlc_rounded_msat,
            } => [
                0.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                transaction_fee_satoshis.into_into_dart().into_dart(),
                outbound_payment_htlc_rounded_msat
                    .into_into_dart()
                    .into_dart(),
                outbound_forwarded_htlc_rounded_msat
                    .into_into_dart()
                    .into_dart(),
                inbound_claiming_htlc_rounded_msat
                    .into_into_dart()
                    .into_dart(),
                inbound_htlc_rounded_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::ClaimableAwaitingConfirmations {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                confirmation_height,
                source,
            } => [
                1.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                confirmation_height.into_into_dart().into_dart(),
                source.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::ContentiousClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                timeout_height,
                payment_hash,
                payment_preimage,
            } => [
                2.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                timeout_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                payment_preimage.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                claimable_height,
                payment_hash,
                outbound_payment,
            } => [
                3.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                claimable_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                outbound_payment.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::MaybePreimageClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                expiry_height,
                payment_hash,
            } => [
                4.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                expiry_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => [
                5.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LightningBalance
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LightningBalance>
    for crate::api::types::LightningBalance
{
    fn into_into_dart(self) -> crate::api::types::LightningBalance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LiquiditySourceConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.lsps2_service.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LiquiditySourceConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LiquiditySourceConfig>
    for crate::api::types::LiquiditySourceConfig
{
    fn into_into_dart(self) -> crate::api::types::LiquiditySourceConfig {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LogLevel {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Gossip => 0.into_dart(),
            Self::Trace => 1.into_dart(),
            Self::Debug => 2.into_dart(),
            Self::Info => 3.into_dart(),
            Self::Warn => 4.into_dart(),
            Self::Error => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::LogLevel {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LogLevel>
    for crate::api::types::LogLevel
{
    fn into_into_dart(self) -> crate::api::types::LogLevel {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LSPFeeLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.max_total_opening_fee_msat.into_into_dart().into_dart(),
            self.max_proportional_opening_fee_ppm_msat
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LSPFeeLimits
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LSPFeeLimits>
    for crate::api::types::LSPFeeLimits
{
    fn into_into_dart(self) -> crate::api::types::LSPFeeLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::MaxDustHTLCExposure {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::MaxDustHTLCExposure
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::MaxDustHTLCExposure>
    for crate::api::types::MaxDustHTLCExposure
{
    fn into_into_dart(self) -> crate::api::types::MaxDustHTLCExposure {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::MaxTotalRoutingFeeLimit {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::MaxTotalRoutingFeeLimit::NoFeeCap => [0.into_dart()].into_dart(),
            crate::api::types::MaxTotalRoutingFeeLimit::FeeCap { amount_msat } => {
                [1.into_dart(), amount_msat.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::MaxTotalRoutingFeeLimit
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::MaxTotalRoutingFeeLimit>
    for crate::api::types::MaxTotalRoutingFeeLimit
{
    fn into_into_dart(self) -> crate::api::types::MaxTotalRoutingFeeLimit {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Network {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Bitcoin => 0.into_dart(),
            Self::Testnet => 1.into_dart(),
            Self::Signet => 2.into_dart(),
            Self::Regtest => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Network {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Network> for crate::api::types::Network {
    fn into_into_dart(self) -> crate::api::types::Network {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::NodeAlias {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::NodeAlias {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::NodeAlias>
    for crate::api::types::NodeAlias
{
    fn into_into_dart(self) -> crate::api::types::NodeAlias {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::NodeAnnouncementInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.last_update.into_into_dart().into_dart(),
            self.alias.into_into_dart().into_dart(),
            self.addresses.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::graph::NodeAnnouncementInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::NodeAnnouncementInfo>
    for crate::api::graph::NodeAnnouncementInfo
{
    fn into_into_dart(self) -> crate::api::graph::NodeAnnouncementInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::NodeId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.compressed.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::graph::NodeId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::NodeId> for crate::api::graph::NodeId {
    fn into_into_dart(self) -> crate::api::graph::NodeId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::NodeInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.channels.into_into_dart().into_dart(),
            self.announcement_info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::graph::NodeInfo {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::NodeInfo>
    for crate::api::graph::NodeInfo
{
    fn into_into_dart(self) -> crate::api::graph::NodeInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::NodeStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.is_running.into_into_dart().into_dart(),
            self.is_listening.into_into_dart().into_dart(),
            self.current_best_block.into_into_dart().into_dart(),
            self.latest_lightning_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_onchain_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_fee_rate_cache_update_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_rgs_snapshot_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_node_announcement_broadcast_timestamp
                .into_into_dart()
                .into_dart(),
            self.latest_channel_monitor_archival_height
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::NodeStatus {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::NodeStatus>
    for crate::api::types::NodeStatus
{
    fn into_into_dart(self) -> crate::api::types::NodeStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt12::Offer {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::bolt12::Offer {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt12::Offer> for crate::api::bolt12::Offer {
    fn into_into_dart(self) -> crate::api::bolt12::Offer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::OfferId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::OfferId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::OfferId> for crate::api::types::OfferId {
    fn into_into_dart(self) -> crate::api::types::OfferId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::OutPoint {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.txid.into_into_dart().into_dart(),
            self.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::OutPoint {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::OutPoint>
    for crate::api::types::OutPoint
{
    fn into_into_dart(self) -> crate::api::types::OutPoint {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.amount_msat.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.status.into_into_dart().into_dart(),
            self.latest_update_timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentDetails>
    for crate::api::types::PaymentDetails
{
    fn into_into_dart(self) -> crate::api::types::PaymentDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentDirection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Inbound => 0.into_dart(),
            Self::Outbound => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentDirection
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentDirection>
    for crate::api::types::PaymentDirection
{
    fn into_into_dart(self) -> crate::api::types::PaymentDirection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentFailureReason {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::RecipientRejected => 0.into_dart(),
            Self::UserAbandoned => 1.into_dart(),
            Self::RetriesExhausted => 2.into_dart(),
            Self::PaymentExpired => 3.into_dart(),
            Self::RouteNotFound => 4.into_dart(),
            Self::UnexpectedError => 5.into_dart(),
            Self::UnknownRequiredFeatures => 6.into_dart(),
            Self::InvoiceRequestExpired => 7.into_dart(),
            Self::InvoiceRequestRejected => 8.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentFailureReason
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentFailureReason>
    for crate::api::types::PaymentFailureReason
{
    fn into_into_dart(self) -> crate::api::types::PaymentFailureReason {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentHash {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentHash
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentHash>
    for crate::api::types::PaymentHash
{
    fn into_into_dart(self) -> crate::api::types::PaymentHash {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PaymentId {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentId>
    for crate::api::types::PaymentId
{
    fn into_into_dart(self) -> crate::api::types::PaymentId {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::PaymentKind::Onchain => [0.into_dart()].into_dart(),
            crate::api::types::PaymentKind::Bolt11 {
                hash,
                preimage,
                secret,
            } => [
                1.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PaymentKind::Bolt11Jit {
                hash,
                preimage,
                secret,
                lsp_fee_limits,
            } => [
                2.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
                lsp_fee_limits.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PaymentKind::Spontaneous { hash, preimage } => [
                3.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PaymentKind::Bolt12Offer {
                hash,
                preimage,
                secret,
                offer_id,
                payer_note,
                quantity,
            } => [
                4.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
                offer_id.into_into_dart().into_dart(),
                payer_note.into_into_dart().into_dart(),
                quantity.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PaymentKind::Bolt12Refund {
                hash,
                preimage,
                secret,
                payer_note,
                quantity,
            } => [
                5.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
                payer_note.into_into_dart().into_dart(),
                quantity.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentKind>
    for crate::api::types::PaymentKind
{
    fn into_into_dart(self) -> crate::api::types::PaymentKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentPreimage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentPreimage
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentPreimage>
    for crate::api::types::PaymentPreimage
{
    fn into_into_dart(self) -> crate::api::types::PaymentPreimage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentSecret {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentSecret
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentSecret>
    for crate::api::types::PaymentSecret
{
    fn into_into_dart(self) -> crate::api::types::PaymentSecret {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PaymentStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Pending => 0.into_dart(),
            Self::Succeeded => 1.into_dart(),
            Self::Failed => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PaymentStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PaymentStatus>
    for crate::api::types::PaymentStatus
{
    fn into_into_dart(self) -> crate::api::types::PaymentStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PeerDetails {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.node_id.into_into_dart().into_dart(),
            self.address.into_into_dart().into_dart(),
            self.is_connected.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PeerDetails
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PeerDetails>
    for crate::api::types::PeerDetails
{
    fn into_into_dart(self) -> crate::api::types::PeerDetails {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PendingSweepBalance {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::PendingSweepBalance::PendingBroadcast {
                channel_id,
                amount_satoshis,
            } => [
                0.into_dart(),
                channel_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                channel_id,
                latest_broadcast_height,
                latest_spending_txid,
                amount_satoshis,
            } => [
                1.into_dart(),
                channel_id.into_into_dart().into_dart(),
                latest_broadcast_height.into_into_dart().into_dart(),
                latest_spending_txid.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                channel_id,
                latest_spending_txid,
                confirmation_hash,
                confirmation_height,
                amount_satoshis,
            } => [
                2.into_dart(),
                channel_id.into_into_dart().into_dart(),
                latest_spending_txid.into_into_dart().into_dart(),
                confirmation_hash.into_into_dart().into_dart(),
                confirmation_height.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::PendingSweepBalance
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PendingSweepBalance>
    for crate::api::types::PendingSweepBalance
{
    fn into_into_dart(self) -> crate::api::types::PendingSweepBalance {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PublicKey {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.hex.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PublicKey {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PublicKey>
    for crate::api::types::PublicKey
{
    fn into_into_dart(self) -> crate::api::types::PublicKey {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::unified_qr::QrPaymentResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::unified_qr::QrPaymentResult::Onchain { txid } => {
                [0.into_dart(), txid.into_into_dart().into_dart()].into_dart()
            }
            crate::api::unified_qr::QrPaymentResult::Bolt11 { payment_id } => {
                [1.into_dart(), payment_id.into_into_dart().into_dart()].into_dart()
            }
            crate::api::unified_qr::QrPaymentResult::Bolt12 { payment_id } => {
                [2.into_dart(), payment_id.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::unified_qr::QrPaymentResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::unified_qr::QrPaymentResult>
    for crate::api::unified_qr::QrPaymentResult
{
    fn into_into_dart(self) -> crate::api::unified_qr::QrPaymentResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::bolt12::Refund {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::bolt12::Refund {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::bolt12::Refund> for crate::api::bolt12::Refund {
    fn into_into_dart(self) -> crate::api::bolt12::Refund {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::graph::RoutingFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.base_msat.into_into_dart().into_dart(),
            self.proportional_millionths.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::graph::RoutingFees
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::graph::RoutingFees>
    for crate::api::graph::RoutingFees
{
    fn into_into_dart(self) -> crate::api::graph::RoutingFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SendingParameters {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.max_total_routing_fee_msat.into_into_dart().into_dart(),
            self.max_total_cltv_expiry_delta
                .into_into_dart()
                .into_dart(),
            self.max_path_count.into_into_dart().into_dart(),
            self.max_channel_saturation_power_of_half
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SendingParameters
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SendingParameters>
    for crate::api::types::SendingParameters
{
    fn into_into_dart(self) -> crate::api::types::SendingParameters {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SocketAddress {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::SocketAddress::TcpIpV4 { addr, port } => [
                0.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::TcpIpV6 { addr, port } => [
                1.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::OnionV2(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::SocketAddress::OnionV3 {
                ed25519_pubkey,
                checksum,
                version,
                port,
            } => [
                3.into_dart(),
                ed25519_pubkey.into_into_dart().into_dart(),
                checksum.into_into_dart().into_dart(),
                version.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::types::SocketAddress::Hostname { addr, port } => [
                4.into_dart(),
                addr.into_into_dart().into_dart(),
                port.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SocketAddress
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SocketAddress>
    for crate::api::types::SocketAddress
{
    fn into_into_dart(self) -> crate::api::types::SocketAddress {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Txid {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.hash.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Txid {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Txid> for crate::api::types::Txid {
    fn into_into_dart(self) -> crate::api::types::Txid {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::UserChannelId {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::UserChannelId
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::UserChannelId>
    for crate::api::types::UserChannelId
{
    fn into_into_dart(self) -> crate::api::types::UserChannelId {
        self
    }
}

impl SseEncode for FfiBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::Builder> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::Node> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::graph::NetworkGraph> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::Bolt11Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::Bolt12Payment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::OnchainPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::SpontaneousPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<ldk_node::payment::UnifiedQrPayment> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::types::Address {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for crate::api::types::AnchorChannelsConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::types::PublicKey>>::sse_encode(self.trusted_peers_no_reserve, serializer);
        <u64>::sse_encode(self.per_channel_reserve_sats, serializer);
    }
}

impl SseEncode for crate::api::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.total_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.spendable_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.total_lightning_balance_sats, serializer);
        <Vec<crate::api::types::LightningBalance>>::sse_encode(self.lightning_balances, serializer);
        <Vec<crate::api::types::PendingSweepBalance>>::sse_encode(
            self.pending_balances_from_channel_closures,
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::BalanceSource {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::BalanceSource::HolderForceClosed => 0,
                crate::api::types::BalanceSource::CounterpartyForceClosed => 1,
                crate::api::types::BalanceSource::CoopClose => 2,
                crate::api::types::BalanceSource::Htlc => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.block_hash, serializer);
        <u32>::sse_encode(self.height, serializer);
    }
}

impl SseEncode for crate::api::bolt11::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.signed_raw_invoice, serializer);
    }
}

impl SseEncode for crate::api::bolt12::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::utils::error::Bolt12ParseError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::utils::error::Bolt12ParseError::InvalidContinuation => {
                <i32>::sse_encode(0, serializer);
            }
            crate::utils::error::Bolt12ParseError::InvalidBech32Hrp => {
                <i32>::sse_encode(1, serializer);
            }
            crate::utils::error::Bolt12ParseError::Bech32(field0) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::utils::error::Bolt12ParseError::Decode(field0) => {
                <i32>::sse_encode(3, serializer);
                <crate::utils::error::DecodeError>::sse_encode(field0, serializer);
            }
            crate::utils::error::Bolt12ParseError::InvalidSemantics(field0) => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::utils::error::Bolt12ParseError::InvalidSignature(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::types::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::ChainDataSourceConfig::Esplora {
                server_url,
                sync_config,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(server_url, serializer);
                <Option<crate::api::types::EsploraSyncConfig>>::sse_encode(sync_config, serializer);
            }
            crate::api::types::ChainDataSourceConfig::BitcoindRpc {
                rpc_host,
                rpc_port,
                rpc_user,
                rpc_password,
            } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(rpc_host, serializer);
                <u16>::sse_encode(rpc_port, serializer);
                <String>::sse_encode(rpc_user, serializer);
                <String>::sse_encode(rpc_password, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.forwarding_fee_proportional_millionths, serializer);
        <u32>::sse_encode(self.forwarding_fee_base_msat, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <crate::api::types::MaxDustHTLCExposure>::sse_encode(
            self.max_dust_htlc_exposure,
            serializer,
        );
        <u64>::sse_encode(self.force_close_avoidance_max_fee_satoshis, serializer);
        <bool>::sse_encode(self.accept_underpaying_htlcs, serializer);
    }
}

impl SseEncode for crate::api::types::ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::ChannelId>::sse_encode(self.channel_id, serializer);
        <crate::api::types::PublicKey>::sse_encode(self.counterparty_node_id, serializer);
        <Option<crate::api::types::OutPoint>>::sse_encode(self.funding_txo, serializer);
        <u64>::sse_encode(self.channel_value_sats, serializer);
        <Option<u64>>::sse_encode(self.unspendable_punishment_reserve, serializer);
        <crate::api::types::UserChannelId>::sse_encode(self.user_channel_id, serializer);
        <u32>::sse_encode(self.feerate_sat_per_1000_weight, serializer);
        <u64>::sse_encode(self.outbound_capacity_msat, serializer);
        <u64>::sse_encode(self.inbound_capacity_msat, serializer);
        <Option<u32>>::sse_encode(self.confirmations_required, serializer);
        <Option<u32>>::sse_encode(self.confirmations, serializer);
        <bool>::sse_encode(self.is_outbound, serializer);
        <bool>::sse_encode(self.is_channel_ready, serializer);
        <bool>::sse_encode(self.is_usable, serializer);
        <Option<u16>>::sse_encode(self.cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.counterparty_unspendable_punishment_reserve, serializer);
        <Option<u64>>::sse_encode(self.counterparty_outbound_htlc_minimum_msat, serializer);
        <Option<u64>>::sse_encode(self.counterparty_outbound_htlc_maximum_msat, serializer);
        <Option<u32>>::sse_encode(self.counterparty_forwarding_info_fee_base_msat, serializer);
        <Option<u32>>::sse_encode(
            self.counterparty_forwarding_info_fee_proportional_millionths,
            serializer,
        );
        <Option<u16>>::sse_encode(
            self.counterparty_forwarding_info_cltv_expiry_delta,
            serializer,
        );
        <u64>::sse_encode(self.next_outbound_htlc_limit_msat, serializer);
        <u64>::sse_encode(self.next_outbound_htlc_minimum_msat, serializer);
        <Option<u16>>::sse_encode(self.force_close_spend_delay, serializer);
        <u64>::sse_encode(self.inbound_htlc_minimum_msat, serializer);
        <Option<u64>>::sse_encode(self.inbound_htlc_maximum_msat, serializer);
        <crate::api::types::ChannelConfig>::sse_encode(self.config, serializer);
    }
}

impl SseEncode for crate::api::types::ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::graph::ChannelInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::graph::NodeId>::sse_encode(self.node_one, serializer);
        <Option<crate::api::graph::ChannelUpdateInfo>>::sse_encode(self.one_to_two, serializer);
        <crate::api::graph::NodeId>::sse_encode(self.node_two, serializer);
        <Option<crate::api::graph::ChannelUpdateInfo>>::sse_encode(self.two_to_one, serializer);
        <Option<u64>>::sse_encode(self.capacity_sats, serializer);
    }
}

impl SseEncode for crate::api::graph::ChannelUpdateInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.last_update, serializer);
        <bool>::sse_encode(self.enabled, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.htlc_minimum_msat, serializer);
        <u64>::sse_encode(self.htlc_maximum_msat, serializer);
        <crate::api::graph::RoutingFees>::sse_encode(self.fees, serializer);
    }
}

impl SseEncode for crate::api::types::ClosureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::ClosureReason::PeerFeerateTooLow {
                peer_feerate_sat_per_kw,
                required_feerate_sat_per_kw,
            } => {
                <i32>::sse_encode(0, serializer);
                <u32>::sse_encode(peer_feerate_sat_per_kw, serializer);
                <u32>::sse_encode(required_feerate_sat_per_kw, serializer);
            }
            crate::api::types::ClosureReason::CounterpartyForceClosed { peer_msg } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(peer_msg, serializer);
            }
            crate::api::types::ClosureReason::HolderForceClosed {
                broadcasted_latest_txn,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<bool>>::sse_encode(broadcasted_latest_txn, serializer);
            }
            crate::api::types::ClosureReason::LegacyCooperativeClosure => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::types::ClosureReason::CounterpartyInitiatedCooperativeClosure => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::types::ClosureReason::LocallyInitiatedCooperativeClosure => {
                <i32>::sse_encode(5, serializer);
            }
            crate::api::types::ClosureReason::CommitmentTxConfirmed => {
                <i32>::sse_encode(6, serializer);
            }
            crate::api::types::ClosureReason::FundingTimedOut => {
                <i32>::sse_encode(7, serializer);
            }
            crate::api::types::ClosureReason::ProcessingError { err } => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(err, serializer);
            }
            crate::api::types::ClosureReason::DisconnectedPeer => {
                <i32>::sse_encode(9, serializer);
            }
            crate::api::types::ClosureReason::OutdatedChannelManager => {
                <i32>::sse_encode(10, serializer);
            }
            crate::api::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel => {
                <i32>::sse_encode(11, serializer);
            }
            crate::api::types::ClosureReason::FundingBatchClosure => {
                <i32>::sse_encode(12, serializer);
            }
            crate::api::types::ClosureReason::HTLCsTimedOut => {
                <i32>::sse_encode(13, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.storage_dir_path, serializer);
        <Option<String>>::sse_encode(self.log_dir_path, serializer);
        <crate::api::types::Network>::sse_encode(self.network, serializer);
        <Option<Vec<crate::api::types::SocketAddress>>>::sse_encode(
            self.listening_addresses,
            serializer,
        );
        <Option<crate::api::types::NodeAlias>>::sse_encode(self.node_alias, serializer);
        <Vec<crate::api::types::PublicKey>>::sse_encode(self.trusted_peers_0conf, serializer);
        <u64>::sse_encode(self.probing_liquidity_limit_multiplier, serializer);
        <crate::api::types::LogLevel>::sse_encode(self.log_level, serializer);
        <Option<crate::api::types::AnchorChannelsConfig>>::sse_encode(
            self.anchor_channels_config,
            serializer,
        );
        <Option<crate::api::types::SendingParameters>>::sse_encode(
            self.sending_parameters,
            serializer,
        );
    }
}

impl SseEncode for crate::utils::error::DecodeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::utils::error::DecodeError::UnknownVersion => {
                <i32>::sse_encode(0, serializer);
            }
            crate::utils::error::DecodeError::UnknownRequiredFeature => {
                <i32>::sse_encode(1, serializer);
            }
            crate::utils::error::DecodeError::InvalidValue => {
                <i32>::sse_encode(2, serializer);
            }
            crate::utils::error::DecodeError::ShortRead => {
                <i32>::sse_encode(3, serializer);
            }
            crate::utils::error::DecodeError::BadLengthDescriptor => {
                <i32>::sse_encode(4, serializer);
            }
            crate::utils::error::DecodeError::Io(field0) => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::utils::error::DecodeError::UnsupportedCompression => {
                <i32>::sse_encode(6, serializer);
            }
            crate::utils::error::DecodeError::DangerousValue => {
                <i32>::sse_encode(7, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::EntropySourceConfig::SeedFile(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::types::EntropySourceConfig::SeedBytes(field0) => {
                <i32>::sse_encode(1, serializer);
                <[u8; 64]>::sse_encode(field0, serializer);
            }
            crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                mnemonic,
                passphrase,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::builder::FfiMnemonic>::sse_encode(mnemonic, serializer);
                <Option<String>>::sse_encode(passphrase, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::EsploraSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.onchain_wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.lightning_wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.fee_rate_cache_update_interval_secs, serializer);
    }
}

impl SseEncode for crate::api::types::Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::Event::PaymentClaimable {
                payment_id,
                payment_hash,
                claimable_amount_msat,
                claim_deadline,
            } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::types::PaymentId>::sse_encode(payment_id, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <u64>::sse_encode(claimable_amount_msat, serializer);
                <Option<u32>>::sse_encode(claim_deadline, serializer);
            }
            crate::api::types::Event::PaymentSuccessful {
                payment_id,
                payment_hash,
                fee_paid_msat,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<crate::api::types::PaymentId>>::sse_encode(payment_id, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <Option<u64>>::sse_encode(fee_paid_msat, serializer);
            }
            crate::api::types::Event::PaymentFailed {
                payment_id,
                payment_hash,
                reason,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<crate::api::types::PaymentId>>::sse_encode(payment_id, serializer);
                <Option<crate::api::types::PaymentHash>>::sse_encode(payment_hash, serializer);
                <Option<crate::api::types::PaymentFailureReason>>::sse_encode(reason, serializer);
            }
            crate::api::types::Event::PaymentReceived {
                payment_id,
                payment_hash,
                amount_msat,
            } => {
                <i32>::sse_encode(3, serializer);
                <Option<crate::api::types::PaymentId>>::sse_encode(payment_id, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <u64>::sse_encode(amount_msat, serializer);
            }
            crate::api::types::Event::ChannelPending {
                channel_id,
                user_channel_id,
                former_temporary_channel_id,
                counterparty_node_id,
                funding_txo,
            } => {
                <i32>::sse_encode(4, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <crate::api::types::ChannelId>::sse_encode(former_temporary_channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <crate::api::types::OutPoint>::sse_encode(funding_txo, serializer);
            }
            crate::api::types::Event::ChannelReady {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => {
                <i32>::sse_encode(5, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <Option<crate::api::types::PublicKey>>::sse_encode(
                    counterparty_node_id,
                    serializer,
                );
            }
            crate::api::types::Event::ChannelClosed {
                channel_id,
                user_channel_id,
                counterparty_node_id,
                reason,
            } => {
                <i32>::sse_encode(6, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::UserChannelId>::sse_encode(user_channel_id, serializer);
                <Option<crate::api::types::PublicKey>>::sse_encode(
                    counterparty_node_id,
                    serializer,
                );
                <Option<crate::api::types::ClosureReason>>::sse_encode(reason, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::bolt11::FfiBolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::Bolt11Payment>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::bolt12::FfiBolt12Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::Bolt12Payment>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::utils::error::FfiBuilderError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::utils::error::FfiBuilderError::InvalidNodeAlias => 0,
                crate::utils::error::FfiBuilderError::SocketAddressParseError => 1,
                crate::utils::error::FfiBuilderError::InvalidSeedBytes => 2,
                crate::utils::error::FfiBuilderError::InvalidSeedFile => 3,
                crate::utils::error::FfiBuilderError::InvalidSystemTime => 4,
                crate::utils::error::FfiBuilderError::InvalidChannelMonitor => 5,
                crate::utils::error::FfiBuilderError::InvalidListeningAddress => 6,
                crate::utils::error::FfiBuilderError::ReadFailed => 7,
                crate::utils::error::FfiBuilderError::WriteFailed => 8,
                crate::utils::error::FfiBuilderError::StoragePathAccessFailed => 9,
                crate::utils::error::FfiBuilderError::KVStoreSetupFailed => 10,
                crate::utils::error::FfiBuilderError::WalletSetupFailed => 11,
                crate::utils::error::FfiBuilderError::LoggerSetupFailed => 12,
                crate::utils::error::FfiBuilderError::InvalidPublicKey => 13,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::builder::FfiMnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.seed_phrase, serializer);
    }
}

impl SseEncode for crate::api::graph::FfiNetworkGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::graph::NetworkGraph>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::node::FfiNode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::Node>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::utils::error::FfiNodeError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::utils::error::FfiNodeError::InvalidTxid => {
                <i32>::sse_encode(0, serializer);
            }
            crate::utils::error::FfiNodeError::AlreadyRunning => {
                <i32>::sse_encode(1, serializer);
            }
            crate::utils::error::FfiNodeError::NotRunning => {
                <i32>::sse_encode(2, serializer);
            }
            crate::utils::error::FfiNodeError::OnchainTxCreationFailed => {
                <i32>::sse_encode(3, serializer);
            }
            crate::utils::error::FfiNodeError::ConnectionFailed => {
                <i32>::sse_encode(4, serializer);
            }
            crate::utils::error::FfiNodeError::InvoiceCreationFailed => {
                <i32>::sse_encode(5, serializer);
            }
            crate::utils::error::FfiNodeError::PaymentSendingFailed => {
                <i32>::sse_encode(6, serializer);
            }
            crate::utils::error::FfiNodeError::ProbeSendingFailed => {
                <i32>::sse_encode(7, serializer);
            }
            crate::utils::error::FfiNodeError::ChannelCreationFailed => {
                <i32>::sse_encode(8, serializer);
            }
            crate::utils::error::FfiNodeError::ChannelClosingFailed => {
                <i32>::sse_encode(9, serializer);
            }
            crate::utils::error::FfiNodeError::ChannelConfigUpdateFailed => {
                <i32>::sse_encode(10, serializer);
            }
            crate::utils::error::FfiNodeError::PersistenceFailed => {
                <i32>::sse_encode(11, serializer);
            }
            crate::utils::error::FfiNodeError::WalletOperationFailed => {
                <i32>::sse_encode(12, serializer);
            }
            crate::utils::error::FfiNodeError::OnchainTxSigningFailed => {
                <i32>::sse_encode(13, serializer);
            }
            crate::utils::error::FfiNodeError::MessageSigningFailed => {
                <i32>::sse_encode(14, serializer);
            }
            crate::utils::error::FfiNodeError::TxSyncFailed => {
                <i32>::sse_encode(15, serializer);
            }
            crate::utils::error::FfiNodeError::GossipUpdateFailed => {
                <i32>::sse_encode(16, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidAddress => {
                <i32>::sse_encode(17, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidSocketAddress => {
                <i32>::sse_encode(18, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidPublicKey => {
                <i32>::sse_encode(19, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidSecretKey => {
                <i32>::sse_encode(20, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidPaymentHash => {
                <i32>::sse_encode(21, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidPaymentPreimage => {
                <i32>::sse_encode(22, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidPaymentSecret => {
                <i32>::sse_encode(23, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidAmount => {
                <i32>::sse_encode(24, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidInvoice => {
                <i32>::sse_encode(25, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidChannelId => {
                <i32>::sse_encode(26, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidNetwork => {
                <i32>::sse_encode(27, serializer);
            }
            crate::utils::error::FfiNodeError::DuplicatePayment => {
                <i32>::sse_encode(28, serializer);
            }
            crate::utils::error::FfiNodeError::InsufficientFunds => {
                <i32>::sse_encode(29, serializer);
            }
            crate::utils::error::FfiNodeError::FeerateEstimationUpdateFailed => {
                <i32>::sse_encode(30, serializer);
            }
            crate::utils::error::FfiNodeError::LiquidityRequestFailed => {
                <i32>::sse_encode(31, serializer);
            }
            crate::utils::error::FfiNodeError::LiquiditySourceUnavailable => {
                <i32>::sse_encode(32, serializer);
            }
            crate::utils::error::FfiNodeError::LiquidityFeeTooHigh => {
                <i32>::sse_encode(33, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidPaymentId => {
                <i32>::sse_encode(34, serializer);
            }
            crate::utils::error::FfiNodeError::Decode(field0) => {
                <i32>::sse_encode(35, serializer);
                <crate::utils::error::DecodeError>::sse_encode(field0, serializer);
            }
            crate::utils::error::FfiNodeError::Bolt12Parse(field0) => {
                <i32>::sse_encode(36, serializer);
                <crate::utils::error::Bolt12ParseError>::sse_encode(field0, serializer);
            }
            crate::utils::error::FfiNodeError::InvoiceRequestCreationFailed => {
                <i32>::sse_encode(37, serializer);
            }
            crate::utils::error::FfiNodeError::OfferCreationFailed => {
                <i32>::sse_encode(38, serializer);
            }
            crate::utils::error::FfiNodeError::RefundCreationFailed => {
                <i32>::sse_encode(39, serializer);
            }
            crate::utils::error::FfiNodeError::FeerateEstimationUpdateTimeout => {
                <i32>::sse_encode(40, serializer);
            }
            crate::utils::error::FfiNodeError::WalletOperationTimeout => {
                <i32>::sse_encode(41, serializer);
            }
            crate::utils::error::FfiNodeError::TxSyncTimeout => {
                <i32>::sse_encode(42, serializer);
            }
            crate::utils::error::FfiNodeError::GossipUpdateTimeout => {
                <i32>::sse_encode(43, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidOfferId => {
                <i32>::sse_encode(44, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidNodeId => {
                <i32>::sse_encode(45, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidOffer => {
                <i32>::sse_encode(46, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidRefund => {
                <i32>::sse_encode(47, serializer);
            }
            crate::utils::error::FfiNodeError::UnsupportedCurrency => {
                <i32>::sse_encode(48, serializer);
            }
            crate::utils::error::FfiNodeError::UriParameterParsingFailed => {
                <i32>::sse_encode(49, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidUri => {
                <i32>::sse_encode(50, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidQuantity => {
                <i32>::sse_encode(51, serializer);
            }
            crate::utils::error::FfiNodeError::InvalidNodeAlias => {
                <i32>::sse_encode(52, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::on_chain::FfiOnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::OnchainPayment>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::spontaneous::FfiSpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::SpontaneousPayment>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::unified_qr::FfiUnifiedQrPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<ldk_node::payment::UnifiedQrPayment>>::sse_encode(self.opaque, serializer);
    }
}

impl SseEncode for crate::api::types::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::GossipSourceConfig::P2PNetwork => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::GossipSourceConfig::RapidGossipSync(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::types::LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::LightningBalance::ClaimableOnChannelClose {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                transaction_fee_satoshis,
                outbound_payment_htlc_rounded_msat,
                outbound_forwarded_htlc_rounded_msat,
                inbound_claiming_htlc_rounded_msat,
                inbound_htlc_rounded_msat,
            } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u64>::sse_encode(transaction_fee_satoshis, serializer);
                <u64>::sse_encode(outbound_payment_htlc_rounded_msat, serializer);
                <u64>::sse_encode(outbound_forwarded_htlc_rounded_msat, serializer);
                <u64>::sse_encode(inbound_claiming_htlc_rounded_msat, serializer);
                <u64>::sse_encode(inbound_htlc_rounded_msat, serializer);
            }
            crate::api::types::LightningBalance::ClaimableAwaitingConfirmations {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                confirmation_height,
                source,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(confirmation_height, serializer);
                <crate::api::types::BalanceSource>::sse_encode(source, serializer);
            }
            crate::api::types::LightningBalance::ContentiousClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                timeout_height,
                payment_hash,
                payment_preimage,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(timeout_height, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <crate::api::types::PaymentPreimage>::sse_encode(payment_preimage, serializer);
            }
            crate::api::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                claimable_height,
                payment_hash,
                outbound_payment,
            } => {
                <i32>::sse_encode(3, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(claimable_height, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
                <bool>::sse_encode(outbound_payment, serializer);
            }
            crate::api::types::LightningBalance::MaybePreimageClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                expiry_height,
                payment_hash,
            } => {
                <i32>::sse_encode(4, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(expiry_height, serializer);
                <crate::api::types::PaymentHash>::sse_encode(payment_hash, serializer);
            }
            crate::api::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => {
                <i32>::sse_encode(5, serializer);
                <crate::api::types::ChannelId>::sse_encode(channel_id, serializer);
                <crate::api::types::PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <(
            crate::api::types::SocketAddress,
            crate::api::types::PublicKey,
            Option<String>,
        )>::sse_encode(self.lsps2_service, serializer);
    }
}

impl SseEncode for Vec<crate::api::types::ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::ChannelDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::LightningBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::graph::NodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::graph::NodeId>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PaymentDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PeerDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PendingSweepBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::PublicKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::types::SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::types::SocketAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::LogLevel::Gossip => 0,
                crate::api::types::LogLevel::Trace => 1,
                crate::api::types::LogLevel::Debug => 2,
                crate::api::types::LogLevel::Info => 3,
                crate::api::types::LogLevel::Warn => 4,
                crate::api::types::LogLevel::Error => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::LSPFeeLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.max_total_opening_fee_msat, serializer);
        <Option<u64>>::sse_encode(self.max_proportional_opening_fee_ppm_msat, serializer);
    }
}

impl SseEncode for crate::api::types::MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(field0) => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(field0, serializer);
            }
            crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(field0) => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::MaxTotalRoutingFeeLimit {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::MaxTotalRoutingFeeLimit::NoFeeCap => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::MaxTotalRoutingFeeLimit::FeeCap { amount_msat } => {
                <i32>::sse_encode(1, serializer);
                <u64>::sse_encode(amount_msat, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Network::Bitcoin => 0,
                crate::api::types::Network::Testnet => 1,
                crate::api::types::Network::Signet => 2,
                crate::api::types::Network::Regtest => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::NodeAlias {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::graph::NodeAnnouncementInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.last_update, serializer);
        <String>::sse_encode(self.alias, serializer);
        <Vec<crate::api::types::SocketAddress>>::sse_encode(self.addresses, serializer);
    }
}

impl SseEncode for crate::api::graph::NodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.compressed, serializer);
    }
}

impl SseEncode for crate::api::graph::NodeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u64>>::sse_encode(self.channels, serializer);
        <Option<crate::api::graph::NodeAnnouncementInfo>>::sse_encode(
            self.announcement_info,
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_running, serializer);
        <bool>::sse_encode(self.is_listening, serializer);
        <crate::api::types::BestBlock>::sse_encode(self.current_best_block, serializer);
        <Option<u64>>::sse_encode(self.latest_lightning_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_onchain_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_fee_rate_cache_update_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_rgs_snapshot_timestamp, serializer);
        <Option<u64>>::sse_encode(
            self.latest_node_announcement_broadcast_timestamp,
            serializer,
        );
        <Option<u32>>::sse_encode(self.latest_channel_monitor_archival_height, serializer);
    }
}

impl SseEncode for crate::api::bolt12::Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for crate::api::types::OfferId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::AnchorChannelsConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::AnchorChannelsConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChainDataSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChannelConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ChannelId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::graph::ChannelInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::graph::ChannelInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::graph::ChannelUpdateInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::graph::ChannelUpdateInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::ClosureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::ClosureReason>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::EntropySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::EsploraSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::EsploraSyncConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::Event>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::GossipSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::LiquiditySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::MaxTotalRoutingFeeLimit> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::MaxTotalRoutingFeeLimit>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::NodeAlias> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::NodeAlias>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::graph::NodeAnnouncementInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::graph::NodeAnnouncementInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::graph::NodeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::graph::NodeInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::OutPoint>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentFailureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentFailureReason>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentHash> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentHash>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentPreimage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentPreimage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PaymentSecret>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::PublicKey>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::SendingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::SendingParameters>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u16>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::api::types::SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::api::types::SocketAddress>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::types::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::Txid>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::PaymentId>::sse_encode(self.id, serializer);
        <crate::api::types::PaymentKind>::sse_encode(self.kind, serializer);
        <Option<u64>>::sse_encode(self.amount_msat, serializer);
        <crate::api::types::PaymentDirection>::sse_encode(self.direction, serializer);
        <crate::api::types::PaymentStatus>::sse_encode(self.status, serializer);
        <u64>::sse_encode(self.latest_update_timestamp, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentDirection::Inbound => 0,
                crate::api::types::PaymentDirection::Outbound => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PaymentFailureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentFailureReason::RecipientRejected => 0,
                crate::api::types::PaymentFailureReason::UserAbandoned => 1,
                crate::api::types::PaymentFailureReason::RetriesExhausted => 2,
                crate::api::types::PaymentFailureReason::PaymentExpired => 3,
                crate::api::types::PaymentFailureReason::RouteNotFound => 4,
                crate::api::types::PaymentFailureReason::UnexpectedError => 5,
                crate::api::types::PaymentFailureReason::UnknownRequiredFeatures => 6,
                crate::api::types::PaymentFailureReason::InvoiceRequestExpired => 7,
                crate::api::types::PaymentFailureReason::InvoiceRequestRejected => 8,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::PaymentKind::Onchain => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::types::PaymentKind::Bolt11 {
                hash,
                preimage,
                secret,
            } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::types::PaymentHash>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<crate::api::types::PaymentSecret>>::sse_encode(secret, serializer);
            }
            crate::api::types::PaymentKind::Bolt11Jit {
                hash,
                preimage,
                secret,
                lsp_fee_limits,
            } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::PaymentHash>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<crate::api::types::PaymentSecret>>::sse_encode(secret, serializer);
                <crate::api::types::LSPFeeLimits>::sse_encode(lsp_fee_limits, serializer);
            }
            crate::api::types::PaymentKind::Spontaneous { hash, preimage } => {
                <i32>::sse_encode(3, serializer);
                <crate::api::types::PaymentHash>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
            }
            crate::api::types::PaymentKind::Bolt12Offer {
                hash,
                preimage,
                secret,
                offer_id,
                payer_note,
                quantity,
            } => {
                <i32>::sse_encode(4, serializer);
                <Option<crate::api::types::PaymentHash>>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<crate::api::types::PaymentSecret>>::sse_encode(secret, serializer);
                <crate::api::types::OfferId>::sse_encode(offer_id, serializer);
                <Option<String>>::sse_encode(payer_note, serializer);
                <Option<u64>>::sse_encode(quantity, serializer);
            }
            crate::api::types::PaymentKind::Bolt12Refund {
                hash,
                preimage,
                secret,
                payer_note,
                quantity,
            } => {
                <i32>::sse_encode(5, serializer);
                <Option<crate::api::types::PaymentHash>>::sse_encode(hash, serializer);
                <Option<crate::api::types::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<crate::api::types::PaymentSecret>>::sse_encode(secret, serializer);
                <Option<String>>::sse_encode(payer_note, serializer);
                <Option<u64>>::sse_encode(quantity, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for crate::api::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::PaymentStatus::Pending => 0,
                crate::api::types::PaymentStatus::Succeeded => 1,
                crate::api::types::PaymentStatus::Failed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::PublicKey>::sse_encode(self.node_id, serializer);
        <crate::api::types::SocketAddress>::sse_encode(self.address, serializer);
        <bool>::sse_encode(self.is_connected, serializer);
    }
}

impl SseEncode for crate::api::types::PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::PendingSweepBalance::PendingBroadcast {
                channel_id,
                amount_satoshis,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<crate::api::types::ChannelId>>::sse_encode(channel_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            crate::api::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                channel_id,
                latest_broadcast_height,
                latest_spending_txid,
                amount_satoshis,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<crate::api::types::ChannelId>>::sse_encode(channel_id, serializer);
                <u32>::sse_encode(latest_broadcast_height, serializer);
                <crate::api::types::Txid>::sse_encode(latest_spending_txid, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            crate::api::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                channel_id,
                latest_spending_txid,
                confirmation_hash,
                confirmation_height,
                amount_satoshis,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<crate::api::types::ChannelId>>::sse_encode(channel_id, serializer);
                <crate::api::types::Txid>::sse_encode(latest_spending_txid, serializer);
                <String>::sse_encode(confirmation_hash, serializer);
                <u32>::sse_encode(confirmation_height, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hex, serializer);
    }
}

impl SseEncode for crate::api::unified_qr::QrPaymentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::unified_qr::QrPaymentResult::Onchain { txid } => {
                <i32>::sse_encode(0, serializer);
                <crate::api::types::Txid>::sse_encode(txid, serializer);
            }
            crate::api::unified_qr::QrPaymentResult::Bolt11 { payment_id } => {
                <i32>::sse_encode(1, serializer);
                <crate::api::types::PaymentId>::sse_encode(payment_id, serializer);
            }
            crate::api::unified_qr::QrPaymentResult::Bolt12 { payment_id } => {
                <i32>::sse_encode(2, serializer);
                <crate::api::types::PaymentId>::sse_encode(payment_id, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode
    for (
        crate::api::types::SocketAddress,
        crate::api::types::PublicKey,
        Option<String>,
    )
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::SocketAddress>::sse_encode(self.0, serializer);
        <crate::api::types::PublicKey>::sse_encode(self.1, serializer);
        <Option<String>>::sse_encode(self.2, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::bolt12::Refund {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for crate::api::graph::RoutingFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.base_msat, serializer);
        <u32>::sse_encode(self.proportional_millionths, serializer);
    }
}

impl SseEncode for crate::api::types::SendingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::types::MaxTotalRoutingFeeLimit>>::sse_encode(
            self.max_total_routing_fee_msat,
            serializer,
        );
        <Option<u32>>::sse_encode(self.max_total_cltv_expiry_delta, serializer);
        <Option<u8>>::sse_encode(self.max_path_count, serializer);
        <Option<u8>>::sse_encode(self.max_channel_saturation_power_of_half, serializer);
    }
}

impl SseEncode for crate::api::types::SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::SocketAddress::TcpIpV4 { addr, port } => {
                <i32>::sse_encode(0, serializer);
                <[u8; 4]>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::TcpIpV6 { addr, port } => {
                <i32>::sse_encode(1, serializer);
                <[u8; 16]>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::OnionV2(field0) => {
                <i32>::sse_encode(2, serializer);
                <[u8; 12]>::sse_encode(field0, serializer);
            }
            crate::api::types::SocketAddress::OnionV3 {
                ed25519_pubkey,
                checksum,
                version,
                port,
            } => {
                <i32>::sse_encode(3, serializer);
                <[u8; 32]>::sse_encode(ed25519_pubkey, serializer);
                <u16>::sse_encode(checksum, serializer);
                <u8>::sse_encode(version, serializer);
                <u16>::sse_encode(port, serializer);
            }
            crate::api::types::SocketAddress::Hostname { addr, port } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(addr, serializer);
                <u16>::sse_encode(port, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::types::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for [u8; 12] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 16] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::types::UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.4.0.

    // Section: imports

    use super::*;
    use crate::api::builder::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<FfiBuilder> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> FfiBuilder {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<std::collections::HashMap<String, String>>
        for *mut wire_cst_list_record_string_string
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> std::collections::HashMap<String, String> {
            let vec: Vec<(String, String)> = self.cst_decode();
            vec.into_iter().collect()
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<ldk_node::Builder>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<ldk_node::Builder> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<ldk_node::Node>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<ldk_node::Node> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<ldk_node::graph::NetworkGraph>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<ldk_node::graph::NetworkGraph> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<ldk_node::payment::Bolt11Payment>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<ldk_node::payment::Bolt11Payment> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<ldk_node::payment::Bolt12Payment>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<ldk_node::payment::Bolt12Payment> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<ldk_node::payment::OnchainPayment>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<ldk_node::payment::OnchainPayment> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<ldk_node::payment::SpontaneousPayment>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<ldk_node::payment::SpontaneousPayment> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<ldk_node::payment::UnifiedQrPayment>> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> RustOpaqueNom<ldk_node::payment::UnifiedQrPayment> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<crate::api::types::Address> for wire_cst_address {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Address {
            crate::api::types::Address {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::AnchorChannelsConfig> for wire_cst_anchor_channels_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::AnchorChannelsConfig {
            crate::api::types::AnchorChannelsConfig {
                trusted_peers_no_reserve: self.trusted_peers_no_reserve.cst_decode(),
                per_channel_reserve_sats: self.per_channel_reserve_sats.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BalanceDetails> for wire_cst_balance_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BalanceDetails {
            crate::api::types::BalanceDetails {
                total_onchain_balance_sats: self.total_onchain_balance_sats.cst_decode(),
                spendable_onchain_balance_sats: self.spendable_onchain_balance_sats.cst_decode(),
                total_lightning_balance_sats: self.total_lightning_balance_sats.cst_decode(),
                lightning_balances: self.lightning_balances.cst_decode(),
                pending_balances_from_channel_closures: self
                    .pending_balances_from_channel_closures
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BestBlock> for wire_cst_best_block {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BestBlock {
            crate::api::types::BestBlock {
                block_hash: self.block_hash.cst_decode(),
                height: self.height.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::bolt11::Bolt11Invoice> for wire_cst_bolt_11_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt11::Bolt11Invoice {
            crate::api::bolt11::Bolt11Invoice {
                signed_raw_invoice: self.signed_raw_invoice.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::bolt12::Bolt12Invoice> for wire_cst_bolt_12_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt12::Bolt12Invoice {
            crate::api::bolt12::Bolt12Invoice {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::utils::error::Bolt12ParseError> for wire_cst_bolt_12_parse_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::utils::error::Bolt12ParseError {
            match self.tag {
                0 => crate::utils::error::Bolt12ParseError::InvalidContinuation,
                1 => crate::utils::error::Bolt12ParseError::InvalidBech32Hrp,
                2 => {
                    let ans = unsafe { self.kind.Bech32 };
                    crate::utils::error::Bolt12ParseError::Bech32(ans.field0.cst_decode())
                }
                3 => {
                    let ans = unsafe { self.kind.Decode };
                    crate::utils::error::Bolt12ParseError::Decode(ans.field0.cst_decode())
                }
                4 => {
                    let ans = unsafe { self.kind.InvalidSemantics };
                    crate::utils::error::Bolt12ParseError::InvalidSemantics(ans.field0.cst_decode())
                }
                5 => {
                    let ans = unsafe { self.kind.InvalidSignature };
                    crate::utils::error::Bolt12ParseError::InvalidSignature(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::Address> for *mut wire_cst_address {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Address {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::Address>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::AnchorChannelsConfig> for *mut wire_cst_anchor_channels_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::AnchorChannelsConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::AnchorChannelsConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::bolt11::Bolt11Invoice> for *mut wire_cst_bolt_11_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt11::Bolt11Invoice {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::bolt11::Bolt11Invoice>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::utils::error::Bolt12ParseError> for *mut wire_cst_bolt_12_parse_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::utils::error::Bolt12ParseError {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::utils::error::Bolt12ParseError>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<bool> for *mut bool {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::types::ChainDataSourceConfig>
        for *mut wire_cst_chain_data_source_config
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ChainDataSourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::ChainDataSourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::ChannelConfig> for *mut wire_cst_channel_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ChannelConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::ChannelConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::ChannelId> for *mut wire_cst_channel_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ChannelId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::ChannelId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::graph::ChannelInfo> for *mut wire_cst_channel_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::ChannelInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::graph::ChannelInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::graph::ChannelUpdateInfo> for *mut wire_cst_channel_update_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::ChannelUpdateInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::graph::ChannelUpdateInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::ClosureReason> for *mut wire_cst_closure_reason {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ClosureReason {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::ClosureReason>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::Config> for *mut wire_cst_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Config {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::Config>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::utils::error::DecodeError> for *mut wire_cst_decode_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::utils::error::DecodeError {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::utils::error::DecodeError>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::EntropySourceConfig> for *mut wire_cst_entropy_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::EntropySourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::EntropySourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::EsploraSyncConfig> for *mut wire_cst_esplora_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::EsploraSyncConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::EsploraSyncConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::Event> for *mut wire_cst_event {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Event {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::Event>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::bolt11::FfiBolt11Payment> for *mut wire_cst_ffi_bolt_11_payment {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt11::FfiBolt11Payment {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::bolt11::FfiBolt11Payment>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::bolt12::FfiBolt12Payment> for *mut wire_cst_ffi_bolt_12_payment {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt12::FfiBolt12Payment {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::bolt12::FfiBolt12Payment>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::builder::FfiMnemonic> for *mut wire_cst_ffi_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::builder::FfiMnemonic {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::builder::FfiMnemonic>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::graph::FfiNetworkGraph> for *mut wire_cst_ffi_network_graph {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::FfiNetworkGraph {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::graph::FfiNetworkGraph>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::node::FfiNode> for *mut wire_cst_ffi_node {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::node::FfiNode {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::node::FfiNode>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::on_chain::FfiOnChainPayment> for *mut wire_cst_ffi_on_chain_payment {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::on_chain::FfiOnChainPayment {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::on_chain::FfiOnChainPayment>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::spontaneous::FfiSpontaneousPayment>
        for *mut wire_cst_ffi_spontaneous_payment
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::spontaneous::FfiSpontaneousPayment {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::spontaneous::FfiSpontaneousPayment>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::unified_qr::FfiUnifiedQrPayment>
        for *mut wire_cst_ffi_unified_qr_payment
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::unified_qr::FfiUnifiedQrPayment {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::unified_qr::FfiUnifiedQrPayment>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::GossipSourceConfig> for *mut wire_cst_gossip_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::GossipSourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::GossipSourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::LiquiditySourceConfig> for *mut wire_cst_liquidity_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LiquiditySourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::LiquiditySourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::LSPFeeLimits> for *mut wire_cst_lsp_fee_limits {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LSPFeeLimits {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::LSPFeeLimits>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::MaxTotalRoutingFeeLimit>
        for *mut wire_cst_max_total_routing_fee_limit
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::MaxTotalRoutingFeeLimit {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::MaxTotalRoutingFeeLimit>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::NodeAlias> for *mut wire_cst_node_alias {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::NodeAlias {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::NodeAlias>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::graph::NodeAnnouncementInfo> for *mut wire_cst_node_announcement_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::NodeAnnouncementInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::graph::NodeAnnouncementInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::graph::NodeId> for *mut wire_cst_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::NodeId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::graph::NodeId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::graph::NodeInfo> for *mut wire_cst_node_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::NodeInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::graph::NodeInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::bolt12::Offer> for *mut wire_cst_offer {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt12::Offer {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::bolt12::Offer>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::OfferId> for *mut wire_cst_offer_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::OfferId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::OfferId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::OutPoint> for *mut wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::OutPoint {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::OutPoint>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::PaymentDetails> for *mut wire_cst_payment_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentDetails {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::PaymentDetails>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::PaymentFailureReason> for *mut i32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentFailureReason {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::PaymentFailureReason>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::PaymentHash> for *mut wire_cst_payment_hash {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentHash {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::PaymentHash>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::PaymentId> for *mut wire_cst_payment_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::PaymentId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::PaymentPreimage> for *mut wire_cst_payment_preimage {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentPreimage {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::PaymentPreimage>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::PaymentSecret> for *mut wire_cst_payment_secret {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentSecret {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::PaymentSecret>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::PublicKey> for *mut wire_cst_public_key {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PublicKey {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::PublicKey>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::bolt12::Refund> for *mut wire_cst_refund {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt12::Refund {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::bolt12::Refund>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::SendingParameters> for *mut wire_cst_sending_parameters {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SendingParameters {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::SendingParameters>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::SocketAddress> for *mut wire_cst_socket_address {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SocketAddress {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::SocketAddress>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::Txid> for *mut wire_cst_txid {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Txid {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::Txid>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u16> for *mut u16 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u16 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u64> for *mut u64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u8> for *mut u8 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::types::UserChannelId> for *mut wire_cst_user_channel_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::UserChannelId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::UserChannelId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::ChainDataSourceConfig> for wire_cst_chain_data_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ChainDataSourceConfig {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Esplora };
                    crate::api::types::ChainDataSourceConfig::Esplora {
                        server_url: ans.server_url.cst_decode(),
                        sync_config: ans.sync_config.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.BitcoindRpc };
                    crate::api::types::ChainDataSourceConfig::BitcoindRpc {
                        rpc_host: ans.rpc_host.cst_decode(),
                        rpc_port: ans.rpc_port.cst_decode(),
                        rpc_user: ans.rpc_user.cst_decode(),
                        rpc_password: ans.rpc_password.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::ChannelConfig> for wire_cst_channel_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ChannelConfig {
            crate::api::types::ChannelConfig {
                forwarding_fee_proportional_millionths: self
                    .forwarding_fee_proportional_millionths
                    .cst_decode(),
                forwarding_fee_base_msat: self.forwarding_fee_base_msat.cst_decode(),
                cltv_expiry_delta: self.cltv_expiry_delta.cst_decode(),
                max_dust_htlc_exposure: self.max_dust_htlc_exposure.cst_decode(),
                force_close_avoidance_max_fee_satoshis: self
                    .force_close_avoidance_max_fee_satoshis
                    .cst_decode(),
                accept_underpaying_htlcs: self.accept_underpaying_htlcs.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::ChannelDetails> for wire_cst_channel_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ChannelDetails {
            crate::api::types::ChannelDetails {
                channel_id: self.channel_id.cst_decode(),
                counterparty_node_id: self.counterparty_node_id.cst_decode(),
                funding_txo: self.funding_txo.cst_decode(),
                channel_value_sats: self.channel_value_sats.cst_decode(),
                unspendable_punishment_reserve: self.unspendable_punishment_reserve.cst_decode(),
                user_channel_id: self.user_channel_id.cst_decode(),
                feerate_sat_per_1000_weight: self.feerate_sat_per_1000_weight.cst_decode(),
                outbound_capacity_msat: self.outbound_capacity_msat.cst_decode(),
                inbound_capacity_msat: self.inbound_capacity_msat.cst_decode(),
                confirmations_required: self.confirmations_required.cst_decode(),
                confirmations: self.confirmations.cst_decode(),
                is_outbound: self.is_outbound.cst_decode(),
                is_channel_ready: self.is_channel_ready.cst_decode(),
                is_usable: self.is_usable.cst_decode(),
                cltv_expiry_delta: self.cltv_expiry_delta.cst_decode(),
                counterparty_unspendable_punishment_reserve: self
                    .counterparty_unspendable_punishment_reserve
                    .cst_decode(),
                counterparty_outbound_htlc_minimum_msat: self
                    .counterparty_outbound_htlc_minimum_msat
                    .cst_decode(),
                counterparty_outbound_htlc_maximum_msat: self
                    .counterparty_outbound_htlc_maximum_msat
                    .cst_decode(),
                counterparty_forwarding_info_fee_base_msat: self
                    .counterparty_forwarding_info_fee_base_msat
                    .cst_decode(),
                counterparty_forwarding_info_fee_proportional_millionths: self
                    .counterparty_forwarding_info_fee_proportional_millionths
                    .cst_decode(),
                counterparty_forwarding_info_cltv_expiry_delta: self
                    .counterparty_forwarding_info_cltv_expiry_delta
                    .cst_decode(),
                next_outbound_htlc_limit_msat: self.next_outbound_htlc_limit_msat.cst_decode(),
                next_outbound_htlc_minimum_msat: self.next_outbound_htlc_minimum_msat.cst_decode(),
                force_close_spend_delay: self.force_close_spend_delay.cst_decode(),
                inbound_htlc_minimum_msat: self.inbound_htlc_minimum_msat.cst_decode(),
                inbound_htlc_maximum_msat: self.inbound_htlc_maximum_msat.cst_decode(),
                config: self.config.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::ChannelId> for wire_cst_channel_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ChannelId {
            crate::api::types::ChannelId {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::graph::ChannelInfo> for wire_cst_channel_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::ChannelInfo {
            crate::api::graph::ChannelInfo {
                node_one: self.node_one.cst_decode(),
                one_to_two: self.one_to_two.cst_decode(),
                node_two: self.node_two.cst_decode(),
                two_to_one: self.two_to_one.cst_decode(),
                capacity_sats: self.capacity_sats.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::graph::ChannelUpdateInfo> for wire_cst_channel_update_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::ChannelUpdateInfo {
            crate::api::graph::ChannelUpdateInfo {
                last_update: self.last_update.cst_decode(),
                enabled: self.enabled.cst_decode(),
                cltv_expiry_delta: self.cltv_expiry_delta.cst_decode(),
                htlc_minimum_msat: self.htlc_minimum_msat.cst_decode(),
                htlc_maximum_msat: self.htlc_maximum_msat.cst_decode(),
                fees: self.fees.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::ClosureReason> for wire_cst_closure_reason {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ClosureReason {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.PeerFeerateTooLow };
                    crate::api::types::ClosureReason::PeerFeerateTooLow {
                        peer_feerate_sat_per_kw: ans.peer_feerate_sat_per_kw.cst_decode(),
                        required_feerate_sat_per_kw: ans.required_feerate_sat_per_kw.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.CounterpartyForceClosed };
                    crate::api::types::ClosureReason::CounterpartyForceClosed {
                        peer_msg: ans.peer_msg.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.HolderForceClosed };
                    crate::api::types::ClosureReason::HolderForceClosed {
                        broadcasted_latest_txn: ans.broadcasted_latest_txn.cst_decode(),
                    }
                }
                3 => crate::api::types::ClosureReason::LegacyCooperativeClosure,
                4 => crate::api::types::ClosureReason::CounterpartyInitiatedCooperativeClosure,
                5 => crate::api::types::ClosureReason::LocallyInitiatedCooperativeClosure,
                6 => crate::api::types::ClosureReason::CommitmentTxConfirmed,
                7 => crate::api::types::ClosureReason::FundingTimedOut,
                8 => {
                    let ans = unsafe { self.kind.ProcessingError };
                    crate::api::types::ClosureReason::ProcessingError {
                        err: ans.err.cst_decode(),
                    }
                }
                9 => crate::api::types::ClosureReason::DisconnectedPeer,
                10 => crate::api::types::ClosureReason::OutdatedChannelManager,
                11 => crate::api::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel,
                12 => crate::api::types::ClosureReason::FundingBatchClosure,
                13 => crate::api::types::ClosureReason::HTLCsTimedOut,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::Config> for wire_cst_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Config {
            crate::api::types::Config {
                storage_dir_path: self.storage_dir_path.cst_decode(),
                log_dir_path: self.log_dir_path.cst_decode(),
                network: self.network.cst_decode(),
                listening_addresses: self.listening_addresses.cst_decode(),
                node_alias: self.node_alias.cst_decode(),
                trusted_peers_0conf: self.trusted_peers_0conf.cst_decode(),
                probing_liquidity_limit_multiplier: self
                    .probing_liquidity_limit_multiplier
                    .cst_decode(),
                log_level: self.log_level.cst_decode(),
                anchor_channels_config: self.anchor_channels_config.cst_decode(),
                sending_parameters: self.sending_parameters.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::utils::error::DecodeError> for wire_cst_decode_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::utils::error::DecodeError {
            match self.tag {
                0 => crate::utils::error::DecodeError::UnknownVersion,
                1 => crate::utils::error::DecodeError::UnknownRequiredFeature,
                2 => crate::utils::error::DecodeError::InvalidValue,
                3 => crate::utils::error::DecodeError::ShortRead,
                4 => crate::utils::error::DecodeError::BadLengthDescriptor,
                5 => {
                    let ans = unsafe { self.kind.Io };
                    crate::utils::error::DecodeError::Io(ans.field0.cst_decode())
                }
                6 => crate::utils::error::DecodeError::UnsupportedCompression,
                7 => crate::utils::error::DecodeError::DangerousValue,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::EntropySourceConfig> for wire_cst_entropy_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::EntropySourceConfig {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.SeedFile };
                    crate::api::types::EntropySourceConfig::SeedFile(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.SeedBytes };
                    crate::api::types::EntropySourceConfig::SeedBytes(ans.field0.cst_decode())
                }
                2 => {
                    let ans = unsafe { self.kind.Bip39Mnemonic };
                    crate::api::types::EntropySourceConfig::Bip39Mnemonic {
                        mnemonic: ans.mnemonic.cst_decode(),
                        passphrase: ans.passphrase.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::EsploraSyncConfig> for wire_cst_esplora_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::EsploraSyncConfig {
            crate::api::types::EsploraSyncConfig {
                onchain_wallet_sync_interval_secs: self
                    .onchain_wallet_sync_interval_secs
                    .cst_decode(),
                lightning_wallet_sync_interval_secs: self
                    .lightning_wallet_sync_interval_secs
                    .cst_decode(),
                fee_rate_cache_update_interval_secs: self
                    .fee_rate_cache_update_interval_secs
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::Event> for wire_cst_event {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Event {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.PaymentClaimable };
                    crate::api::types::Event::PaymentClaimable {
                        payment_id: ans.payment_id.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        claimable_amount_msat: ans.claimable_amount_msat.cst_decode(),
                        claim_deadline: ans.claim_deadline.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.PaymentSuccessful };
                    crate::api::types::Event::PaymentSuccessful {
                        payment_id: ans.payment_id.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        fee_paid_msat: ans.fee_paid_msat.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.PaymentFailed };
                    crate::api::types::Event::PaymentFailed {
                        payment_id: ans.payment_id.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        reason: ans.reason.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.PaymentReceived };
                    crate::api::types::Event::PaymentReceived {
                        payment_id: ans.payment_id.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        amount_msat: ans.amount_msat.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.ChannelPending };
                    crate::api::types::Event::ChannelPending {
                        channel_id: ans.channel_id.cst_decode(),
                        user_channel_id: ans.user_channel_id.cst_decode(),
                        former_temporary_channel_id: ans.former_temporary_channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        funding_txo: ans.funding_txo.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.ChannelReady };
                    crate::api::types::Event::ChannelReady {
                        channel_id: ans.channel_id.cst_decode(),
                        user_channel_id: ans.user_channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                    }
                }
                6 => {
                    let ans = unsafe { self.kind.ChannelClosed };
                    crate::api::types::Event::ChannelClosed {
                        channel_id: ans.channel_id.cst_decode(),
                        user_channel_id: ans.user_channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        reason: ans.reason.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::bolt11::FfiBolt11Payment> for wire_cst_ffi_bolt_11_payment {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt11::FfiBolt11Payment {
            crate::api::bolt11::FfiBolt11Payment {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::bolt12::FfiBolt12Payment> for wire_cst_ffi_bolt_12_payment {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt12::FfiBolt12Payment {
            crate::api::bolt12::FfiBolt12Payment {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::builder::FfiMnemonic> for wire_cst_ffi_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::builder::FfiMnemonic {
            crate::api::builder::FfiMnemonic {
                seed_phrase: self.seed_phrase.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::graph::FfiNetworkGraph> for wire_cst_ffi_network_graph {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::FfiNetworkGraph {
            crate::api::graph::FfiNetworkGraph {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::node::FfiNode> for wire_cst_ffi_node {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::node::FfiNode {
            crate::api::node::FfiNode {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::utils::error::FfiNodeError> for wire_cst_ffi_node_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::utils::error::FfiNodeError {
            match self.tag {
                0 => crate::utils::error::FfiNodeError::InvalidTxid,
                1 => crate::utils::error::FfiNodeError::AlreadyRunning,
                2 => crate::utils::error::FfiNodeError::NotRunning,
                3 => crate::utils::error::FfiNodeError::OnchainTxCreationFailed,
                4 => crate::utils::error::FfiNodeError::ConnectionFailed,
                5 => crate::utils::error::FfiNodeError::InvoiceCreationFailed,
                6 => crate::utils::error::FfiNodeError::PaymentSendingFailed,
                7 => crate::utils::error::FfiNodeError::ProbeSendingFailed,
                8 => crate::utils::error::FfiNodeError::ChannelCreationFailed,
                9 => crate::utils::error::FfiNodeError::ChannelClosingFailed,
                10 => crate::utils::error::FfiNodeError::ChannelConfigUpdateFailed,
                11 => crate::utils::error::FfiNodeError::PersistenceFailed,
                12 => crate::utils::error::FfiNodeError::WalletOperationFailed,
                13 => crate::utils::error::FfiNodeError::OnchainTxSigningFailed,
                14 => crate::utils::error::FfiNodeError::MessageSigningFailed,
                15 => crate::utils::error::FfiNodeError::TxSyncFailed,
                16 => crate::utils::error::FfiNodeError::GossipUpdateFailed,
                17 => crate::utils::error::FfiNodeError::InvalidAddress,
                18 => crate::utils::error::FfiNodeError::InvalidSocketAddress,
                19 => crate::utils::error::FfiNodeError::InvalidPublicKey,
                20 => crate::utils::error::FfiNodeError::InvalidSecretKey,
                21 => crate::utils::error::FfiNodeError::InvalidPaymentHash,
                22 => crate::utils::error::FfiNodeError::InvalidPaymentPreimage,
                23 => crate::utils::error::FfiNodeError::InvalidPaymentSecret,
                24 => crate::utils::error::FfiNodeError::InvalidAmount,
                25 => crate::utils::error::FfiNodeError::InvalidInvoice,
                26 => crate::utils::error::FfiNodeError::InvalidChannelId,
                27 => crate::utils::error::FfiNodeError::InvalidNetwork,
                28 => crate::utils::error::FfiNodeError::DuplicatePayment,
                29 => crate::utils::error::FfiNodeError::InsufficientFunds,
                30 => crate::utils::error::FfiNodeError::FeerateEstimationUpdateFailed,
                31 => crate::utils::error::FfiNodeError::LiquidityRequestFailed,
                32 => crate::utils::error::FfiNodeError::LiquiditySourceUnavailable,
                33 => crate::utils::error::FfiNodeError::LiquidityFeeTooHigh,
                34 => crate::utils::error::FfiNodeError::InvalidPaymentId,
                35 => {
                    let ans = unsafe { self.kind.Decode };
                    crate::utils::error::FfiNodeError::Decode(ans.field0.cst_decode())
                }
                36 => {
                    let ans = unsafe { self.kind.Bolt12Parse };
                    crate::utils::error::FfiNodeError::Bolt12Parse(ans.field0.cst_decode())
                }
                37 => crate::utils::error::FfiNodeError::InvoiceRequestCreationFailed,
                38 => crate::utils::error::FfiNodeError::OfferCreationFailed,
                39 => crate::utils::error::FfiNodeError::RefundCreationFailed,
                40 => crate::utils::error::FfiNodeError::FeerateEstimationUpdateTimeout,
                41 => crate::utils::error::FfiNodeError::WalletOperationTimeout,
                42 => crate::utils::error::FfiNodeError::TxSyncTimeout,
                43 => crate::utils::error::FfiNodeError::GossipUpdateTimeout,
                44 => crate::utils::error::FfiNodeError::InvalidOfferId,
                45 => crate::utils::error::FfiNodeError::InvalidNodeId,
                46 => crate::utils::error::FfiNodeError::InvalidOffer,
                47 => crate::utils::error::FfiNodeError::InvalidRefund,
                48 => crate::utils::error::FfiNodeError::UnsupportedCurrency,
                49 => crate::utils::error::FfiNodeError::UriParameterParsingFailed,
                50 => crate::utils::error::FfiNodeError::InvalidUri,
                51 => crate::utils::error::FfiNodeError::InvalidQuantity,
                52 => crate::utils::error::FfiNodeError::InvalidNodeAlias,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::on_chain::FfiOnChainPayment> for wire_cst_ffi_on_chain_payment {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::on_chain::FfiOnChainPayment {
            crate::api::on_chain::FfiOnChainPayment {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::spontaneous::FfiSpontaneousPayment>
        for wire_cst_ffi_spontaneous_payment
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::spontaneous::FfiSpontaneousPayment {
            crate::api::spontaneous::FfiSpontaneousPayment {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::unified_qr::FfiUnifiedQrPayment> for wire_cst_ffi_unified_qr_payment {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::unified_qr::FfiUnifiedQrPayment {
            crate::api::unified_qr::FfiUnifiedQrPayment {
                opaque: self.opaque.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::GossipSourceConfig> for wire_cst_gossip_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::GossipSourceConfig {
            match self.tag {
                0 => crate::api::types::GossipSourceConfig::P2PNetwork,
                1 => {
                    let ans = unsafe { self.kind.RapidGossipSync };
                    crate::api::types::GossipSourceConfig::RapidGossipSync(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::LightningBalance> for wire_cst_lightning_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LightningBalance {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.ClaimableOnChannelClose };
                    crate::api::types::LightningBalance::ClaimableOnChannelClose {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                        transaction_fee_satoshis: ans.transaction_fee_satoshis.cst_decode(),
                        outbound_payment_htlc_rounded_msat: ans
                            .outbound_payment_htlc_rounded_msat
                            .cst_decode(),
                        outbound_forwarded_htlc_rounded_msat: ans
                            .outbound_forwarded_htlc_rounded_msat
                            .cst_decode(),
                        inbound_claiming_htlc_rounded_msat: ans
                            .inbound_claiming_htlc_rounded_msat
                            .cst_decode(),
                        inbound_htlc_rounded_msat: ans.inbound_htlc_rounded_msat.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.ClaimableAwaitingConfirmations };
                    crate::api::types::LightningBalance::ClaimableAwaitingConfirmations {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                        confirmation_height: ans.confirmation_height.cst_decode(),
                        source: ans.source.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.ContentiousClaimable };
                    crate::api::types::LightningBalance::ContentiousClaimable {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                        timeout_height: ans.timeout_height.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        payment_preimage: ans.payment_preimage.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.MaybeTimeoutClaimableHTLC };
                    crate::api::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                        claimable_height: ans.claimable_height.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        outbound_payment: ans.outbound_payment.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.MaybePreimageClaimableHTLC };
                    crate::api::types::LightningBalance::MaybePreimageClaimableHTLC {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                        expiry_height: ans.expiry_height.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.CounterpartyRevokedOutputClaimable };
                    crate::api::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::LiquiditySourceConfig> for wire_cst_liquidity_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LiquiditySourceConfig {
            crate::api::types::LiquiditySourceConfig {
                lsps2_service: self.lsps2_service.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<crate::api::types::ChannelDetails>> for *mut wire_cst_list_channel_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::ChannelDetails> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::LightningBalance>> for *mut wire_cst_list_lightning_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::LightningBalance> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::graph::NodeId>> for *mut wire_cst_list_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::graph::NodeId> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::PaymentDetails>> for *mut wire_cst_list_payment_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::PaymentDetails> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::PeerDetails>> for *mut wire_cst_list_peer_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::PeerDetails> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::PendingSweepBalance>>
        for *mut wire_cst_list_pending_sweep_balance
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::PendingSweepBalance> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<u64>> for *mut wire_cst_list_prim_u_64_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u64> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<crate::api::types::PublicKey>> for *mut wire_cst_list_public_key {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::PublicKey> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<(String, String)>> for *mut wire_cst_list_record_string_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(String, String)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<crate::api::types::SocketAddress>> for *mut wire_cst_list_socket_address {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<crate::api::types::SocketAddress> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<crate::api::types::LSPFeeLimits> for wire_cst_lsp_fee_limits {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LSPFeeLimits {
            crate::api::types::LSPFeeLimits {
                max_total_opening_fee_msat: self.max_total_opening_fee_msat.cst_decode(),
                max_proportional_opening_fee_ppm_msat: self
                    .max_proportional_opening_fee_ppm_msat
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::MaxDustHTLCExposure> for wire_cst_max_dust_htlc_exposure {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::MaxDustHTLCExposure {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.FixedLimitMsat };
                    crate::api::types::MaxDustHTLCExposure::FixedLimitMsat(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.FeeRateMultiplier };
                    crate::api::types::MaxDustHTLCExposure::FeeRateMultiplier(
                        ans.field0.cst_decode(),
                    )
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::MaxTotalRoutingFeeLimit>
        for wire_cst_max_total_routing_fee_limit
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::MaxTotalRoutingFeeLimit {
            match self.tag {
                0 => crate::api::types::MaxTotalRoutingFeeLimit::NoFeeCap,
                1 => {
                    let ans = unsafe { self.kind.FeeCap };
                    crate::api::types::MaxTotalRoutingFeeLimit::FeeCap {
                        amount_msat: ans.amount_msat.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::NodeAlias> for wire_cst_node_alias {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::NodeAlias {
            crate::api::types::NodeAlias(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::graph::NodeAnnouncementInfo> for wire_cst_node_announcement_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::NodeAnnouncementInfo {
            crate::api::graph::NodeAnnouncementInfo {
                last_update: self.last_update.cst_decode(),
                alias: self.alias.cst_decode(),
                addresses: self.addresses.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::graph::NodeId> for wire_cst_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::NodeId {
            crate::api::graph::NodeId {
                compressed: self.compressed.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::graph::NodeInfo> for wire_cst_node_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::NodeInfo {
            crate::api::graph::NodeInfo {
                channels: self.channels.cst_decode(),
                announcement_info: self.announcement_info.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::NodeStatus> for wire_cst_node_status {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::NodeStatus {
            crate::api::types::NodeStatus {
                is_running: self.is_running.cst_decode(),
                is_listening: self.is_listening.cst_decode(),
                current_best_block: self.current_best_block.cst_decode(),
                latest_lightning_wallet_sync_timestamp: self
                    .latest_lightning_wallet_sync_timestamp
                    .cst_decode(),
                latest_onchain_wallet_sync_timestamp: self
                    .latest_onchain_wallet_sync_timestamp
                    .cst_decode(),
                latest_fee_rate_cache_update_timestamp: self
                    .latest_fee_rate_cache_update_timestamp
                    .cst_decode(),
                latest_rgs_snapshot_timestamp: self.latest_rgs_snapshot_timestamp.cst_decode(),
                latest_node_announcement_broadcast_timestamp: self
                    .latest_node_announcement_broadcast_timestamp
                    .cst_decode(),
                latest_channel_monitor_archival_height: self
                    .latest_channel_monitor_archival_height
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::bolt12::Offer> for wire_cst_offer {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt12::Offer {
            crate::api::bolt12::Offer {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::OfferId> for wire_cst_offer_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::OfferId {
            crate::api::types::OfferId(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::types::OutPoint> for wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::OutPoint {
            crate::api::types::OutPoint {
                txid: self.txid.cst_decode(),
                vout: self.vout.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PaymentDetails> for wire_cst_payment_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentDetails {
            crate::api::types::PaymentDetails {
                id: self.id.cst_decode(),
                kind: self.kind.cst_decode(),
                amount_msat: self.amount_msat.cst_decode(),
                direction: self.direction.cst_decode(),
                status: self.status.cst_decode(),
                latest_update_timestamp: self.latest_update_timestamp.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PaymentHash> for wire_cst_payment_hash {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentHash {
            crate::api::types::PaymentHash {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PaymentId> for wire_cst_payment_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentId {
            crate::api::types::PaymentId(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::types::PaymentKind> for wire_cst_payment_kind {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentKind {
            match self.tag {
                0 => crate::api::types::PaymentKind::Onchain,
                1 => {
                    let ans = unsafe { self.kind.Bolt11 };
                    crate::api::types::PaymentKind::Bolt11 {
                        hash: ans.hash.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                        secret: ans.secret.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Bolt11Jit };
                    crate::api::types::PaymentKind::Bolt11Jit {
                        hash: ans.hash.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                        secret: ans.secret.cst_decode(),
                        lsp_fee_limits: ans.lsp_fee_limits.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.Spontaneous };
                    crate::api::types::PaymentKind::Spontaneous {
                        hash: ans.hash.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.Bolt12Offer };
                    crate::api::types::PaymentKind::Bolt12Offer {
                        hash: ans.hash.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                        secret: ans.secret.cst_decode(),
                        offer_id: ans.offer_id.cst_decode(),
                        payer_note: ans.payer_note.cst_decode(),
                        quantity: ans.quantity.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.Bolt12Refund };
                    crate::api::types::PaymentKind::Bolt12Refund {
                        hash: ans.hash.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                        secret: ans.secret.cst_decode(),
                        payer_note: ans.payer_note.cst_decode(),
                        quantity: ans.quantity.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::PaymentPreimage> for wire_cst_payment_preimage {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentPreimage {
            crate::api::types::PaymentPreimage {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PaymentSecret> for wire_cst_payment_secret {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PaymentSecret {
            crate::api::types::PaymentSecret {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PeerDetails> for wire_cst_peer_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PeerDetails {
            crate::api::types::PeerDetails {
                node_id: self.node_id.cst_decode(),
                address: self.address.cst_decode(),
                is_connected: self.is_connected.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PendingSweepBalance> for wire_cst_pending_sweep_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PendingSweepBalance {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.PendingBroadcast };
                    crate::api::types::PendingSweepBalance::PendingBroadcast {
                        channel_id: ans.channel_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.BroadcastAwaitingConfirmation };
                    crate::api::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                        channel_id: ans.channel_id.cst_decode(),
                        latest_broadcast_height: ans.latest_broadcast_height.cst_decode(),
                        latest_spending_txid: ans.latest_spending_txid.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.AwaitingThresholdConfirmations };
                    crate::api::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                        channel_id: ans.channel_id.cst_decode(),
                        latest_spending_txid: ans.latest_spending_txid.cst_decode(),
                        confirmation_hash: ans.confirmation_hash.cst_decode(),
                        confirmation_height: ans.confirmation_height.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::PublicKey> for wire_cst_public_key {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PublicKey {
            crate::api::types::PublicKey {
                hex: self.hex.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::unified_qr::QrPaymentResult> for wire_cst_qr_payment_result {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::unified_qr::QrPaymentResult {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Onchain };
                    crate::api::unified_qr::QrPaymentResult::Onchain {
                        txid: ans.txid.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Bolt11 };
                    crate::api::unified_qr::QrPaymentResult::Bolt11 {
                        payment_id: ans.payment_id.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Bolt12 };
                    crate::api::unified_qr::QrPaymentResult::Bolt12 {
                        payment_id: ans.payment_id.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl
        CstDecode<(
            crate::api::types::SocketAddress,
            crate::api::types::PublicKey,
            Option<String>,
        )> for wire_cst_record_socket_address_public_key_opt_string
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> (
            crate::api::types::SocketAddress,
            crate::api::types::PublicKey,
            Option<String>,
        ) {
            (
                self.field0.cst_decode(),
                self.field1.cst_decode(),
                self.field2.cst_decode(),
            )
        }
    }
    impl CstDecode<(String, String)> for wire_cst_record_string_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (String, String) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<crate::api::bolt12::Refund> for wire_cst_refund {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::bolt12::Refund {
            crate::api::bolt12::Refund {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::graph::RoutingFees> for wire_cst_routing_fees {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::graph::RoutingFees {
            crate::api::graph::RoutingFees {
                base_msat: self.base_msat.cst_decode(),
                proportional_millionths: self.proportional_millionths.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::SendingParameters> for wire_cst_sending_parameters {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SendingParameters {
            crate::api::types::SendingParameters {
                max_total_routing_fee_msat: self.max_total_routing_fee_msat.cst_decode(),
                max_total_cltv_expiry_delta: self.max_total_cltv_expiry_delta.cst_decode(),
                max_path_count: self.max_path_count.cst_decode(),
                max_channel_saturation_power_of_half: self
                    .max_channel_saturation_power_of_half
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::SocketAddress> for wire_cst_socket_address {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SocketAddress {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.TcpIpV4 };
                    crate::api::types::SocketAddress::TcpIpV4 {
                        addr: ans.addr.cst_decode(),
                        port: ans.port.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.TcpIpV6 };
                    crate::api::types::SocketAddress::TcpIpV6 {
                        addr: ans.addr.cst_decode(),
                        port: ans.port.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.OnionV2 };
                    crate::api::types::SocketAddress::OnionV2(ans.field0.cst_decode())
                }
                3 => {
                    let ans = unsafe { self.kind.OnionV3 };
                    crate::api::types::SocketAddress::OnionV3 {
                        ed25519_pubkey: ans.ed25519_pubkey.cst_decode(),
                        checksum: ans.checksum.cst_decode(),
                        version: ans.version.cst_decode(),
                        port: ans.port.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.Hostname };
                    crate::api::types::SocketAddress::Hostname {
                        addr: ans.addr.cst_decode(),
                        port: ans.port.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<crate::api::types::Txid> for wire_cst_txid {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Txid {
            crate::api::types::Txid {
                hash: self.hash.cst_decode(),
            }
        }
    }
    impl CstDecode<[u8; 12]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 12] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<[u8; 16]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 16] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<[u8; 32]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 32] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<[u8; 4]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 4] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<[u8; 64]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 64] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<crate::api::types::UserChannelId> for wire_cst_user_channel_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::UserChannelId {
            crate::api::types::UserChannelId {
                data: self.data.cst_decode(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_address {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_address {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_anchor_channels_config {
        fn new_with_null_ptr() -> Self {
            Self {
                trusted_peers_no_reserve: core::ptr::null_mut(),
                per_channel_reserve_sats: Default::default(),
            }
        }
    }
    impl Default for wire_cst_anchor_channels_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_balance_details {
        fn new_with_null_ptr() -> Self {
            Self {
                total_onchain_balance_sats: Default::default(),
                spendable_onchain_balance_sats: Default::default(),
                total_lightning_balance_sats: Default::default(),
                lightning_balances: core::ptr::null_mut(),
                pending_balances_from_channel_closures: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_balance_details {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_best_block {
        fn new_with_null_ptr() -> Self {
            Self {
                block_hash: core::ptr::null_mut(),
                height: Default::default(),
            }
        }
    }
    impl Default for wire_cst_best_block {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bolt_11_invoice {
        fn new_with_null_ptr() -> Self {
            Self {
                signed_raw_invoice: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bolt_11_invoice {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bolt_12_invoice {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bolt_12_invoice {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bolt_12_parse_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: Bolt12ParseErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_bolt_12_parse_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_chain_data_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: ChainDataSourceConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_chain_data_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_config {
        fn new_with_null_ptr() -> Self {
            Self {
                forwarding_fee_proportional_millionths: Default::default(),
                forwarding_fee_base_msat: Default::default(),
                cltv_expiry_delta: Default::default(),
                max_dust_htlc_exposure: Default::default(),
                force_close_avoidance_max_fee_satoshis: Default::default(),
                accept_underpaying_htlcs: Default::default(),
            }
        }
    }
    impl Default for wire_cst_channel_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_details {
        fn new_with_null_ptr() -> Self {
            Self {
                channel_id: Default::default(),
                counterparty_node_id: Default::default(),
                funding_txo: core::ptr::null_mut(),
                channel_value_sats: Default::default(),
                unspendable_punishment_reserve: core::ptr::null_mut(),
                user_channel_id: Default::default(),
                feerate_sat_per_1000_weight: Default::default(),
                outbound_capacity_msat: Default::default(),
                inbound_capacity_msat: Default::default(),
                confirmations_required: core::ptr::null_mut(),
                confirmations: core::ptr::null_mut(),
                is_outbound: Default::default(),
                is_channel_ready: Default::default(),
                is_usable: Default::default(),
                cltv_expiry_delta: core::ptr::null_mut(),
                counterparty_unspendable_punishment_reserve: Default::default(),
                counterparty_outbound_htlc_minimum_msat: core::ptr::null_mut(),
                counterparty_outbound_htlc_maximum_msat: core::ptr::null_mut(),
                counterparty_forwarding_info_fee_base_msat: core::ptr::null_mut(),
                counterparty_forwarding_info_fee_proportional_millionths: core::ptr::null_mut(),
                counterparty_forwarding_info_cltv_expiry_delta: core::ptr::null_mut(),
                next_outbound_htlc_limit_msat: Default::default(),
                next_outbound_htlc_minimum_msat: Default::default(),
                force_close_spend_delay: core::ptr::null_mut(),
                inbound_htlc_minimum_msat: Default::default(),
                inbound_htlc_maximum_msat: core::ptr::null_mut(),
                config: Default::default(),
            }
        }
    }
    impl Default for wire_cst_channel_details {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_id {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_channel_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_info {
        fn new_with_null_ptr() -> Self {
            Self {
                node_one: Default::default(),
                one_to_two: core::ptr::null_mut(),
                node_two: Default::default(),
                two_to_one: core::ptr::null_mut(),
                capacity_sats: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_channel_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_update_info {
        fn new_with_null_ptr() -> Self {
            Self {
                last_update: Default::default(),
                enabled: Default::default(),
                cltv_expiry_delta: Default::default(),
                htlc_minimum_msat: Default::default(),
                htlc_maximum_msat: Default::default(),
                fees: Default::default(),
            }
        }
    }
    impl Default for wire_cst_channel_update_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_closure_reason {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: ClosureReasonKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_closure_reason {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_config {
        fn new_with_null_ptr() -> Self {
            Self {
                storage_dir_path: core::ptr::null_mut(),
                log_dir_path: core::ptr::null_mut(),
                network: Default::default(),
                listening_addresses: core::ptr::null_mut(),
                node_alias: core::ptr::null_mut(),
                trusted_peers_0conf: core::ptr::null_mut(),
                probing_liquidity_limit_multiplier: Default::default(),
                log_level: Default::default(),
                anchor_channels_config: core::ptr::null_mut(),
                sending_parameters: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_decode_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: DecodeErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_decode_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_entropy_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: EntropySourceConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_entropy_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_esplora_sync_config {
        fn new_with_null_ptr() -> Self {
            Self {
                onchain_wallet_sync_interval_secs: Default::default(),
                lightning_wallet_sync_interval_secs: Default::default(),
                fee_rate_cache_update_interval_secs: Default::default(),
            }
        }
    }
    impl Default for wire_cst_esplora_sync_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_event {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: EventKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_event {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_bolt_11_payment {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_bolt_11_payment {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_bolt_12_payment {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_bolt_12_payment {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_mnemonic {
        fn new_with_null_ptr() -> Self {
            Self {
                seed_phrase: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_ffi_mnemonic {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_network_graph {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_network_graph {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_node {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_node {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_node_error {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: FfiNodeErrorKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_ffi_node_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_on_chain_payment {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_on_chain_payment {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_spontaneous_payment {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_spontaneous_payment {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_unified_qr_payment {
        fn new_with_null_ptr() -> Self {
            Self {
                opaque: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_unified_qr_payment {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_gossip_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: GossipSourceConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_gossip_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_lightning_balance {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: LightningBalanceKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_lightning_balance {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_liquidity_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                lsps2_service: Default::default(),
            }
        }
    }
    impl Default for wire_cst_liquidity_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_lsp_fee_limits {
        fn new_with_null_ptr() -> Self {
            Self {
                max_total_opening_fee_msat: core::ptr::null_mut(),
                max_proportional_opening_fee_ppm_msat: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_lsp_fee_limits {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_max_dust_htlc_exposure {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: MaxDustHTLCExposureKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_max_dust_htlc_exposure {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_max_total_routing_fee_limit {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: MaxTotalRoutingFeeLimitKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_max_total_routing_fee_limit {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_alias {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_alias {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_announcement_info {
        fn new_with_null_ptr() -> Self {
            Self {
                last_update: Default::default(),
                alias: core::ptr::null_mut(),
                addresses: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_announcement_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_id {
        fn new_with_null_ptr() -> Self {
            Self {
                compressed: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_info {
        fn new_with_null_ptr() -> Self {
            Self {
                channels: core::ptr::null_mut(),
                announcement_info: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_status {
        fn new_with_null_ptr() -> Self {
            Self {
                is_running: Default::default(),
                is_listening: Default::default(),
                current_best_block: Default::default(),
                latest_lightning_wallet_sync_timestamp: core::ptr::null_mut(),
                latest_onchain_wallet_sync_timestamp: core::ptr::null_mut(),
                latest_fee_rate_cache_update_timestamp: core::ptr::null_mut(),
                latest_rgs_snapshot_timestamp: core::ptr::null_mut(),
                latest_node_announcement_broadcast_timestamp: core::ptr::null_mut(),
                latest_channel_monitor_archival_height: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_status {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_offer {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_offer {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_offer_id {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_offer_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_out_point {
        fn new_with_null_ptr() -> Self {
            Self {
                txid: Default::default(),
                vout: Default::default(),
            }
        }
    }
    impl Default for wire_cst_out_point {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_details {
        fn new_with_null_ptr() -> Self {
            Self {
                id: Default::default(),
                kind: Default::default(),
                amount_msat: core::ptr::null_mut(),
                direction: Default::default(),
                status: Default::default(),
                latest_update_timestamp: Default::default(),
            }
        }
    }
    impl Default for wire_cst_payment_details {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_hash {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_hash {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_id {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_kind {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: PaymentKindKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_payment_kind {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_preimage {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_preimage {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_secret {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_secret {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_peer_details {
        fn new_with_null_ptr() -> Self {
            Self {
                node_id: Default::default(),
                address: Default::default(),
                is_connected: Default::default(),
            }
        }
    }
    impl Default for wire_cst_peer_details {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_pending_sweep_balance {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: PendingSweepBalanceKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_pending_sweep_balance {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_public_key {
        fn new_with_null_ptr() -> Self {
            Self {
                hex: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_public_key {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_qr_payment_result {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: QrPaymentResultKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_qr_payment_result {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_socket_address_public_key_opt_string {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: Default::default(),
                field1: Default::default(),
                field2: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_socket_address_public_key_opt_string {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_string_string {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
                field1: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_string_string {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_refund {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_refund {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_routing_fees {
        fn new_with_null_ptr() -> Self {
            Self {
                base_msat: Default::default(),
                proportional_millionths: Default::default(),
            }
        }
    }
    impl Default for wire_cst_routing_fees {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sending_parameters {
        fn new_with_null_ptr() -> Self {
            Self {
                max_total_routing_fee_msat: core::ptr::null_mut(),
                max_total_cltv_expiry_delta: core::ptr::null_mut(),
                max_path_count: core::ptr::null_mut(),
                max_channel_saturation_power_of_half: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_sending_parameters {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_socket_address {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: SocketAddressKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_socket_address {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_txid {
        fn new_with_null_ptr() -> Self {
            Self {
                hash: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_txid {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_user_channel_id {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_user_channel_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_claim_for_hash(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        payment_hash: *mut wire_cst_payment_hash,
        claimable_amount_msat: u64,
        preimage: *mut wire_cst_payment_preimage,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_claim_for_hash_impl(
            port_,
            that,
            payment_hash,
            claimable_amount_msat,
            preimage,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_fail_for_hash(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        payment_hash: *mut wire_cst_payment_hash,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_fail_for_hash_impl(port_, that, payment_hash)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_receive(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_receive_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_receive_for_hash(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        payment_hash: *mut wire_cst_payment_hash,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_receive_for_hash_impl(
            port_,
            that,
            payment_hash,
            amount_msat,
            description,
            expiry_secs,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount_impl(
            port_,
            that,
            description,
            expiry_secs,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount_for_hash(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        payment_hash: *mut wire_cst_payment_hash,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount_for_hash_impl(
            port_,
            that,
            description,
            expiry_secs,
            payment_hash,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount_via_jit_channel(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        max_proportional_lsp_fee_limit_ppm_msat: *mut u64,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_receive_variable_amount_via_jit_channel_impl(
            port_,
            that,
            description,
            expiry_secs,
            max_proportional_lsp_fee_limit_ppm_msat,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_receive_via_jit_channel(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        max_total_lsp_fee_limit_msat: *mut u64,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_receive_via_jit_channel_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
            max_total_lsp_fee_limit_msat,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_send(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        invoice: *mut wire_cst_bolt_11_invoice,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_send_impl(
            port_,
            that,
            invoice,
            sending_parameters,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_send_probes(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        invoice: *mut wire_cst_bolt_11_invoice,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_send_probes_impl(port_, that, invoice)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_send_probes_using_amount(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        invoice: *mut wire_cst_bolt_11_invoice,
        amount_msat: u64,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_send_probes_using_amount_impl(
            port_,
            that,
            invoice,
            amount_msat,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt11__ffi_bolt_11_payment_send_using_amount(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_11_payment,
        invoice: *mut wire_cst_bolt_11_invoice,
        amount_msat: u64,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__crate__api__bolt11__ffi_bolt_11_payment_send_using_amount_impl(
            port_,
            that,
            invoice,
            amount_msat,
            sending_parameters,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt12__ffi_bolt_12_payment_initiate_refund(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_12_payment,
        amount_msat: u64,
        expiry_secs: u32,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__bolt12__ffi_bolt_12_payment_initiate_refund_impl(
            port_,
            that,
            amount_msat,
            expiry_secs,
            quantity,
            payer_note,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt12__ffi_bolt_12_payment_receive(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_12_payment,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: *mut u32,
        quantity: *mut u64,
    ) {
        wire__crate__api__bolt12__ffi_bolt_12_payment_receive_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
            quantity,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt12__ffi_bolt_12_payment_receive_variable_amount(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_12_payment,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: *mut u32,
    ) {
        wire__crate__api__bolt12__ffi_bolt_12_payment_receive_variable_amount_impl(
            port_,
            that,
            description,
            expiry_secs,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt12__ffi_bolt_12_payment_request_refund_payment(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_12_payment,
        refund: *mut wire_cst_refund,
    ) {
        wire__crate__api__bolt12__ffi_bolt_12_payment_request_refund_payment_impl(
            port_, that, refund,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt12__ffi_bolt_12_payment_send(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_12_payment,
        offer: *mut wire_cst_offer,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__bolt12__ffi_bolt_12_payment_send_impl(
            port_, that, offer, quantity, payer_note,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__bolt12__ffi_bolt_12_payment_send_using_amount(
        port_: i64,
        that: *mut wire_cst_ffi_bolt_12_payment,
        offer: *mut wire_cst_offer,
        amount_msat: u64,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__bolt12__ffi_bolt_12_payment_send_using_amount_impl(
            port_,
            that,
            offer,
            amount_msat,
            quantity,
            payer_note,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__builder__FfiBuilder_auto_accessor_get_opaque(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__builder__FfiBuilder_auto_accessor_get_opaque_impl(that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__builder__FfiBuilder_auto_accessor_set_opaque(
        that: usize,
        opaque: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__builder__FfiBuilder_auto_accessor_set_opaque_impl(that, opaque)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__builder__FfiBuilder_build(
        port_: i64,
        that: usize,
    ) {
        wire__crate__api__builder__FfiBuilder_build_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__builder__FfiBuilder_build_with_fs_store(
        port_: i64,
        that: usize,
    ) {
        wire__crate__api__builder__FfiBuilder_build_with_fs_store_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__builder__FfiBuilder_build_with_vss_store(
        port_: i64,
        that: usize,
        vss_url: *mut wire_cst_list_prim_u_8_strict,
        store_id: *mut wire_cst_list_prim_u_8_strict,
        lnurl_auth_server_url: *mut wire_cst_list_prim_u_8_strict,
        fixed_headers: *mut wire_cst_list_record_string_string,
    ) {
        wire__crate__api__builder__FfiBuilder_build_with_vss_store_impl(
            port_,
            that,
            vss_url,
            store_id,
            lnurl_auth_server_url,
            fixed_headers,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__builder__FfiBuilder_build_with_vss_store_and_fixed_headers(
        port_: i64,
        that: usize,
        vss_url: *mut wire_cst_list_prim_u_8_strict,
        store_id: *mut wire_cst_list_prim_u_8_strict,
        fixed_headers: *mut wire_cst_list_record_string_string,
    ) {
        wire__crate__api__builder__FfiBuilder_build_with_vss_store_and_fixed_headers_impl(
            port_,
            that,
            vss_url,
            store_id,
            fixed_headers,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__builder__FfiBuilder_create_builder(
        config: *mut wire_cst_config,
        chain_data_source_config: *mut wire_cst_chain_data_source_config,
        entropy_source_config: *mut wire_cst_entropy_source_config,
        gossip_source_config: *mut wire_cst_gossip_source_config,
        liquidity_source_config: *mut wire_cst_liquidity_source_config,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__builder__FfiBuilder_create_builder_impl(
            config,
            chain_data_source_config,
            entropy_source_config,
            gossip_source_config,
            liquidity_source_config,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__builder__ffi_mnemonic_generate(port_: i64) {
        wire__crate__api__builder__ffi_mnemonic_generate_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__graph__ffi_network_graph_channel(
        port_: i64,
        that: *mut wire_cst_ffi_network_graph,
        short_channel_id: u64,
    ) {
        wire__crate__api__graph__ffi_network_graph_channel_impl(port_, that, short_channel_id)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__graph__ffi_network_graph_list_channels(
        port_: i64,
        that: *mut wire_cst_ffi_network_graph,
    ) {
        wire__crate__api__graph__ffi_network_graph_list_channels_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__graph__ffi_network_graph_list_nodes(
        port_: i64,
        that: *mut wire_cst_ffi_network_graph,
    ) {
        wire__crate__api__graph__ffi_network_graph_list_nodes_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__graph__ffi_network_graph_node(
        port_: i64,
        that: *mut wire_cst_ffi_network_graph,
        node_id: *mut wire_cst_node_id,
    ) {
        wire__crate__api__graph__ffi_network_graph_node_impl(port_, that, node_id)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_bolt11_payment(
        port_: i64,
        ptr: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_bolt11_payment_impl(port_, ptr)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_bolt12_payment(
        port_: i64,
        ptr: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_bolt12_payment_impl(port_, ptr)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_close_channel(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        user_channel_id: *mut wire_cst_user_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
    ) {
        wire__crate__api__node__ffi_node_close_channel_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_config(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_config_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_connect(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        node_id: *mut wire_cst_public_key,
        address: *mut wire_cst_socket_address,
        persist: bool,
    ) {
        wire__crate__api__node__ffi_node_connect_impl(port_, that, node_id, address, persist)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_disconnect(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        counterparty_node_id: *mut wire_cst_public_key,
    ) {
        wire__crate__api__node__ffi_node_disconnect_impl(port_, that, counterparty_node_id)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_event_handled(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_event_handled_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_force_close_channel(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        user_channel_id: *mut wire_cst_user_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
    ) {
        wire__crate__api__node__ffi_node_force_close_channel_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_list_balances(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_list_balances_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_list_channels(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_list_channels_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_list_payments(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_list_payments_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_list_payments_with_filter(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        payment_direction: i32,
    ) {
        wire__crate__api__node__ffi_node_list_payments_with_filter_impl(
            port_,
            that,
            payment_direction,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_list_peers(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_list_peers_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_listening_addresses(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_listening_addresses_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_network_graph(
        port_: i64,
        ptr: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_network_graph_impl(port_, ptr)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_next_event(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_next_event_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_next_event_async(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_next_event_async_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_node_id(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_node_id_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_on_chain_payment(
        port_: i64,
        ptr: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_on_chain_payment_impl(port_, ptr)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_open_announced_channel(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        socket_address: *mut wire_cst_socket_address,
        node_id: *mut wire_cst_public_key,
        channel_amount_sats: u64,
        push_to_counterparty_msat: *mut u64,
        channel_config: *mut wire_cst_channel_config,
    ) {
        wire__crate__api__node__ffi_node_open_announced_channel_impl(
            port_,
            that,
            socket_address,
            node_id,
            channel_amount_sats,
            push_to_counterparty_msat,
            channel_config,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_open_channel(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        socket_address: *mut wire_cst_socket_address,
        node_id: *mut wire_cst_public_key,
        channel_amount_sats: u64,
        push_to_counterparty_msat: *mut u64,
        channel_config: *mut wire_cst_channel_config,
    ) {
        wire__crate__api__node__ffi_node_open_channel_impl(
            port_,
            that,
            socket_address,
            node_id,
            channel_amount_sats,
            push_to_counterparty_msat,
            channel_config,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_payment(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        payment_id: *mut wire_cst_payment_id,
    ) {
        wire__crate__api__node__ffi_node_payment_impl(port_, that, payment_id)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_remove_payment(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        payment_id: *mut wire_cst_payment_id,
    ) {
        wire__crate__api__node__ffi_node_remove_payment_impl(port_, that, payment_id)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_sign_message(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        msg: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__crate__api__node__ffi_node_sign_message_impl(port_, that, msg)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_spontaneous_payment(
        port_: i64,
        ptr: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_spontaneous_payment_impl(port_, ptr)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_start(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_start_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_status(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_status_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_stop(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_stop_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_sync_wallets(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_sync_wallets_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_unified_qr_payment(
        port_: i64,
        ptr: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_unified_qr_payment_impl(port_, ptr)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_update_channel_config(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        user_channel_id: *mut wire_cst_user_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
        channel_config: *mut wire_cst_channel_config,
    ) {
        wire__crate__api__node__ffi_node_update_channel_config_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
            channel_config,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_verify_signature(
        port_: i64,
        that: *mut wire_cst_ffi_node,
        msg: *mut wire_cst_list_prim_u_8_loose,
        sig: *mut wire_cst_list_prim_u_8_strict,
        public_key: *mut wire_cst_public_key,
    ) {
        wire__crate__api__node__ffi_node_verify_signature_impl(port_, that, msg, sig, public_key)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__node__ffi_node_wait_next_event(
        port_: i64,
        that: *mut wire_cst_ffi_node,
    ) {
        wire__crate__api__node__ffi_node_wait_next_event_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__on_chain__ffi_on_chain_payment_new_address(
        port_: i64,
        that: *mut wire_cst_ffi_on_chain_payment,
    ) {
        wire__crate__api__on_chain__ffi_on_chain_payment_new_address_impl(port_, that)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__on_chain__ffi_on_chain_payment_send_all_to_address(
        port_: i64,
        that: *mut wire_cst_ffi_on_chain_payment,
        address: *mut wire_cst_address,
    ) {
        wire__crate__api__on_chain__ffi_on_chain_payment_send_all_to_address_impl(
            port_, that, address,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__on_chain__ffi_on_chain_payment_send_to_address(
        port_: i64,
        that: *mut wire_cst_ffi_on_chain_payment,
        address: *mut wire_cst_address,
        amount_sats: u64,
    ) {
        wire__crate__api__on_chain__ffi_on_chain_payment_send_to_address_impl(
            port_,
            that,
            address,
            amount_sats,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__spontaneous__ffi_spontaneous_payment_send(
        port_: i64,
        that: *mut wire_cst_ffi_spontaneous_payment,
        amount_msat: u64,
        node_id: *mut wire_cst_public_key,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__crate__api__spontaneous__ffi_spontaneous_payment_send_impl(
            port_,
            that,
            amount_msat,
            node_id,
            sending_parameters,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__spontaneous__ffi_spontaneous_payment_send_probes(
        port_: i64,
        that: *mut wire_cst_ffi_spontaneous_payment,
        amount_msat: u64,
        node_id: *mut wire_cst_public_key,
    ) {
        wire__crate__api__spontaneous__ffi_spontaneous_payment_send_probes_impl(
            port_,
            that,
            amount_msat,
            node_id,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__types__anchor_channels_config_default(
        port_: i64,
    ) {
        wire__crate__api__types__anchor_channels_config_default_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__types__config_default(port_: i64) {
        wire__crate__api__types__config_default_impl(port_)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__unified_qr__ffi_unified_qr_payment_receive(
        port_: i64,
        that: *mut wire_cst_ffi_unified_qr_payment,
        amount_sats: u64,
        message: *mut wire_cst_list_prim_u_8_strict,
        expiry_sec: u32,
    ) {
        wire__crate__api__unified_qr__ffi_unified_qr_payment_receive_impl(
            port_,
            that,
            amount_sats,
            message,
            expiry_sec,
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__unified_qr__ffi_unified_qr_payment_send(
        port_: i64,
        that: *mut wire_cst_ffi_unified_qr_payment,
        uri_str: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__unified_qr__ffi_unified_qr_payment_send_impl(port_, that, uri_str)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFfiBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiBuilder>>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_ldk_nodeBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::Builder>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_ldk_nodeBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::Builder>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_ldk_nodeNode(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::Node>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_ldk_nodeNode(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::Node>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_ldk_nodegraphNetworkGraph(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::graph::NetworkGraph>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_ldk_nodegraphNetworkGraph(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::graph::NetworkGraph>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentBolt11Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::payment::Bolt11Payment>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentBolt11Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::payment::Bolt11Payment>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentBolt12Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::payment::Bolt12Payment>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentBolt12Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::payment::Bolt12Payment>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentOnchainPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::payment::OnchainPayment>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentOnchainPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::payment::OnchainPayment>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentSpontaneousPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::payment::SpontaneousPayment>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentSpontaneousPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::payment::SpontaneousPayment>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_ldk_nodepaymentUnifiedQrPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::payment::UnifiedQrPayment>::increment_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_ldk_nodepaymentUnifiedQrPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<ldk_node::payment::UnifiedQrPayment>::decrement_strong_count(ptr as _);
        }
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_address() -> *mut wire_cst_address {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_address::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_anchor_channels_config(
    ) -> *mut wire_cst_anchor_channels_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_anchor_channels_config::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_bolt_11_invoice(
    ) -> *mut wire_cst_bolt_11_invoice {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bolt_11_invoice::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_bolt_12_parse_error(
    ) -> *mut wire_cst_bolt_12_parse_error {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bolt_12_parse_error::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_bool(value: bool) -> *mut bool {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_chain_data_source_config(
    ) -> *mut wire_cst_chain_data_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_chain_data_source_config::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_channel_config(
    ) -> *mut wire_cst_channel_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_channel_config::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_channel_id() -> *mut wire_cst_channel_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_channel_id::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_channel_info(
    ) -> *mut wire_cst_channel_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_channel_info::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_channel_update_info(
    ) -> *mut wire_cst_channel_update_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_channel_update_info::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_closure_reason(
    ) -> *mut wire_cst_closure_reason {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_closure_reason::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_config() -> *mut wire_cst_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_config::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_decode_error(
    ) -> *mut wire_cst_decode_error {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_decode_error::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_entropy_source_config(
    ) -> *mut wire_cst_entropy_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_entropy_source_config::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_esplora_sync_config(
    ) -> *mut wire_cst_esplora_sync_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_esplora_sync_config::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_event() -> *mut wire_cst_event {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_event::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_bolt_11_payment(
    ) -> *mut wire_cst_ffi_bolt_11_payment {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_bolt_11_payment::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_bolt_12_payment(
    ) -> *mut wire_cst_ffi_bolt_12_payment {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_bolt_12_payment::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_mnemonic(
    ) -> *mut wire_cst_ffi_mnemonic {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_mnemonic::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_network_graph(
    ) -> *mut wire_cst_ffi_network_graph {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_network_graph::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_node() -> *mut wire_cst_ffi_node {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_ffi_node::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_on_chain_payment(
    ) -> *mut wire_cst_ffi_on_chain_payment {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_on_chain_payment::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_spontaneous_payment(
    ) -> *mut wire_cst_ffi_spontaneous_payment {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_spontaneous_payment::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_unified_qr_payment(
    ) -> *mut wire_cst_ffi_unified_qr_payment {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_unified_qr_payment::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_gossip_source_config(
    ) -> *mut wire_cst_gossip_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_gossip_source_config::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_liquidity_source_config(
    ) -> *mut wire_cst_liquidity_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_liquidity_source_config::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_lsp_fee_limits(
    ) -> *mut wire_cst_lsp_fee_limits {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_lsp_fee_limits::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_max_total_routing_fee_limit(
    ) -> *mut wire_cst_max_total_routing_fee_limit {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_max_total_routing_fee_limit::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_alias() -> *mut wire_cst_node_alias {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_node_alias::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_announcement_info(
    ) -> *mut wire_cst_node_announcement_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_node_announcement_info::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_id() -> *mut wire_cst_node_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_node_id::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_info() -> *mut wire_cst_node_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_node_info::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_offer() -> *mut wire_cst_offer {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_offer::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_offer_id() -> *mut wire_cst_offer_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_offer_id::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_out_point() -> *mut wire_cst_out_point {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_out_point::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_details(
    ) -> *mut wire_cst_payment_details {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_details::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_failure_reason(
        value: i32,
    ) -> *mut i32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_hash(
    ) -> *mut wire_cst_payment_hash {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_hash::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_id() -> *mut wire_cst_payment_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_id::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_preimage(
    ) -> *mut wire_cst_payment_preimage {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_preimage::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_secret(
    ) -> *mut wire_cst_payment_secret {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_secret::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_public_key() -> *mut wire_cst_public_key {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_public_key::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_refund() -> *mut wire_cst_refund {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_refund::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_sending_parameters(
    ) -> *mut wire_cst_sending_parameters {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_sending_parameters::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_socket_address(
    ) -> *mut wire_cst_socket_address {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_socket_address::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_txid() -> *mut wire_cst_txid {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_txid::new_with_null_ptr())
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_16(value: u16) -> *mut u16 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_8(value: u8) -> *mut u8 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_user_channel_id(
    ) -> *mut wire_cst_user_channel_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_user_channel_id::new_with_null_ptr(),
        )
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_channel_details(
        len: i32,
    ) -> *mut wire_cst_list_channel_details {
        let wrap = wire_cst_list_channel_details {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_channel_details>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_lightning_balance(
        len: i32,
    ) -> *mut wire_cst_list_lightning_balance {
        let wrap = wire_cst_list_lightning_balance {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_lightning_balance>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_node_id(len: i32) -> *mut wire_cst_list_node_id {
        let wrap = wire_cst_list_node_id {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_node_id>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_payment_details(
        len: i32,
    ) -> *mut wire_cst_list_payment_details {
        let wrap = wire_cst_list_payment_details {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_payment_details>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_peer_details(
        len: i32,
    ) -> *mut wire_cst_list_peer_details {
        let wrap = wire_cst_list_peer_details {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_peer_details>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_pending_sweep_balance(
        len: i32,
    ) -> *mut wire_cst_list_pending_sweep_balance {
        let wrap = wire_cst_list_pending_sweep_balance {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_pending_sweep_balance>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_64_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_64_strict {
        let ans = wire_cst_list_prim_u_64_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_8_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_loose {
        let ans = wire_cst_list_prim_u_8_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_public_key(
        len: i32,
    ) -> *mut wire_cst_list_public_key {
        let wrap = wire_cst_list_public_key {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_public_key>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_record_string_string(
        len: i32,
    ) -> *mut wire_cst_list_record_string_string {
        let wrap = wire_cst_list_record_string_string {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_string_string>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[no_mangle]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_socket_address(
        len: i32,
    ) -> *mut wire_cst_list_socket_address {
        let wrap = wire_cst_list_socket_address {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_socket_address>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_anchor_channels_config {
        trusted_peers_no_reserve: *mut wire_cst_list_public_key,
        per_channel_reserve_sats: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_balance_details {
        total_onchain_balance_sats: u64,
        spendable_onchain_balance_sats: u64,
        total_lightning_balance_sats: u64,
        lightning_balances: *mut wire_cst_list_lightning_balance,
        pending_balances_from_channel_closures: *mut wire_cst_list_pending_sweep_balance,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_best_block {
        block_hash: *mut wire_cst_list_prim_u_8_strict,
        height: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bolt_11_invoice {
        signed_raw_invoice: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bolt_12_invoice {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bolt_12_parse_error {
        tag: i32,
        kind: Bolt12ParseErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union Bolt12ParseErrorKind {
        Bech32: wire_cst_Bolt12ParseError_Bech32,
        Decode: wire_cst_Bolt12ParseError_Decode,
        InvalidSemantics: wire_cst_Bolt12ParseError_InvalidSemantics,
        InvalidSignature: wire_cst_Bolt12ParseError_InvalidSignature,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bolt12ParseError_Bech32 {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bolt12ParseError_Decode {
        field0: *mut wire_cst_decode_error,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bolt12ParseError_InvalidSemantics {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Bolt12ParseError_InvalidSignature {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_chain_data_source_config {
        tag: i32,
        kind: ChainDataSourceConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union ChainDataSourceConfigKind {
        Esplora: wire_cst_ChainDataSourceConfig_Esplora,
        BitcoindRpc: wire_cst_ChainDataSourceConfig_BitcoindRpc,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ChainDataSourceConfig_Esplora {
        server_url: *mut wire_cst_list_prim_u_8_strict,
        sync_config: *mut wire_cst_esplora_sync_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ChainDataSourceConfig_BitcoindRpc {
        rpc_host: *mut wire_cst_list_prim_u_8_strict,
        rpc_port: u16,
        rpc_user: *mut wire_cst_list_prim_u_8_strict,
        rpc_password: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_config {
        forwarding_fee_proportional_millionths: u32,
        forwarding_fee_base_msat: u32,
        cltv_expiry_delta: u16,
        max_dust_htlc_exposure: wire_cst_max_dust_htlc_exposure,
        force_close_avoidance_max_fee_satoshis: u64,
        accept_underpaying_htlcs: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_details {
        channel_id: wire_cst_channel_id,
        counterparty_node_id: wire_cst_public_key,
        funding_txo: *mut wire_cst_out_point,
        channel_value_sats: u64,
        unspendable_punishment_reserve: *mut u64,
        user_channel_id: wire_cst_user_channel_id,
        feerate_sat_per_1000_weight: u32,
        outbound_capacity_msat: u64,
        inbound_capacity_msat: u64,
        confirmations_required: *mut u32,
        confirmations: *mut u32,
        is_outbound: bool,
        is_channel_ready: bool,
        is_usable: bool,
        cltv_expiry_delta: *mut u16,
        counterparty_unspendable_punishment_reserve: u64,
        counterparty_outbound_htlc_minimum_msat: *mut u64,
        counterparty_outbound_htlc_maximum_msat: *mut u64,
        counterparty_forwarding_info_fee_base_msat: *mut u32,
        counterparty_forwarding_info_fee_proportional_millionths: *mut u32,
        counterparty_forwarding_info_cltv_expiry_delta: *mut u16,
        next_outbound_htlc_limit_msat: u64,
        next_outbound_htlc_minimum_msat: u64,
        force_close_spend_delay: *mut u16,
        inbound_htlc_minimum_msat: u64,
        inbound_htlc_maximum_msat: *mut u64,
        config: wire_cst_channel_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_id {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_info {
        node_one: wire_cst_node_id,
        one_to_two: *mut wire_cst_channel_update_info,
        node_two: wire_cst_node_id,
        two_to_one: *mut wire_cst_channel_update_info,
        capacity_sats: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_update_info {
        last_update: u32,
        enabled: bool,
        cltv_expiry_delta: u16,
        htlc_minimum_msat: u64,
        htlc_maximum_msat: u64,
        fees: wire_cst_routing_fees,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_closure_reason {
        tag: i32,
        kind: ClosureReasonKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union ClosureReasonKind {
        PeerFeerateTooLow: wire_cst_ClosureReason_PeerFeerateTooLow,
        CounterpartyForceClosed: wire_cst_ClosureReason_CounterpartyForceClosed,
        HolderForceClosed: wire_cst_ClosureReason_HolderForceClosed,
        ProcessingError: wire_cst_ClosureReason_ProcessingError,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ClosureReason_PeerFeerateTooLow {
        peer_feerate_sat_per_kw: u32,
        required_feerate_sat_per_kw: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ClosureReason_CounterpartyForceClosed {
        peer_msg: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ClosureReason_HolderForceClosed {
        broadcasted_latest_txn: *mut bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ClosureReason_ProcessingError {
        err: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_config {
        storage_dir_path: *mut wire_cst_list_prim_u_8_strict,
        log_dir_path: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
        listening_addresses: *mut wire_cst_list_socket_address,
        node_alias: *mut wire_cst_node_alias,
        trusted_peers_0conf: *mut wire_cst_list_public_key,
        probing_liquidity_limit_multiplier: u64,
        log_level: i32,
        anchor_channels_config: *mut wire_cst_anchor_channels_config,
        sending_parameters: *mut wire_cst_sending_parameters,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_decode_error {
        tag: i32,
        kind: DecodeErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union DecodeErrorKind {
        Io: wire_cst_DecodeError_Io,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_DecodeError_Io {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_entropy_source_config {
        tag: i32,
        kind: EntropySourceConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union EntropySourceConfigKind {
        SeedFile: wire_cst_EntropySourceConfig_SeedFile,
        SeedBytes: wire_cst_EntropySourceConfig_SeedBytes,
        Bip39Mnemonic: wire_cst_EntropySourceConfig_Bip39Mnemonic,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EntropySourceConfig_SeedFile {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EntropySourceConfig_SeedBytes {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EntropySourceConfig_Bip39Mnemonic {
        mnemonic: *mut wire_cst_ffi_mnemonic,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_esplora_sync_config {
        onchain_wallet_sync_interval_secs: u64,
        lightning_wallet_sync_interval_secs: u64,
        fee_rate_cache_update_interval_secs: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_event {
        tag: i32,
        kind: EventKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union EventKind {
        PaymentClaimable: wire_cst_Event_PaymentClaimable,
        PaymentSuccessful: wire_cst_Event_PaymentSuccessful,
        PaymentFailed: wire_cst_Event_PaymentFailed,
        PaymentReceived: wire_cst_Event_PaymentReceived,
        ChannelPending: wire_cst_Event_ChannelPending,
        ChannelReady: wire_cst_Event_ChannelReady,
        ChannelClosed: wire_cst_Event_ChannelClosed,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_PaymentClaimable {
        payment_id: *mut wire_cst_payment_id,
        payment_hash: *mut wire_cst_payment_hash,
        claimable_amount_msat: u64,
        claim_deadline: *mut u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_PaymentSuccessful {
        payment_id: *mut wire_cst_payment_id,
        payment_hash: *mut wire_cst_payment_hash,
        fee_paid_msat: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_PaymentFailed {
        payment_id: *mut wire_cst_payment_id,
        payment_hash: *mut wire_cst_payment_hash,
        reason: *mut i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_PaymentReceived {
        payment_id: *mut wire_cst_payment_id,
        payment_hash: *mut wire_cst_payment_hash,
        amount_msat: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_ChannelPending {
        channel_id: *mut wire_cst_channel_id,
        user_channel_id: *mut wire_cst_user_channel_id,
        former_temporary_channel_id: *mut wire_cst_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
        funding_txo: *mut wire_cst_out_point,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_ChannelReady {
        channel_id: *mut wire_cst_channel_id,
        user_channel_id: *mut wire_cst_user_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_ChannelClosed {
        channel_id: *mut wire_cst_channel_id,
        user_channel_id: *mut wire_cst_user_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
        reason: *mut wire_cst_closure_reason,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_bolt_11_payment {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_bolt_12_payment {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_mnemonic {
        seed_phrase: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_network_graph {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_node {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_node_error {
        tag: i32,
        kind: FfiNodeErrorKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union FfiNodeErrorKind {
        Decode: wire_cst_FfiNodeError_Decode,
        Bolt12Parse: wire_cst_FfiNodeError_Bolt12Parse,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_FfiNodeError_Decode {
        field0: *mut wire_cst_decode_error,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_FfiNodeError_Bolt12Parse {
        field0: *mut wire_cst_bolt_12_parse_error,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_on_chain_payment {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_spontaneous_payment {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_unified_qr_payment {
        opaque: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_gossip_source_config {
        tag: i32,
        kind: GossipSourceConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union GossipSourceConfigKind {
        RapidGossipSync: wire_cst_GossipSourceConfig_RapidGossipSync,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_GossipSourceConfig_RapidGossipSync {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_lightning_balance {
        tag: i32,
        kind: LightningBalanceKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union LightningBalanceKind {
        ClaimableOnChannelClose: wire_cst_LightningBalance_ClaimableOnChannelClose,
        ClaimableAwaitingConfirmations: wire_cst_LightningBalance_ClaimableAwaitingConfirmations,
        ContentiousClaimable: wire_cst_LightningBalance_ContentiousClaimable,
        MaybeTimeoutClaimableHTLC: wire_cst_LightningBalance_MaybeTimeoutClaimableHTLC,
        MaybePreimageClaimableHTLC: wire_cst_LightningBalance_MaybePreimageClaimableHTLC,
        CounterpartyRevokedOutputClaimable:
            wire_cst_LightningBalance_CounterpartyRevokedOutputClaimable,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_ClaimableOnChannelClose {
        channel_id: *mut wire_cst_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
        amount_satoshis: u64,
        transaction_fee_satoshis: u64,
        outbound_payment_htlc_rounded_msat: u64,
        outbound_forwarded_htlc_rounded_msat: u64,
        inbound_claiming_htlc_rounded_msat: u64,
        inbound_htlc_rounded_msat: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_ClaimableAwaitingConfirmations {
        channel_id: *mut wire_cst_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
        amount_satoshis: u64,
        confirmation_height: u32,
        source: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_ContentiousClaimable {
        channel_id: *mut wire_cst_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
        amount_satoshis: u64,
        timeout_height: u32,
        payment_hash: *mut wire_cst_payment_hash,
        payment_preimage: *mut wire_cst_payment_preimage,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_MaybeTimeoutClaimableHTLC {
        channel_id: *mut wire_cst_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
        amount_satoshis: u64,
        claimable_height: u32,
        payment_hash: *mut wire_cst_payment_hash,
        outbound_payment: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_MaybePreimageClaimableHTLC {
        channel_id: *mut wire_cst_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
        amount_satoshis: u64,
        expiry_height: u32,
        payment_hash: *mut wire_cst_payment_hash,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_CounterpartyRevokedOutputClaimable {
        channel_id: *mut wire_cst_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
        amount_satoshis: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_liquidity_source_config {
        lsps2_service: wire_cst_record_socket_address_public_key_opt_string,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_channel_details {
        ptr: *mut wire_cst_channel_details,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_lightning_balance {
        ptr: *mut wire_cst_lightning_balance,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_node_id {
        ptr: *mut wire_cst_node_id,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_payment_details {
        ptr: *mut wire_cst_payment_details,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_peer_details {
        ptr: *mut wire_cst_peer_details,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_pending_sweep_balance {
        ptr: *mut wire_cst_pending_sweep_balance,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_64_strict {
        ptr: *mut u64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_loose {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_public_key {
        ptr: *mut wire_cst_public_key,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_string_string {
        ptr: *mut wire_cst_record_string_string,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_socket_address {
        ptr: *mut wire_cst_socket_address,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_lsp_fee_limits {
        max_total_opening_fee_msat: *mut u64,
        max_proportional_opening_fee_ppm_msat: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_max_dust_htlc_exposure {
        tag: i32,
        kind: MaxDustHTLCExposureKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union MaxDustHTLCExposureKind {
        FixedLimitMsat: wire_cst_MaxDustHTLCExposure_FixedLimitMsat,
        FeeRateMultiplier: wire_cst_MaxDustHTLCExposure_FeeRateMultiplier,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_MaxDustHTLCExposure_FixedLimitMsat {
        field0: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_MaxDustHTLCExposure_FeeRateMultiplier {
        field0: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_max_total_routing_fee_limit {
        tag: i32,
        kind: MaxTotalRoutingFeeLimitKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union MaxTotalRoutingFeeLimitKind {
        FeeCap: wire_cst_MaxTotalRoutingFeeLimit_FeeCap,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_MaxTotalRoutingFeeLimit_FeeCap {
        amount_msat: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_alias {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_announcement_info {
        last_update: u32,
        alias: *mut wire_cst_list_prim_u_8_strict,
        addresses: *mut wire_cst_list_socket_address,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_id {
        compressed: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_info {
        channels: *mut wire_cst_list_prim_u_64_strict,
        announcement_info: *mut wire_cst_node_announcement_info,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_status {
        is_running: bool,
        is_listening: bool,
        current_best_block: wire_cst_best_block,
        latest_lightning_wallet_sync_timestamp: *mut u64,
        latest_onchain_wallet_sync_timestamp: *mut u64,
        latest_fee_rate_cache_update_timestamp: *mut u64,
        latest_rgs_snapshot_timestamp: *mut u64,
        latest_node_announcement_broadcast_timestamp: *mut u64,
        latest_channel_monitor_archival_height: *mut u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_offer {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_offer_id {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_out_point {
        txid: wire_cst_txid,
        vout: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_details {
        id: wire_cst_payment_id,
        kind: wire_cst_payment_kind,
        amount_msat: *mut u64,
        direction: i32,
        status: i32,
        latest_update_timestamp: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_hash {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_id {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_kind {
        tag: i32,
        kind: PaymentKindKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union PaymentKindKind {
        Bolt11: wire_cst_PaymentKind_Bolt11,
        Bolt11Jit: wire_cst_PaymentKind_Bolt11Jit,
        Spontaneous: wire_cst_PaymentKind_Spontaneous,
        Bolt12Offer: wire_cst_PaymentKind_Bolt12Offer,
        Bolt12Refund: wire_cst_PaymentKind_Bolt12Refund,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Bolt11 {
        hash: *mut wire_cst_payment_hash,
        preimage: *mut wire_cst_payment_preimage,
        secret: *mut wire_cst_payment_secret,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Bolt11Jit {
        hash: *mut wire_cst_payment_hash,
        preimage: *mut wire_cst_payment_preimage,
        secret: *mut wire_cst_payment_secret,
        lsp_fee_limits: *mut wire_cst_lsp_fee_limits,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Spontaneous {
        hash: *mut wire_cst_payment_hash,
        preimage: *mut wire_cst_payment_preimage,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Bolt12Offer {
        hash: *mut wire_cst_payment_hash,
        preimage: *mut wire_cst_payment_preimage,
        secret: *mut wire_cst_payment_secret,
        offer_id: *mut wire_cst_offer_id,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
        quantity: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Bolt12Refund {
        hash: *mut wire_cst_payment_hash,
        preimage: *mut wire_cst_payment_preimage,
        secret: *mut wire_cst_payment_secret,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
        quantity: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_preimage {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_secret {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_peer_details {
        node_id: wire_cst_public_key,
        address: wire_cst_socket_address,
        is_connected: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_pending_sweep_balance {
        tag: i32,
        kind: PendingSweepBalanceKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union PendingSweepBalanceKind {
        PendingBroadcast: wire_cst_PendingSweepBalance_PendingBroadcast,
        BroadcastAwaitingConfirmation: wire_cst_PendingSweepBalance_BroadcastAwaitingConfirmation,
        AwaitingThresholdConfirmations: wire_cst_PendingSweepBalance_AwaitingThresholdConfirmations,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PendingSweepBalance_PendingBroadcast {
        channel_id: *mut wire_cst_channel_id,
        amount_satoshis: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PendingSweepBalance_BroadcastAwaitingConfirmation {
        channel_id: *mut wire_cst_channel_id,
        latest_broadcast_height: u32,
        latest_spending_txid: *mut wire_cst_txid,
        amount_satoshis: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PendingSweepBalance_AwaitingThresholdConfirmations {
        channel_id: *mut wire_cst_channel_id,
        latest_spending_txid: *mut wire_cst_txid,
        confirmation_hash: *mut wire_cst_list_prim_u_8_strict,
        confirmation_height: u32,
        amount_satoshis: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_public_key {
        hex: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_qr_payment_result {
        tag: i32,
        kind: QrPaymentResultKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union QrPaymentResultKind {
        Onchain: wire_cst_QrPaymentResult_Onchain,
        Bolt11: wire_cst_QrPaymentResult_Bolt11,
        Bolt12: wire_cst_QrPaymentResult_Bolt12,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_QrPaymentResult_Onchain {
        txid: *mut wire_cst_txid,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_QrPaymentResult_Bolt11 {
        payment_id: *mut wire_cst_payment_id,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_QrPaymentResult_Bolt12 {
        payment_id: *mut wire_cst_payment_id,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_socket_address_public_key_opt_string {
        field0: wire_cst_socket_address,
        field1: wire_cst_public_key,
        field2: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_string_string {
        field0: *mut wire_cst_list_prim_u_8_strict,
        field1: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_refund {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_routing_fees {
        base_msat: u32,
        proportional_millionths: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sending_parameters {
        max_total_routing_fee_msat: *mut wire_cst_max_total_routing_fee_limit,
        max_total_cltv_expiry_delta: *mut u32,
        max_path_count: *mut u8,
        max_channel_saturation_power_of_half: *mut u8,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_socket_address {
        tag: i32,
        kind: SocketAddressKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union SocketAddressKind {
        TcpIpV4: wire_cst_SocketAddress_TcpIpV4,
        TcpIpV6: wire_cst_SocketAddress_TcpIpV6,
        OnionV2: wire_cst_SocketAddress_OnionV2,
        OnionV3: wire_cst_SocketAddress_OnionV3,
        Hostname: wire_cst_SocketAddress_Hostname,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SocketAddress_TcpIpV4 {
        addr: *mut wire_cst_list_prim_u_8_strict,
        port: u16,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SocketAddress_TcpIpV6 {
        addr: *mut wire_cst_list_prim_u_8_strict,
        port: u16,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SocketAddress_OnionV2 {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SocketAddress_OnionV3 {
        ed25519_pubkey: *mut wire_cst_list_prim_u_8_strict,
        checksum: u16,
        version: u8,
        port: u16,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_SocketAddress_Hostname {
        addr: *mut wire_cst_list_prim_u_8_strict,
        port: u16,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_txid {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_user_channel_id {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
