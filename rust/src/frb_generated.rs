// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};
use ldk_adapter::bolt11::*;
use ldk_adapter::bolt12::*;
use ldk_adapter::builder::*;
use ldk_adapter::graph::*;
use ldk_adapter::node::*;
use ldk_adapter::on_chain::*;
use ldk_adapter::spontaneous::*;
use ldk_adapter::types::*;
use ldk_adapter::unified_qr::*;
use shared::*;

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1190083986;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__ldk_adapter__types__AnchorChannelsConfig_add_trusted_peer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        >,
    >,
    peer: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_add_trusted_peer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_peer = peer.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok({
                        ldk_adapter::types::AnchorChannelsConfig::add_trusted_peer(
                            &mut *api_that_guard,
                            api_peer,
                        );
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_get_per_channel_reserve_sats_impl(
    that: impl CstDecode<
        RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        >,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_auto_accessor_get_per_channel_reserve_sats",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.per_channel_reserve_sats.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_get_trusted_peers_no_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        >,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_auto_accessor_get_trusted_peers_no_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.trusted_peers_no_reserve.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_set_per_channel_reserve_sats_impl(
    that: impl CstDecode<
        RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        >,
    >,
    per_channel_reserve_sats: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_auto_accessor_set_per_channel_reserve_sats",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_per_channel_reserve_sats = per_channel_reserve_sats.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.per_channel_reserve_sats = api_per_channel_reserve_sats;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_set_trusted_peers_no_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        >,
    >,
    trusted_peers_no_reserve: impl CstDecode<Vec<PublicKey>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_auto_accessor_set_trusted_peers_no_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_trusted_peers_no_reserve = trusted_peers_no_reserve.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.trusted_peers_no_reserve = api_trusted_peers_no_reserve;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_conservative_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_conservative",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::AnchorChannelsConfig::conservative(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::AnchorChannelsConfig::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_is_peer_trusted_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        >,
    >,
    peer: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_is_peer_trusted",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_peer = peer.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let mut api_peer_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_peer, 1, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            1 => api_peer_guard = Some(api_peer.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let api_peer_guard = api_peer_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::AnchorChannelsConfig::is_peer_trusted(
                            &*api_that_guard,
                            &*api_peer_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_low_reserve_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_low_reserve",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::AnchorChannelsConfig::low_reserve(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    trusted_peers_no_reserve: impl CstDecode<Vec<PublicKey>>,
    per_channel_reserve_sats: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_trusted_peers_no_reserve = trusted_peers_no_reserve.cst_decode();
            let api_per_channel_reserve_sats = per_channel_reserve_sats.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::AnchorChannelsConfig::new(
                            api_trusted_peers_no_reserve,
                            api_per_channel_reserve_sats,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_remove_trusted_peer_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        >,
    >,
    peer: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_remove_trusted_peer",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_peer = peer.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let mut api_peer_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_peer, 1, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            1 => api_peer_guard = Some(api_peer.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let api_peer_guard = api_peer_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok({
                        ldk_adapter::types::AnchorChannelsConfig::remove_trusted_peer(
                            &mut *api_that_guard,
                            &*api_peer_guard,
                        );
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_trusted_peers_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        >,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_trusted_peers_count",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::AnchorChannelsConfig::trusted_peers_count(
                            &*api_that_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__AnchorChannelsConfig_with_trusted_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    trusted_peers: impl CstDecode<Vec<PublicKey>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "AnchorChannelsConfig_with_trusted_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_trusted_peers = trusted_peers.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::AnchorChannelsConfig::with_trusted_peers(
                            api_trusted_peers,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_as_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_as_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::BitcoinAddress::as_string(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_auto_accessor_get_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_auto_accessor_get_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inner.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__BitcoinAddress_auto_accessor_set_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
    inner: impl CstDecode<BitcoinAddressInner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_auto_accessor_set_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inner = inner.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inner = api_inner;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__BitcoinAddress_from_script_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    script: impl CstDecode<shared::ScriptBuf>,
    network: impl CstDecode<shared::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_from_script",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_script = script.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            shared::BitcoinAddress::from_script(api_script, api_network)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__BitcoinAddress_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    address: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::BitcoinAddress::from_string(api_address)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__BitcoinAddress_is_valid_for_network_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
    network: impl CstDecode<shared::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_is_valid_for_network",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        shared::BitcoinAddress::is_valid_for_network(&*api_that_guard, api_network),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_new_impl(
    address: impl CstDecode<String>,
    network: impl CstDecode<shared::Network>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_address = address.cst_decode();
            let api_network = network.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = shared::BitcoinAddress::new(api_address, api_network)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__shared__BitcoinAddress_script_pubkey_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_script_pubkey",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(shared::BitcoinAddress::script_pubkey(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_to_address_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_to_address_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(shared::BitcoinAddress::to_address_data(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_to_qr_uri_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_to_qr_uri",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::BitcoinAddress::to_qr_uri(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_claim_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    payment_hash: impl CstDecode<shared::PaymentHash>,
    claimable_amount_msat: impl CstDecode<u64>,
    preimage: impl CstDecode<shared::PaymentPreimage>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_claim_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            let api_claimable_amount_msat = claimable_amount_msat.cst_decode();
            let api_preimage = preimage.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::claim_for_hash(
                            &*api_that_guard,
                            api_payment_hash,
                            api_claimable_amount_msat,
                            api_preimage,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_fail_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    payment_hash: impl CstDecode<shared::PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_fail_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::fail_for_hash(
                            &*api_that_guard,
                            api_payment_hash,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::receive(
                            &*api_that_guard,
                            api_amount_msat,
                            api_description,
                            api_expiry_secs,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    payment_hash: impl CstDecode<shared::PaymentHash>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::receive_for_hash(
                            &*api_that_guard,
                            api_payment_hash,
                            api_amount_msat,
                            api_description,
                            api_expiry_secs,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::receive_variable_amount(
                                &*api_that_guard,
                                api_description,
                                api_expiry_secs,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    payment_hash: impl CstDecode<shared::PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_variable_amount_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::receive_variable_amount_for_hash(
                                &*api_that_guard,
                                api_description,
                                api_expiry_secs,
                                api_payment_hash,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_proportional_lsp_fee_limit_ppm_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Bolt11Payment_receive_variable_amount_via_jit_channel", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_description = description.cst_decode();let api_expiry_secs = expiry_secs.cst_decode();let api_max_proportional_lsp_fee_limit_ppm_msat = max_proportional_lsp_fee_limit_ppm_msat.cst_decode(); move |context|  {
                    transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = ldk_adapter::bolt11::Bolt11Payment::receive_variable_amount_via_jit_channel(&*api_that_guard, api_description, api_expiry_secs, api_max_proportional_lsp_fee_limit_ppm_msat)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_total_lsp_fee_limit_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_via_jit_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_max_total_lsp_fee_limit_msat = max_total_lsp_fee_limit_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::receive_via_jit_channel(
                                &*api_that_guard,
                                api_amount_msat,
                                api_description,
                                api_expiry_secs,
                                api_max_total_lsp_fee_limit_msat,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<shared::Bolt11Invoice>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::send(
                            &*api_that_guard,
                            api_invoice,
                            api_sending_parameters,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<shared::Bolt11Invoice>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::send_probes(
                            &*api_that_guard,
                            api_invoice,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<shared::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send_probes_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::send_probes_using_amount(
                                &*api_that_guard,
                                api_invoice,
                                api_amount_msat,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<shared::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::send_using_amount(
                            &*api_that_guard,
                            api_invoice,
                            api_amount_msat,
                            api_sending_parameters,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_initiate_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    expiry_secs: impl CstDecode<u32>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_initiate_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::initiate_refund(
                            &*api_that_guard,
                            api_amount_msat,
                            api_expiry_secs,
                            api_quantity,
                            api_payer_note,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<Option<u32>>,
    quantity: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_quantity = quantity.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::receive(
                            &*api_that_guard,
                            api_amount_msat,
                            api_description,
                            api_expiry_secs,
                            api_quantity,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt12::Bolt12Payment::receive_variable_amount(
                                &*api_that_guard,
                                api_description,
                                api_expiry_secs,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_request_refund_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    refund: impl CstDecode<shared::Refund>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_request_refund_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_refund = refund.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::request_refund_payment(
                            &*api_that_guard,
                            api_refund,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    offer: impl CstDecode<shared::Offer>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offer = offer.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::send(
                            &*api_that_guard,
                            api_offer,
                            api_quantity,
                            api_payer_note,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    offer: impl CstDecode<shared::Offer>,
    amount_msat: impl CstDecode<u64>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offer = offer.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::send_using_amount(
                            &*api_that_guard,
                            api_offer,
                            api_amount_msat,
                            api_quantity,
                            api_payer_note,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_accept_underpaying_htlcs_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_accept_underpaying_htlcs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.accept_underpaying_htlcs.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.cltv_expiry_delta.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .force_close_avoidance_max_fee_satoshis
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_forwarding_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.forwarding_fee_base_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .forwarding_fee_proportional_millionths
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_max_dust_htlc_exposure_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_max_dust_htlc_exposure",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.max_dust_htlc_exposure.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_accept_underpaying_htlcs_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    accept_underpaying_htlcs: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_accept_underpaying_htlcs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_accept_underpaying_htlcs = accept_underpaying_htlcs.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.accept_underpaying_htlcs = api_accept_underpaying_htlcs;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    cltv_expiry_delta: impl CstDecode<u16>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_cltv_expiry_delta = cltv_expiry_delta.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.cltv_expiry_delta = api_cltv_expiry_delta;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    force_close_avoidance_max_fee_satoshis: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_force_close_avoidance_max_fee_satoshis =
                force_close_avoidance_max_fee_satoshis.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.force_close_avoidance_max_fee_satoshis =
                            api_force_close_avoidance_max_fee_satoshis;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    forwarding_fee_base_msat: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_forwarding_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_forwarding_fee_base_msat = forwarding_fee_base_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.forwarding_fee_base_msat = api_forwarding_fee_base_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    forwarding_fee_proportional_millionths: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_forwarding_fee_proportional_millionths =
                forwarding_fee_proportional_millionths.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.forwarding_fee_proportional_millionths =
                            api_forwarding_fee_proportional_millionths;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_max_dust_htlc_exposure_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    max_dust_htlc_exposure: impl CstDecode<MaxDustHTLCExposure>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_max_dust_htlc_exposure",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_max_dust_htlc_exposure = max_dust_htlc_exposure.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.max_dust_htlc_exposure = api_max_dust_htlc_exposure;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_calculate_forwarding_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_calculate_forwarding_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::ChannelConfig::calculate_forwarding_fee(
                            &*api_that_guard,
                            api_amount_msat,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_high_fee_routing_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_high_fee_routing",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelConfig::high_fee_routing())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_low_fee_routing_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_low_fee_routing",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelConfig::low_fee_routing())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    forwarding_fee_proportional_millionths: impl CstDecode<u32>,
    forwarding_fee_base_msat: impl CstDecode<u32>,
    cltv_expiry_delta: impl CstDecode<u16>,
    max_dust_htlc_exposure: impl CstDecode<MaxDustHTLCExposure>,
    force_close_avoidance_max_fee_satoshis: impl CstDecode<u64>,
    accept_underpaying_htlcs: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_forwarding_fee_proportional_millionths =
                forwarding_fee_proportional_millionths.cst_decode();
            let api_forwarding_fee_base_msat = forwarding_fee_base_msat.cst_decode();
            let api_cltv_expiry_delta = cltv_expiry_delta.cst_decode();
            let api_max_dust_htlc_exposure = max_dust_htlc_exposure.cst_decode();
            let api_force_close_avoidance_max_fee_satoshis =
                force_close_avoidance_max_fee_satoshis.cst_decode();
            let api_accept_underpaying_htlcs = accept_underpaying_htlcs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::ChannelConfig::new(
                        api_forwarding_fee_proportional_millionths,
                        api_forwarding_fee_base_msat,
                        api_cltv_expiry_delta,
                        api_max_dust_htlc_exposure,
                        api_force_close_avoidance_max_fee_satoshis,
                        api_accept_underpaying_htlcs,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.channel_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_value_sats_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_channel_value_sats",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.channel_value_sats.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.cltv_expiry_delta.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_config_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_config",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.config.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_confirmations",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.confirmations.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_required_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_confirmations_required",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.confirmations_required.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_forwarding_info_cltv_expiry_delta
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_forwarding_info_fee_base_msat
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { let api_that = that.cst_decode();
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(api_that_guard.counterparty_forwarding_info_fee_proportional_millionths.clone())?;   Ok(output_ok)
                })()) })
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_counterparty_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.counterparty_node_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_outbound_htlc_maximum_msat
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_outbound_htlc_minimum_msat
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_unspendable_punishment_reserve
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.feerate_sat_per_1000_weight.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_force_close_spend_delay_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_force_close_spend_delay",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.force_close_spend_delay.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_funding_txo_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_funding_txo",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.funding_txo.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_inbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inbound_capacity_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.inbound_htlc_maximum_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.inbound_htlc_minimum_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_channel_ready_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_is_channel_ready",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_channel_ready.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_outbound_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_is_outbound",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_outbound.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_usable_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_is_usable",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_usable.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.next_outbound_htlc_limit_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.next_outbound_htlc_minimum_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_outbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_outbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.outbound_capacity_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.unspendable_punishment_reserve.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_user_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_user_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.user_channel_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    channel_id: impl CstDecode<ChannelId>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_channel_id = channel_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.channel_id = api_channel_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_value_sats_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    channel_value_sats: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_channel_value_sats",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_channel_value_sats = channel_value_sats.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.channel_value_sats = api_channel_value_sats;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    cltv_expiry_delta: impl CstDecode<Option<u16>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_cltv_expiry_delta = cltv_expiry_delta.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.cltv_expiry_delta = api_cltv_expiry_delta;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_config_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    config: impl CstDecode<ChannelConfig>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_config",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_config = config.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.config = api_config;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    confirmations: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_confirmations",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_confirmations = confirmations.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.confirmations = api_confirmations;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_required_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    confirmations_required: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_confirmations_required",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_confirmations_required = confirmations_required.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.confirmations_required = api_confirmations_required;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_forwarding_info_cltv_expiry_delta: impl CstDecode<Option<u16>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_forwarding_info_cltv_expiry_delta =
                counterparty_forwarding_info_cltv_expiry_delta.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_forwarding_info_cltv_expiry_delta =
                            api_counterparty_forwarding_info_cltv_expiry_delta;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_forwarding_info_fee_base_msat: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_forwarding_info_fee_base_msat =
                counterparty_forwarding_info_fee_base_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_forwarding_info_fee_base_msat =
                            api_counterparty_forwarding_info_fee_base_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_forwarding_info_fee_proportional_millionths: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { let api_that = that.cst_decode();let api_counterparty_forwarding_info_fee_proportional_millionths = counterparty_forwarding_info_fee_proportional_millionths.cst_decode();
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ { api_that_guard.counterparty_forwarding_info_fee_proportional_millionths = api_counterparty_forwarding_info_fee_proportional_millionths; }; })?;   Ok(output_ok)
                })()) })
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_node_id: impl CstDecode<PublicKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_counterparty_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_node_id = api_counterparty_node_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_outbound_htlc_maximum_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_outbound_htlc_maximum_msat =
                counterparty_outbound_htlc_maximum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_outbound_htlc_maximum_msat =
                            api_counterparty_outbound_htlc_maximum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_outbound_htlc_minimum_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_outbound_htlc_minimum_msat =
                counterparty_outbound_htlc_minimum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_outbound_htlc_minimum_msat =
                            api_counterparty_outbound_htlc_minimum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_unspendable_punishment_reserve: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_unspendable_punishment_reserve =
                counterparty_unspendable_punishment_reserve.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_unspendable_punishment_reserve =
                            api_counterparty_unspendable_punishment_reserve;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    feerate_sat_per_1000_weight: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_feerate_sat_per_1000_weight = feerate_sat_per_1000_weight.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.feerate_sat_per_1000_weight =
                            api_feerate_sat_per_1000_weight;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_force_close_spend_delay_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    force_close_spend_delay: impl CstDecode<Option<u16>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_force_close_spend_delay",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_force_close_spend_delay = force_close_spend_delay.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.force_close_spend_delay = api_force_close_spend_delay;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_funding_txo_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    funding_txo: impl CstDecode<Option<shared::OutPoint>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_funding_txo",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_funding_txo = funding_txo.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.funding_txo = api_funding_txo;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    inbound_capacity_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_inbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inbound_capacity_msat = inbound_capacity_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inbound_capacity_msat = api_inbound_capacity_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    inbound_htlc_maximum_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inbound_htlc_maximum_msat = inbound_htlc_maximum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inbound_htlc_maximum_msat = api_inbound_htlc_maximum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    inbound_htlc_minimum_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inbound_htlc_minimum_msat = inbound_htlc_minimum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inbound_htlc_minimum_msat = api_inbound_htlc_minimum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_channel_ready_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    is_channel_ready: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_is_channel_ready",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_channel_ready = is_channel_ready.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_channel_ready = api_is_channel_ready;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_outbound_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    is_outbound: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_is_outbound",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_outbound = is_outbound.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_outbound = api_is_outbound;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_usable_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    is_usable: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_is_usable",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_usable = is_usable.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_usable = api_is_usable;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    next_outbound_htlc_limit_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_next_outbound_htlc_limit_msat = next_outbound_htlc_limit_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.next_outbound_htlc_limit_msat =
                            api_next_outbound_htlc_limit_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    next_outbound_htlc_minimum_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_next_outbound_htlc_minimum_msat = next_outbound_htlc_minimum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.next_outbound_htlc_minimum_msat =
                            api_next_outbound_htlc_minimum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_outbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    outbound_capacity_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_outbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_outbound_capacity_msat = outbound_capacity_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.outbound_capacity_msat = api_outbound_capacity_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    unspendable_punishment_reserve: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_unspendable_punishment_reserve = unspendable_punishment_reserve.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.unspendable_punishment_reserve =
                            api_unspendable_punishment_reserve;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_user_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    user_channel_id: impl CstDecode<UserChannelId>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_user_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.user_channel_id = api_user_channel_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_balance_ratio_percent_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_balance_ratio_percent",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::ChannelDetails::balance_ratio_percent(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_can_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_can_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelDetails::can_receive(
                            &*api_that_guard,
                            api_amount_msat,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_can_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_can_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelDetails::can_send(
                            &*api_that_guard,
                            api_amount_msat,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_capacity_sats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_capacity_sats",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::ChannelDetails::capacity_sats(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    channel_id: impl CstDecode<ChannelId>,
    counterparty_node_id: impl CstDecode<PublicKey>,
    funding_txo: impl CstDecode<Option<shared::OutPoint>>,
    channel_value_sats: impl CstDecode<u64>,
    unspendable_punishment_reserve: impl CstDecode<Option<u64>>,
    user_channel_id: impl CstDecode<UserChannelId>,
    feerate_sat_per_1000_weight: impl CstDecode<u32>,
    outbound_capacity_msat: impl CstDecode<u64>,
    inbound_capacity_msat: impl CstDecode<u64>,
    is_outbound: impl CstDecode<bool>,
    is_channel_ready: impl CstDecode<bool>,
    is_usable: impl CstDecode<bool>,
    config: impl CstDecode<ChannelConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_channel_id = channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            let api_funding_txo = funding_txo.cst_decode();
            let api_channel_value_sats = channel_value_sats.cst_decode();
            let api_unspendable_punishment_reserve = unspendable_punishment_reserve.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_feerate_sat_per_1000_weight = feerate_sat_per_1000_weight.cst_decode();
            let api_outbound_capacity_msat = outbound_capacity_msat.cst_decode();
            let api_inbound_capacity_msat = inbound_capacity_msat.cst_decode();
            let api_is_outbound = is_outbound.cst_decode();
            let api_is_channel_ready = is_channel_ready.cst_decode();
            let api_is_usable = is_usable.cst_decode();
            let api_config = config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::ChannelDetails::new(
                        api_channel_id,
                        api_counterparty_node_id,
                        api_funding_txo,
                        api_channel_value_sats,
                        api_unspendable_punishment_reserve,
                        api_user_channel_id,
                        api_feerate_sat_per_1000_weight,
                        api_outbound_capacity_msat,
                        api_inbound_capacity_msat,
                        api_is_outbound,
                        api_is_channel_ready,
                        api_is_usable,
                        api_config,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_total_liquidity_msat_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_total_liquidity_msat",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::ChannelDetails::total_liquidity_msat(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelId_as_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelId_as_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok({
                        ldk_adapter::types::ChannelId::as_bytes(&*api_that_guard);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelId_auto_accessor_get_data_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelId_auto_accessor_get_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.data.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelId_auto_accessor_set_data_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>,
    >,
    data: impl CstDecode<[u8; 32]>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelId_auto_accessor_set_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_data = data.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.data = api_data;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelId_from_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelId_from_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_bytes = bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelId::from_bytes(&api_bytes))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelId_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<[u8; 32]>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelId_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelId::new(api_data))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_build_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<LdkBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_build",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::LdkBuilder::build(api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_build_with_fs_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<LdkBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_build_with_fs_store",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            ldk_adapter::builder::LdkBuilder::build_with_fs_store(api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>,
    >,
    vss_url: impl CstDecode<String>,
    store_id: impl CstDecode<String>,
    lnurl_auth_server_url: impl CstDecode<String>,
    fixed_headers: impl CstDecode<std::collections::HashMap<String, String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_build_with_vss_store",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_vss_url = vss_url.cst_decode();
            let api_store_id = store_id.cst_decode();
            let api_lnurl_auth_server_url = lnurl_auth_server_url.cst_decode();
            let api_fixed_headers = fixed_headers.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::builder::LdkBuilder::build_with_vss_store(
                            &*api_that_guard,
                            api_vss_url,
                            api_store_id,
                            api_lnurl_auth_server_url,
                            api_fixed_headers,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store_and_fixed_headers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>,
    >,
    vss_url: impl CstDecode<String>,
    store_id: impl CstDecode<String>,
    fixed_headers: impl CstDecode<std::collections::HashMap<String, String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "LdkBuilder_build_with_vss_store_and_fixed_headers", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_vss_url = vss_url.cst_decode();let api_store_id = store_id.cst_decode();let api_fixed_headers = fixed_headers.cst_decode(); move |context|  {
                    transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = ldk_adapter::builder::LdkBuilder::build_with_vss_store_and_fixed_headers(&*api_that_guard, api_vss_url, api_store_id, api_fixed_headers)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__ldk_adapter__builder__LdkBuilder_create_builder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    config: impl CstDecode<ldk_adapter::types::Config>,
    chain_data_source_config: impl CstDecode<Option<ldk_adapter::types::ChainDataSourceConfig>>,
    entropy_source_config: impl CstDecode<Option<ldk_adapter::types::EntropySourceConfig>>,
    gossip_source_config: impl CstDecode<Option<ldk_adapter::types::GossipSourceConfig>>,
    liquidity_source_config: impl CstDecode<Option<ldk_adapter::types::LiquiditySourceConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_create_builder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_config = config.cst_decode();
            let api_chain_data_source_config = chain_data_source_config.cst_decode();
            let api_entropy_source_config = entropy_source_config.cst_decode();
            let api_gossip_source_config = gossip_source_config.cst_decode();
            let api_liquidity_source_config = liquidity_source_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::LdkBuilder::create_builder(
                            api_config,
                            api_chain_data_source_config,
                            api_entropy_source_config,
                            api_gossip_source_config,
                            api_liquidity_source_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_set_entropy_seed_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<LdkBuilder>,
    seed_bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_set_entropy_seed_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_seed_bytes = seed_bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::LdkBuilder::set_entropy_seed_bytes(
                            api_that,
                            api_seed_bytes,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_set_filesystem_logger_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<LdkBuilder>,
    log_file_path: impl CstDecode<Option<String>>,
    max_log_level: impl CstDecode<Option<ldk_adapter::types::LogLevel>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_set_filesystem_logger",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_log_file_path = log_file_path.cst_decode();
            let api_max_log_level = max_log_level.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::LdkBuilder::set_filesystem_logger(
                            api_that,
                            api_log_file_path,
                            api_max_log_level,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_set_log_facade_logger_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<LdkBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_set_log_facade_logger",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            ldk_adapter::builder::LdkBuilder::set_log_facade_logger(api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__MaxDustHtlcExposure_conservative_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MaxDustHtlcExposure_conservative",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::MaxDustHTLCExposure::conservative(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__MaxDustHtlcExposure_default_fee_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MaxDustHtlcExposure_default_fee_rate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::MaxDustHTLCExposure::default_fee_rate(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__MaxDustHtlcExposure_new_fee_rate_multiplier_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    multiplier: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MaxDustHtlcExposure_new_fee_rate_multiplier",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_multiplier = multiplier.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::MaxDustHTLCExposure::new_fee_rate_multiplier(
                            api_multiplier,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__MaxDustHtlcExposure_new_fixed_limit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    limit_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MaxDustHtlcExposure_new_fixed_limit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_limit_msat = limit_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::MaxDustHTLCExposure::new_fixed_limit(api_limit_msat),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
    short_channel_id: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_short_channel_id = short_channel_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::graph::NetworkGraph::channel(
                            &*api_that_guard,
                            api_short_channel_id,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::graph::NetworkGraph::list_channels(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_list_nodes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_list_nodes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::graph::NetworkGraph::list_nodes(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
    node_id: impl CstDecode<ldk_adapter::graph::NodeId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::graph::NetworkGraph::node(&*api_that_guard, api_node_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_bolt11_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_bolt11_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::bolt11_payment(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_bolt12_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_bolt12_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::bolt12_payment(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    user_channel_id: impl CstDecode<UserChannelId>,
    counterparty_node_id: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::close_channel(
                            &*api_that_guard,
                            api_user_channel_id,
                            api_counterparty_node_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::config(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_connect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    node_id: impl CstDecode<PublicKey>,
    address: impl CstDecode<SocketAddress>,
    persist: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_connect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            let api_persist = persist.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::connect(
                            &*api_that_guard,
                            api_node_id,
                            api_address,
                            api_persist,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_disconnect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    counterparty_node_id: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_disconnect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::disconnect(
                            &*api_that_guard,
                            api_counterparty_node_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_event_handled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_event_handled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::event_handled(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_export_pathfinding_scores_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_export_pathfinding_scores",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::node::Node::export_pathfinding_scores(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_force_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    user_channel_id: impl CstDecode<UserChannelId>,
    counterparty_node_id: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_force_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::force_close_channel(
                            &*api_that_guard,
                            api_user_channel_id,
                            api_counterparty_node_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::list_balances(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::list_channels(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_payments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_payments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::list_payments(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_payments_with_filter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    payment_direction: impl CstDecode<ldk_adapter::types::PaymentDirection>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_payments_with_filter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_direction = payment_direction.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::list_payments_with_filter(
                            &*api_that_guard,
                            api_payment_direction,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::list_peers(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_listening_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_listening_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::node::Node::listening_addresses(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_network_graph_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_network_graph",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::network_graph(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::next_event(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_next_event_async_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_next_event_async",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            ldk_adapter::node::Node::next_event_async(&*api_that_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_node_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_node_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::node_id(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_on_chain_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_on_chain_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::node::Node::on_chain_payment(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_open_announced_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    socket_address: impl CstDecode<SocketAddress>,
    node_id: impl CstDecode<PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    channel_config: impl CstDecode<Option<ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_open_announced_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_socket_address = socket_address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::open_announced_channel(
                            &*api_that_guard,
                            api_socket_address,
                            api_node_id,
                            api_channel_amount_sats,
                            api_push_to_counterparty_msat,
                            api_channel_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_open_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    socket_address: impl CstDecode<SocketAddress>,
    node_id: impl CstDecode<PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    channel_config: impl CstDecode<Option<ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_open_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_socket_address = socket_address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::open_channel(
                            &*api_that_guard,
                            api_socket_address,
                            api_node_id,
                            api_channel_amount_sats,
                            api_push_to_counterparty_msat,
                            api_channel_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    payment_id: impl CstDecode<shared::PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::payment(
                        &*api_that_guard,
                        api_payment_id,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_remove_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    payment_id: impl CstDecode<shared::PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_remove_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::remove_payment(
                            &*api_that_guard,
                            api_payment_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_sign_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    msg: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_sign_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::sign_message(
                        &*api_that_guard,
                        api_msg,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_spontaneous_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_spontaneous_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::node::Node::spontaneous_payment(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::start(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::status(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_stop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_stop",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::stop(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_sync_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_sync_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::sync_wallets(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_unified_qr_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_unified_qr_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::node::Node::unified_qr_payment(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_update_channel_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    user_channel_id: impl CstDecode<UserChannelId>,
    counterparty_node_id: impl CstDecode<PublicKey>,
    channel_config: impl CstDecode<ChannelConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_update_channel_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::update_channel_config(
                            &*api_that_guard,
                            api_user_channel_id,
                            api_counterparty_node_id,
                            api_channel_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_verify_signature_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    msg: impl CstDecode<Vec<u8>>,
    sig: impl CstDecode<String>,
    public_key: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_verify_signature",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            let api_sig = sig.cst_decode();
            let api_public_key = public_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::verify_signature(
                            &*api_that_guard,
                            api_msg,
                            api_sig,
                            api_public_key,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_wait_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_wait_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::wait_next_event(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__on_chain__OnChainPayment_new_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnChainPayment_new_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::on_chain::OnChainPayment::new_address(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__on_chain__OnChainPayment_send_all_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
    >,
    address: impl CstDecode<BitcoinAddress>,
    retain_reserves: impl CstDecode<bool>,
    fee_rate_sat_per_kwu: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnChainPayment_send_all_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_retain_reserves = retain_reserves.cst_decode();
            let api_fee_rate_sat_per_kwu = fee_rate_sat_per_kwu.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::on_chain::OnChainPayment::send_all_to_address(
                            &*api_that_guard,
                            api_address,
                            api_retain_reserves,
                            api_fee_rate_sat_per_kwu,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__on_chain__OnChainPayment_send_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
    >,
    address: impl CstDecode<BitcoinAddress>,
    amount_sats: impl CstDecode<u64>,
    fee_rate_sat_per_kwu: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnChainPayment_send_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            let api_fee_rate_sat_per_kwu = fee_rate_sat_per_kwu.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::on_chain::OnChainPayment::send_to_address(
                            &*api_that_guard,
                            api_address,
                            api_amount_sats,
                            api_fee_rate_sat_per_kwu,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_get_address_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_get_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.address.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_get_is_connected_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_get_is_connected",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_connected.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_get_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_get_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.node_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_set_address_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
    address: impl CstDecode<SocketAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_set_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.address = api_address;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_set_is_connected_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
    is_connected: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_set_is_connected",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_connected = is_connected.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_connected = api_is_connected;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_set_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
    node_id: impl CstDecode<PublicKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_set_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.node_id = api_node_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_is_offline_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_is_offline",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PeerDetails::is_offline(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_is_online_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_is_online",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PeerDetails::is_online(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    node_id: impl CstDecode<PublicKey>,
    address: impl CstDecode<SocketAddress>,
    is_connected: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            let api_is_connected = is_connected.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::PeerDetails::new(
                        api_node_id,
                        api_address,
                        api_is_connected,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_new_connected_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    node_id: impl CstDecode<PublicKey>,
    address: impl CstDecode<SocketAddress>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_new_connected",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PeerDetails::new_connected(api_node_id, api_address),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_new_disconnected_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    node_id: impl CstDecode<PublicKey>,
    address: impl CstDecode<SocketAddress>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_new_disconnected",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PeerDetails::new_disconnected(api_node_id, api_address),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__PublicKey_auto_accessor_get_hex_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PublicKey_auto_accessor_get_hex",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.hex.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__PublicKey_auto_accessor_set_hex_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
    >,
    hex: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PublicKey_auto_accessor_set_hex",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_hex = hex.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.hex = api_hex;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__PublicKey_new_impl(
    hex: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PublicKey_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_hex = hex.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(shared::PublicKey::new(api_hex))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__SocketAddress_addr_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_addr",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::SocketAddress::addr(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__SocketAddress_hostname_impl(
    addr: impl CstDecode<String>,
    port: impl CstDecode<u16>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_hostname",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_addr = addr.cst_decode();
            let api_port = port.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(shared::SocketAddress::hostname(api_addr, api_port))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__SocketAddress_port_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_port",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::SocketAddress::port(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__spontaneous__SpontaneousPayment_send_probes_unsafe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SpontaneousPayment_send_probes_unsafe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::spontaneous::SpontaneousPayment::send_probes_unsafe(
                                &*api_that_guard,
                                api_amount_msat,
                                api_node_id,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__spontaneous__SpontaneousPayment_send_unsafe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<PublicKey>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SpontaneousPayment_send_unsafe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::spontaneous::SpontaneousPayment::send_unsafe(
                            &*api_that_guard,
                            api_amount_msat,
                            api_node_id,
                            api_sending_parameters,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__spontaneous__SpontaneousPayment_send_with_custom_tlvs_unsafe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<PublicKey>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
    custom_tlvs: impl CstDecode<Vec<ldk_adapter::types::CustomTlvRecord>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SpontaneousPayment_send_with_custom_tlvs_unsafe", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_amount_msat = amount_msat.cst_decode();let api_node_id = node_id.cst_decode();let api_sending_parameters = sending_parameters.cst_decode();let api_custom_tlvs = custom_tlvs.cst_decode(); move |context|  {
                    transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = ldk_adapter::spontaneous::SpontaneousPayment::send_with_custom_tlvs_unsafe(&*api_that_guard, api_amount_msat, api_node_id, api_sending_parameters, api_custom_tlvs)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__shared__TaprootSpendInfo_auto_accessor_get_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TaprootSpendInfo_auto_accessor_get_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inner.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__TaprootSpendInfo_auto_accessor_set_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>,
    >,
    inner: impl CstDecode<TaprootSpendInfoInner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TaprootSpendInfo_auto_accessor_set_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inner = inner.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inner = api_inner;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__Transaction_auto_accessor_get_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_auto_accessor_get_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inner.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__Transaction_auto_accessor_set_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
    inner: impl CstDecode<BitcoinTransactionInner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_auto_accessor_set_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inner = inner.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inner = api_inner;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__Transaction_compute_txid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_compute_txid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::compute_txid(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_compute_wtxid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_compute_wtxid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::compute_wtxid(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_input_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_input",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::input(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_is_coinbase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_is_coinbase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::is_coinbase(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_is_explicitly_rbf_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_is_explicitly_rbf",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(shared::Transaction::is_explicitly_rbf(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_is_lock_time_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_is_lock_time_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        shared::Transaction::is_lock_time_enabled(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_lock_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_lock_time",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::lock_time(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_new_impl(
    transaction_bytes: impl CstDecode<Vec<u8>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_transaction_bytes = transaction_bytes.cst_decode();
            transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = shared::Transaction::new(api_transaction_bytes)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__shared__Transaction_output_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_output",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::output(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_total_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_total_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::total_size(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_version_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_version",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::version(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_vsize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_vsize",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::vsize(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_weight_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_weight",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::weight(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__unified_qr__UnifiedQrPayment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>,
    >,
    amount_sats: impl CstDecode<u64>,
    message: impl CstDecode<String>,
    expiry_sec: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UnifiedQrPayment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            let api_message = message.cst_decode();
            let api_expiry_sec = expiry_sec.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::unified_qr::UnifiedQrPayment::receive(
                            &*api_that_guard,
                            api_amount_sats,
                            api_message,
                            api_expiry_sec,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__unified_qr__UnifiedQrPayment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>,
    >,
    uri_str: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UnifiedQrPayment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_uri_str = uri_str.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::unified_qr::UnifiedQrPayment::send(
                            &*api_that_guard,
                            api_uri_str,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_as_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_as_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok({
                        ldk_adapter::types::UserChannelId::as_bytes(&*api_that_guard);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_auto_accessor_get_data_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_auto_accessor_get_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.data.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_auto_accessor_set_data_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>,
    >,
    data: impl CstDecode<Vec<u8>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_auto_accessor_set_data",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_data = data.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.data = api_data;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    s: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_s = s.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::UserChannelId::from_string(&api_s),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_from_u64_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_from_u64",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::UserChannelId::from_u64(api_id))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_new_impl(
    data: impl CstDecode<Vec<u8>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_data = data.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(ldk_adapter::types::UserChannelId::new(api_data))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::Config::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__custom_tlv_record_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    type_num: impl CstDecode<u64>,
    value: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "custom_tlv_record_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_type_num = type_num.cst_decode();
            let api_value = value.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::CustomTlvRecord::from_string(api_type_num, &api_value),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__custom_tlv_record_from_u64_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    type_num: impl CstDecode<u64>,
    value: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "custom_tlv_record_from_u64",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_type_num = type_num.cst_decode();
            let api_value = value.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::CustomTlvRecord::from_u64(api_type_num, api_value),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__custom_tlv_record_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    type_num: impl CstDecode<u64>,
    value: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "custom_tlv_record_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_type_num = type_num.cst_decode();
            let api_value = value.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::CustomTlvRecord::new(
                        api_type_num,
                        api_value,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__custom_tlv_record_value_as_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::CustomTlvRecord>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "custom_tlv_record_value_as_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::CustomTlvRecord::value_as_string(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_debug_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_debug",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::debug(
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_error_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_error",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::error(
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_formatted_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::FfiLogRecord>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_formatted",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::FfiLogRecord::formatted(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::info(
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_is_error_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::FfiLogRecord>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_is_error",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::is_error(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_is_warn_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::FfiLogRecord>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_is_warn",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::is_warn(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    level: impl CstDecode<ldk_adapter::types::LogLevel>,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_level = level.cst_decode();
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::new(
                        api_level,
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_trace_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_trace",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::trace(
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_warn_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_warn",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::warn(
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__lsp_fee_limits_conservative_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lsp_fee_limits_conservative",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::LSPFeeLimits::conservative())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__lsp_fee_limits_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    max_total_opening_fee_msat: impl CstDecode<Option<u64>>,
    max_proportional_opening_fee_ppm_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lsp_fee_limits_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_max_total_opening_fee_msat = max_total_opening_fee_msat.cst_decode();
            let api_max_proportional_opening_fee_ppm_msat =
                max_proportional_opening_fee_ppm_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::LSPFeeLimits::new(
                        api_max_total_opening_fee_msat,
                        api_max_proportional_opening_fee_ppm_msat,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__lsp_fee_limits_permissive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lsp_fee_limits_permissive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::LSPFeeLimits::permissive())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__lsp_fee_limits_unlimited_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lsp_fee_limits_unlimited",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::LSPFeeLimits::unlimited())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__mnemonic_as_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Mnemonic>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_as_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(shared::Mnemonic::as_string(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__mnemonic_from_entropy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    entropy: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_from_entropy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_entropy = entropy.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Mnemonic::from_entropy(&api_entropy)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__mnemonic_from_seed_phrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    seed_phrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_from_seed_phrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_seed_phrase = seed_phrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Mnemonic::from_seed_phrase(&api_seed_phrase)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__mnemonic_generate_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(shared::Mnemonic::generate())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__mnemonic_to_seed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Mnemonic>,
    passphrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_to_seed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Mnemonic::to_seed(&api_that, &api_passphrase))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__offer_id_as_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::OfferId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "offer_id_as_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        ldk_adapter::types::OfferId::as_bytes(&api_that);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__offer_id_from_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "offer_id_from_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_bytes = bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::OfferId::from_bytes(&api_bytes))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__offer_id_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<[u8; 32]>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "offer_id_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::OfferId::new(api_data))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_details_is_failed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::PaymentDetails>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_details_is_failed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentDetails::is_failed(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_details_is_pending_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::PaymentDetails>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_details_is_pending",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentDetails::is_pending(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_details_is_succeeded_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::PaymentDetails>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_details_is_succeeded",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentDetails::is_succeeded(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_details_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<shared::PaymentId>,
    kind: impl CstDecode<ldk_adapter::types::PaymentKind>,
    amount_msat: impl CstDecode<Option<u64>>,
    direction: impl CstDecode<ldk_adapter::types::PaymentDirection>,
    status: impl CstDecode<ldk_adapter::types::PaymentStatus>,
    latest_update_timestamp: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_details_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_direction = direction.cst_decode();
            let api_status = status.cst_decode();
            let api_latest_update_timestamp = latest_update_timestamp.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::PaymentDetails::new(
                        api_id,
                        api_kind,
                        api_amount_msat,
                        api_direction,
                        api_status,
                        api_latest_update_timestamp,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_details_new_inbound_pending_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<shared::PaymentId>,
    kind: impl CstDecode<ldk_adapter::types::PaymentKind>,
    amount_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_details_new_inbound_pending",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentDetails::new_inbound_pending(
                            api_id,
                            api_kind,
                            api_amount_msat,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_details_new_outbound_pending_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<shared::PaymentId>,
    kind: impl CstDecode<ldk_adapter::types::PaymentKind>,
    amount_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_details_new_outbound_pending",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentDetails::new_outbound_pending(
                            api_id,
                            api_kind,
                            api_amount_msat,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_secret_as_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::PaymentSecret>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_secret_as_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        ldk_adapter::types::PaymentSecret::as_bytes(&api_that);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_secret_from_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_secret_from_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_bytes = bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentSecret::from_bytes(&api_bytes),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_secret_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<[u8; 32]>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_secret_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::PaymentSecret::new(api_data))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__psbt_extract_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Psbt>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "psbt_extract_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Psbt::extract_tx(&api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__psbt_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Psbt>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "psbt_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Psbt::fee(&api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__psbt_from_base64_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    base64: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "psbt_from_base64",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_base64 = base64.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Psbt::from_base64(api_base64)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    {
        let BackgroundSyncConfig = None::<ldk_adapter::types::BackgroundSyncConfig>.unwrap();
        let _: u64 = BackgroundSyncConfig.onchain_wallet_sync_interval_secs;
        let _: u64 = BackgroundSyncConfig.lightning_wallet_sync_interval_secs;
        let _: u64 = BackgroundSyncConfig.fee_rate_cache_update_interval_secs;
    }
    {
        let BalanceDetails = None::<ldk_adapter::types::BalanceDetails>.unwrap();
        let _: u64 = BalanceDetails.total_onchain_balance_sats;
        let _: u64 = BalanceDetails.spendable_onchain_balance_sats;
        let _: u64 = BalanceDetails.total_lightning_balance_sats;
        let _: Vec<ldk_adapter::types::LightningBalance> = BalanceDetails.lightning_balances;
        let _: Vec<ldk_adapter::types::PendingSweepBalance> =
            BalanceDetails.pending_balances_from_channel_closures;
    }
    {
        let BestBlock = None::<ldk_adapter::types::BestBlock>.unwrap();
        let _: String = BestBlock.block_hash;
        let _: u32 = BestBlock.height;
    }
    {
        let Bolt11Invoice = None::<shared::Bolt11Invoice>.unwrap();
        let _: String = Bolt11Invoice.signed_raw_invoice;
    }
    {
        let Bolt12Invoice = None::<shared::Bolt12Invoice>.unwrap();
        let _: Vec<u8> = Bolt12Invoice.data;
    }
    match None::<ldk_adapter::types::ChainDataSourceConfig>.unwrap() {
        ldk_adapter::types::ChainDataSourceConfig::Esplora {
            server_url,
            sync_config,
        } => {
            let _: String = server_url;
            let _: Option<ldk_adapter::types::EsploraSyncConfig> = sync_config;
        }
        ldk_adapter::types::ChainDataSourceConfig::Electrum {
            server_url,
            sync_config,
        } => {
            let _: String = server_url;
            let _: Option<ldk_adapter::types::ElectrumSyncConfig> = sync_config;
        }
        ldk_adapter::types::ChainDataSourceConfig::BitcoindRpc {
            rpc_host,
            rpc_port,
            rpc_user,
            rpc_password,
        } => {
            let _: String = rpc_host;
            let _: u16 = rpc_port;
            let _: String = rpc_user;
            let _: String = rpc_password;
        }
    }
    {
        let ChannelInfo = None::<ldk_adapter::graph::ChannelInfo>.unwrap();
        let _: ldk_adapter::graph::NodeId = ChannelInfo.node_one;
        let _: Option<ldk_adapter::graph::ChannelUpdateInfo> = ChannelInfo.one_to_two;
        let _: ldk_adapter::graph::NodeId = ChannelInfo.node_two;
        let _: Option<ldk_adapter::graph::ChannelUpdateInfo> = ChannelInfo.two_to_one;
        let _: Option<u64> = ChannelInfo.capacity_sats;
    }
    {
        let ChannelUpdateInfo = None::<ldk_adapter::graph::ChannelUpdateInfo>.unwrap();
        let _: u32 = ChannelUpdateInfo.last_update;
        let _: bool = ChannelUpdateInfo.enabled;
        let _: u16 = ChannelUpdateInfo.cltv_expiry_delta;
        let _: u64 = ChannelUpdateInfo.htlc_minimum_msat;
        let _: u64 = ChannelUpdateInfo.htlc_maximum_msat;
        let _: ldk_adapter::graph::RoutingFees = ChannelUpdateInfo.fees;
    }
    match None::<ldk_adapter::types::ClosureReason>.unwrap() {
        ldk_adapter::types::ClosureReason::PeerFeerateTooLow {
            peer_feerate_sat_per_kw,
            required_feerate_sat_per_kw,
        } => {
            let _: u32 = peer_feerate_sat_per_kw;
            let _: u32 = required_feerate_sat_per_kw;
        }
        ldk_adapter::types::ClosureReason::CounterpartyForceClosed { peer_msg } => {
            let _: String = peer_msg;
        }
        ldk_adapter::types::ClosureReason::HolderForceClosed {
            broadcasted_latest_txn,
        } => {
            let _: Option<bool> = broadcasted_latest_txn;
        }
        ldk_adapter::types::ClosureReason::LegacyCooperativeClosure => {}
        ldk_adapter::types::ClosureReason::CounterpartyInitiatedCooperativeClosure => {}
        ldk_adapter::types::ClosureReason::LocallyInitiatedCooperativeClosure => {}
        ldk_adapter::types::ClosureReason::CommitmentTxConfirmed => {}
        ldk_adapter::types::ClosureReason::FundingTimedOut => {}
        ldk_adapter::types::ClosureReason::ProcessingError { err } => {
            let _: String = err;
        }
        ldk_adapter::types::ClosureReason::DisconnectedPeer => {}
        ldk_adapter::types::ClosureReason::OutdatedChannelManager => {}
        ldk_adapter::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel => {}
        ldk_adapter::types::ClosureReason::FundingBatchClosure => {}
        ldk_adapter::types::ClosureReason::HTLCsTimedOut => {}
    }
    {
        let Config = None::<ldk_adapter::types::Config>.unwrap();
        let _: String = Config.storage_dir_path;
        let _: shared::Network = Config.network;
        let _: Option<Vec<SocketAddress>> = Config.listening_addresses;
        let _: Option<Vec<SocketAddress>> = Config.announcement_addresses;
        let _: Option<ldk_adapter::types::NodeAlias> = Config.node_alias;
        let _: Vec<PublicKey> = Config.trusted_peers_0conf;
        let _: u64 = Config.probing_liquidity_limit_multiplier;
        let _: Option<AnchorChannelsConfig> = Config.anchor_channels_config;
        let _: Option<shared::SendingParameters> = Config.sending_parameters;
    }
    {
        let CustomTlvRecord = None::<ldk_adapter::types::CustomTlvRecord>.unwrap();
        let _: u64 = CustomTlvRecord.type_num;
        let _: Vec<u8> = CustomTlvRecord.value;
    }
    {
        let ElectrumSyncConfig = None::<ldk_adapter::types::ElectrumSyncConfig>.unwrap();
        let _: Option<ldk_adapter::types::BackgroundSyncConfig> =
            ElectrumSyncConfig.background_sync_config;
    }
    match None::<ldk_adapter::types::EntropySourceConfig>.unwrap() {
        ldk_adapter::types::EntropySourceConfig::SeedFile(field0) => {
            let _: String = field0;
        }
        ldk_adapter::types::EntropySourceConfig::SeedBytes(field0) => {
            let _: [u8; 64] = field0;
        }
        ldk_adapter::types::EntropySourceConfig::Bip39Mnemonic {
            mnemonic,
            passphrase,
        } => {
            let _: shared::Mnemonic = mnemonic;
            let _: Option<String> = passphrase;
        }
    }
    {
        let EsploraSyncConfig = None::<ldk_adapter::types::EsploraSyncConfig>.unwrap();
        let _: Option<ldk_adapter::types::BackgroundSyncConfig> =
            EsploraSyncConfig.background_sync_config;
    }
    match None::<ldk_adapter::types::Event>.unwrap() {
        ldk_adapter::types::Event::PaymentClaimable {
            payment_id,
            payment_hash,
            claimable_amount_msat,
            claim_deadline,
            custom_records,
        } => {
            let _: shared::PaymentId = payment_id;
            let _: shared::PaymentHash = payment_hash;
            let _: u64 = claimable_amount_msat;
            let _: Option<u32> = claim_deadline;
            let _: Vec<ldk_adapter::types::CustomTlvRecord> = custom_records;
        }
        ldk_adapter::types::Event::PaymentSuccessful {
            payment_id,
            payment_hash,
            fee_paid_msat,
            preimage,
        } => {
            let _: Option<shared::PaymentId> = payment_id;
            let _: shared::PaymentHash = payment_hash;
            let _: Option<u64> = fee_paid_msat;
            let _: Option<shared::PaymentPreimage> = preimage;
        }
        ldk_adapter::types::Event::PaymentFailed {
            payment_id,
            payment_hash,
            reason,
        } => {
            let _: Option<shared::PaymentId> = payment_id;
            let _: Option<shared::PaymentHash> = payment_hash;
            let _: Option<ldk_adapter::types::PaymentFailureReason> = reason;
        }
        ldk_adapter::types::Event::PaymentReceived {
            payment_id,
            payment_hash,
            amount_msat,
            custom_records,
        } => {
            let _: Option<shared::PaymentId> = payment_id;
            let _: shared::PaymentHash = payment_hash;
            let _: u64 = amount_msat;
            let _: Vec<ldk_adapter::types::CustomTlvRecord> = custom_records;
        }
        ldk_adapter::types::Event::ChannelPending {
            channel_id,
            user_channel_id,
            former_temporary_channel_id,
            counterparty_node_id,
            funding_txo,
        } => {
            let _: ChannelId = channel_id;
            let _: UserChannelId = user_channel_id;
            let _: ChannelId = former_temporary_channel_id;
            let _: PublicKey = counterparty_node_id;
            let _: shared::OutPoint = funding_txo;
        }
        ldk_adapter::types::Event::ChannelReady {
            channel_id,
            user_channel_id,
            counterparty_node_id,
        } => {
            let _: ChannelId = channel_id;
            let _: UserChannelId = user_channel_id;
            let _: Option<PublicKey> = counterparty_node_id;
        }
        ldk_adapter::types::Event::ChannelClosed {
            channel_id,
            user_channel_id,
            counterparty_node_id,
            reason,
        } => {
            let _: ChannelId = channel_id;
            let _: UserChannelId = user_channel_id;
            let _: Option<PublicKey> = counterparty_node_id;
            let _: Option<ldk_adapter::types::ClosureReason> = reason;
        }
        ldk_adapter::types::Event::PaymentForwarded {
            prev_channel_id,
            next_channel_id,
            prev_user_channel_id,
            next_user_channel_id,
            prev_node_id,
            next_node_id,
            total_fee_earned_msat,
            skimmed_fee_msat,
            claim_from_onchain_tx,
            outbound_amount_forwarded_msat,
        } => {
            let _: ChannelId = prev_channel_id;
            let _: ChannelId = next_channel_id;
            let _: Option<UserChannelId> = prev_user_channel_id;
            let _: Option<UserChannelId> = next_user_channel_id;
            let _: Option<PublicKey> = prev_node_id;
            let _: Option<PublicKey> = next_node_id;
            let _: Option<u64> = total_fee_earned_msat;
            let _: Option<u64> = skimmed_fee_msat;
            let _: bool = claim_from_onchain_tx;
            let _: Option<u64> = outbound_amount_forwarded_msat;
        }
    }
    {
        let FfiLogRecord = None::<ldk_adapter::types::FfiLogRecord>.unwrap();
        let _: ldk_adapter::types::LogLevel = FfiLogRecord.level;
        let _: String = FfiLogRecord.args;
        let _: String = FfiLogRecord.module_path;
        let _: u32 = FfiLogRecord.line;
    }
    match None::<ldk_adapter::types::GossipSourceConfig>.unwrap() {
        ldk_adapter::types::GossipSourceConfig::P2PNetwork => {}
        ldk_adapter::types::GossipSourceConfig::RapidGossipSync(field0) => {
            let _: String = field0;
        }
    }
    match None::<ldk_adapter::types::LightningBalance>.unwrap() {
        ldk_adapter::types::LightningBalance::ClaimableOnChannelClose {
            channel_id,
            counterparty_node_id,
            amount_satoshis,
            transaction_fee_satoshis,
            outbound_payment_htlc_rounded_msat,
            outbound_forwarded_htlc_rounded_msat,
            inbound_claiming_htlc_rounded_msat,
            inbound_htlc_rounded_msat,
        } => {
            let _: ChannelId = channel_id;
            let _: PublicKey = counterparty_node_id;
            let _: u64 = amount_satoshis;
            let _: u64 = transaction_fee_satoshis;
            let _: u64 = outbound_payment_htlc_rounded_msat;
            let _: u64 = outbound_forwarded_htlc_rounded_msat;
            let _: u64 = inbound_claiming_htlc_rounded_msat;
            let _: u64 = inbound_htlc_rounded_msat;
        }
        ldk_adapter::types::LightningBalance::ClaimableAwaitingConfirmations {
            channel_id,
            counterparty_node_id,
            amount_satoshis,
            confirmation_height,
            source,
        } => {
            let _: ChannelId = channel_id;
            let _: PublicKey = counterparty_node_id;
            let _: u64 = amount_satoshis;
            let _: u32 = confirmation_height;
            let _: ldk_adapter::types::BalanceSource = source;
        }
        ldk_adapter::types::LightningBalance::ContentiousClaimable {
            channel_id,
            counterparty_node_id,
            amount_satoshis,
            timeout_height,
            payment_hash,
            payment_preimage,
        } => {
            let _: ChannelId = channel_id;
            let _: PublicKey = counterparty_node_id;
            let _: u64 = amount_satoshis;
            let _: u32 = timeout_height;
            let _: shared::PaymentHash = payment_hash;
            let _: shared::PaymentPreimage = payment_preimage;
        }
        ldk_adapter::types::LightningBalance::MaybeTimeoutClaimableHTLC {
            channel_id,
            counterparty_node_id,
            amount_satoshis,
            claimable_height,
            payment_hash,
            outbound_payment,
        } => {
            let _: ChannelId = channel_id;
            let _: PublicKey = counterparty_node_id;
            let _: u64 = amount_satoshis;
            let _: u32 = claimable_height;
            let _: shared::PaymentHash = payment_hash;
            let _: bool = outbound_payment;
        }
        ldk_adapter::types::LightningBalance::MaybePreimageClaimableHTLC {
            channel_id,
            counterparty_node_id,
            amount_satoshis,
            expiry_height,
            payment_hash,
        } => {
            let _: ChannelId = channel_id;
            let _: PublicKey = counterparty_node_id;
            let _: u64 = amount_satoshis;
            let _: u32 = expiry_height;
            let _: shared::PaymentHash = payment_hash;
        }
        ldk_adapter::types::LightningBalance::CounterpartyRevokedOutputClaimable {
            channel_id,
            counterparty_node_id,
            amount_satoshis,
        } => {
            let _: ChannelId = channel_id;
            let _: PublicKey = counterparty_node_id;
            let _: u64 = amount_satoshis;
        }
    }
    {
        let LiquiditySourceConfig = None::<ldk_adapter::types::LiquiditySourceConfig>.unwrap();
        let _: (SocketAddress, PublicKey, Option<String>) = LiquiditySourceConfig.lsps2_service;
    }
    {
        let LSPFeeLimits = None::<ldk_adapter::types::LSPFeeLimits>.unwrap();
        let _: Option<u64> = LSPFeeLimits.max_total_opening_fee_msat;
        let _: Option<u64> = LSPFeeLimits.max_proportional_opening_fee_ppm_msat;
    }
    {
        let Mnemonic = None::<shared::Mnemonic>.unwrap();
        let _: Vec<String> = Mnemonic.words;
    }
    {
        let NodeAlias_ = None::<ldk_adapter::types::NodeAlias>.unwrap();
        let _: [u8; 32] = NodeAlias_.0;
    }
    {
        let NodeAnnouncementInfo = None::<ldk_adapter::graph::NodeAnnouncementInfo>.unwrap();
        let _: u32 = NodeAnnouncementInfo.last_update;
        let _: String = NodeAnnouncementInfo.alias;
        let _: Vec<SocketAddress> = NodeAnnouncementInfo.addresses;
    }
    {
        let NodeId = None::<ldk_adapter::graph::NodeId>.unwrap();
        let _: Vec<u8> = NodeId.compressed;
    }
    {
        let NodeInfo = None::<ldk_adapter::graph::NodeInfo>.unwrap();
        let _: Vec<u64> = NodeInfo.channels;
        let _: Option<ldk_adapter::graph::NodeAnnouncementInfo> = NodeInfo.announcement_info;
    }
    {
        let NodeStatus = None::<ldk_adapter::types::NodeStatus>.unwrap();
        let _: bool = NodeStatus.is_running;
        let _: bool = NodeStatus.is_listening;
        let _: ldk_adapter::types::BestBlock = NodeStatus.current_best_block;
        let _: Option<u64> = NodeStatus.latest_lightning_wallet_sync_timestamp;
        let _: Option<u64> = NodeStatus.latest_onchain_wallet_sync_timestamp;
        let _: Option<u64> = NodeStatus.latest_fee_rate_cache_update_timestamp;
        let _: Option<u64> = NodeStatus.latest_rgs_snapshot_timestamp;
        let _: Option<u64> = NodeStatus.latest_node_announcement_broadcast_timestamp;
        let _: Option<u32> = NodeStatus.latest_channel_monitor_archival_height;
    }
    {
        let Offer = None::<shared::Offer>.unwrap();
        let _: String = Offer.s;
    }
    {
        let OfferId_ = None::<ldk_adapter::types::OfferId>.unwrap();
        let _: [u8; 32] = OfferId_.0;
    }
    {
        let OutPoint = None::<shared::OutPoint>.unwrap();
        let _: shared::Txid = OutPoint.txid;
        let _: u32 = OutPoint.vout;
    }
    {
        let PaymentDetails = None::<ldk_adapter::types::PaymentDetails>.unwrap();
        let _: shared::PaymentId = PaymentDetails.id;
        let _: ldk_adapter::types::PaymentKind = PaymentDetails.kind;
        let _: Option<u64> = PaymentDetails.amount_msat;
        let _: ldk_adapter::types::PaymentDirection = PaymentDetails.direction;
        let _: ldk_adapter::types::PaymentStatus = PaymentDetails.status;
        let _: u64 = PaymentDetails.latest_update_timestamp;
    }
    {
        let PaymentHash = None::<shared::PaymentHash>.unwrap();
        let _: [u8; 32] = PaymentHash.data;
    }
    {
        let PaymentId = None::<shared::PaymentId>.unwrap();
        let _: Vec<u8> = PaymentId.data;
    }
    match None::<ldk_adapter::types::PaymentKind>.unwrap() {
        ldk_adapter::types::PaymentKind::Onchain { txid, status } => {
            let _: shared::Txid = txid;
            let _: ConfirmationStatus = status;
        }
        ldk_adapter::types::PaymentKind::Bolt11 {
            hash,
            preimage,
            secret,
        } => {
            let _: shared::PaymentHash = hash;
            let _: Option<shared::PaymentPreimage> = preimage;
            let _: Option<ldk_adapter::types::PaymentSecret> = secret;
        }
        ldk_adapter::types::PaymentKind::Bolt11Jit {
            hash,
            preimage,
            secret,
            lsp_fee_limits,
            counterparty_skimmed_fee_msat,
        } => {
            let _: shared::PaymentHash = hash;
            let _: Option<shared::PaymentPreimage> = preimage;
            let _: Option<ldk_adapter::types::PaymentSecret> = secret;
            let _: ldk_adapter::types::LSPFeeLimits = lsp_fee_limits;
            let _: Option<u64> = counterparty_skimmed_fee_msat;
        }
        ldk_adapter::types::PaymentKind::Spontaneous { hash, preimage } => {
            let _: shared::PaymentHash = hash;
            let _: Option<shared::PaymentPreimage> = preimage;
        }
        ldk_adapter::types::PaymentKind::Bolt12Offer {
            hash,
            preimage,
            secret,
            offer_id,
            payer_note,
            quantity,
        } => {
            let _: Option<shared::PaymentHash> = hash;
            let _: Option<shared::PaymentPreimage> = preimage;
            let _: Option<ldk_adapter::types::PaymentSecret> = secret;
            let _: ldk_adapter::types::OfferId = offer_id;
            let _: Option<String> = payer_note;
            let _: Option<u64> = quantity;
        }
        ldk_adapter::types::PaymentKind::Bolt12Refund {
            hash,
            preimage,
            secret,
            payer_note,
            quantity,
        } => {
            let _: Option<shared::PaymentHash> = hash;
            let _: Option<shared::PaymentPreimage> = preimage;
            let _: Option<ldk_adapter::types::PaymentSecret> = secret;
            let _: Option<String> = payer_note;
            let _: Option<u64> = quantity;
        }
    }
    {
        let PaymentPreimage = None::<shared::PaymentPreimage>.unwrap();
        let _: [u8; 32] = PaymentPreimage.data;
    }
    {
        let PaymentSecret = None::<ldk_adapter::types::PaymentSecret>.unwrap();
        let _: [u8; 32] = PaymentSecret.data;
    }
    match None::<ldk_adapter::types::PendingSweepBalance>.unwrap() {
        ldk_adapter::types::PendingSweepBalance::PendingBroadcast {
            channel_id,
            amount_satoshis,
        } => {
            let _: Option<ChannelId> = channel_id;
            let _: u64 = amount_satoshis;
        }
        ldk_adapter::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
            channel_id,
            latest_broadcast_height,
            latest_spending_txid,
            amount_satoshis,
        } => {
            let _: Option<ChannelId> = channel_id;
            let _: u32 = latest_broadcast_height;
            let _: shared::Txid = latest_spending_txid;
            let _: u64 = amount_satoshis;
        }
        ldk_adapter::types::PendingSweepBalance::AwaitingThresholdConfirmations {
            channel_id,
            latest_spending_txid,
            confirmation_hash,
            confirmation_height,
            amount_satoshis,
        } => {
            let _: Option<ChannelId> = channel_id;
            let _: shared::Txid = latest_spending_txid;
            let _: String = confirmation_hash;
            let _: u32 = confirmation_height;
            let _: u64 = amount_satoshis;
        }
    }
    {
        let Psbt = None::<shared::Psbt>.unwrap();
        let _: String = Psbt.inner;
    }
    {
        let Refund = None::<shared::Refund>.unwrap();
        let _: String = Refund.s;
    }
    {
        let RoutingFees = None::<ldk_adapter::graph::RoutingFees>.unwrap();
        let _: u32 = RoutingFees.base_msat;
        let _: u32 = RoutingFees.proportional_millionths;
    }
    {
        let ScriptBuf = None::<shared::ScriptBuf>.unwrap();
        let _: Vec<u8> = ScriptBuf.inner;
    }
    {
        let SendingParameters = None::<shared::SendingParameters>.unwrap();
        let _: Option<u64> = SendingParameters.max_total_routing_fee_msat;
        let _: Option<u32> = SendingParameters.max_total_cltv_expiry_delta;
        let _: Option<u8> = SendingParameters.max_path_count;
        let _: Option<u8> = SendingParameters.max_channel_saturation_power_of_half;
    }
    {
        let TxIn = None::<shared::TxIn>.unwrap();
        let _: shared::OutPoint = TxIn.previous_output;
        let _: shared::ScriptBuf = TxIn.script_sig;
        let _: u32 = TxIn.sequence;
        let _: Vec<Vec<u8>> = TxIn.witness;
    }
    {
        let TxOut = None::<shared::TxOut>.unwrap();
        let _: u64 = TxOut.value;
        let _: shared::ScriptBuf = TxOut.script_pubkey;
    }
    {
        let Txid = None::<shared::Txid>.unwrap();
        let _: String = Txid.hash;
    }
    {
        let WTxid = None::<shared::WTxid>.unwrap();
        let _: String = WTxid.hash;
    }
    {
        let WitnessProgram = None::<shared::WitnessProgram>.unwrap();
        let _: u8 = WitnessProgram.version;
        let _: Vec<u8> = WitnessProgram.program;
    }
};

// Section: dart2rust

impl CstDecode<ldk_adapter::types::BalanceSource> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::BalanceSource {
        match self {
            0 => ldk_adapter::types::BalanceSource::HolderForceClosed,
            1 => ldk_adapter::types::BalanceSource::CounterpartyForceClosed,
            2 => ldk_adapter::types::BalanceSource::CoopClose,
            3 => ldk_adapter::types::BalanceSource::Htlc,
            _ => unreachable!("Invalid variant for BalanceSource: {}", self),
        }
    }
}
impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<f64> for f64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<ldk_adapter::types::LogLevel> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::LogLevel {
        match self {
            0 => ldk_adapter::types::LogLevel::Gossip,
            1 => ldk_adapter::types::LogLevel::Trace,
            2 => ldk_adapter::types::LogLevel::Debug,
            3 => ldk_adapter::types::LogLevel::Info,
            4 => ldk_adapter::types::LogLevel::Warn,
            5 => ldk_adapter::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", self),
        }
    }
}
impl CstDecode<shared::Network> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> shared::Network {
        match self {
            0 => shared::Network::Bitcoin,
            1 => shared::Network::Testnet,
            2 => shared::Network::Testnet4,
            3 => shared::Network::Signet,
            4 => shared::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}
impl CstDecode<ldk_adapter::types::PaymentDirection> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::PaymentDirection {
        match self {
            0 => ldk_adapter::types::PaymentDirection::Inbound,
            1 => ldk_adapter::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", self),
        }
    }
}
impl CstDecode<ldk_adapter::types::PaymentFailureReason> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::PaymentFailureReason {
        match self {
            0 => ldk_adapter::types::PaymentFailureReason::RecipientRejected,
            1 => ldk_adapter::types::PaymentFailureReason::UserAbandoned,
            2 => ldk_adapter::types::PaymentFailureReason::RetriesExhausted,
            3 => ldk_adapter::types::PaymentFailureReason::PaymentExpired,
            4 => ldk_adapter::types::PaymentFailureReason::RouteNotFound,
            5 => ldk_adapter::types::PaymentFailureReason::UnexpectedError,
            6 => ldk_adapter::types::PaymentFailureReason::UnknownRequiredFeatures,
            7 => ldk_adapter::types::PaymentFailureReason::InvoiceRequestExpired,
            8 => ldk_adapter::types::PaymentFailureReason::InvoiceRequestRejected,
            9 => ldk_adapter::types::PaymentFailureReason::BlindedPathCreationFailed,
            _ => unreachable!("Invalid variant for PaymentFailureReason: {}", self),
        }
    }
}
impl CstDecode<ldk_adapter::types::PaymentStatus> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::PaymentStatus {
        match self {
            0 => ldk_adapter::types::PaymentStatus::Pending,
            1 => ldk_adapter::types::PaymentStatus::Succeeded,
            2 => ldk_adapter::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for AddressData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for AnchorChannelsConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BitcoinAddressInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BitcoinTransactionInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Bolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Bolt12Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ConfirmationStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfirmationStatus>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for LdkBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for NetworkGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Node {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for OnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for QrPaymentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TaprootSpendInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TaprootSpendInfoInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Transaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for UnifiedQrPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfirmationStatus>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for ldk_adapter::types::BackgroundSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_onchainWalletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_lightningWalletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_feeRateCacheUpdateIntervalSecs = <u64>::sse_decode(deserializer);
        return ldk_adapter::types::BackgroundSyncConfig {
            onchain_wallet_sync_interval_secs: var_onchainWalletSyncIntervalSecs,
            lightning_wallet_sync_interval_secs: var_lightningWalletSyncIntervalSecs,
            fee_rate_cache_update_interval_secs: var_feeRateCacheUpdateIntervalSecs,
        };
    }
}

impl SseDecode for ldk_adapter::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_totalOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_spendableOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_totalLightningBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_lightningBalances =
            <Vec<ldk_adapter::types::LightningBalance>>::sse_decode(deserializer);
        let mut var_pendingBalancesFromChannelClosures =
            <Vec<ldk_adapter::types::PendingSweepBalance>>::sse_decode(deserializer);
        return ldk_adapter::types::BalanceDetails {
            total_onchain_balance_sats: var_totalOnchainBalanceSats,
            spendable_onchain_balance_sats: var_spendableOnchainBalanceSats,
            total_lightning_balance_sats: var_totalLightningBalanceSats,
            lightning_balances: var_lightningBalances,
            pending_balances_from_channel_closures: var_pendingBalancesFromChannelClosures,
        };
    }
}

impl SseDecode for ldk_adapter::types::BalanceSource {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::BalanceSource::HolderForceClosed,
            1 => ldk_adapter::types::BalanceSource::CounterpartyForceClosed,
            2 => ldk_adapter::types::BalanceSource::CoopClose,
            3 => ldk_adapter::types::BalanceSource::Htlc,
            _ => unreachable!("Invalid variant for BalanceSource: {}", inner),
        };
    }
}

impl SseDecode for ldk_adapter::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blockHash = <String>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        return ldk_adapter::types::BestBlock {
            block_hash: var_blockHash,
            height: var_height,
        };
    }
}

impl SseDecode for shared::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_signedRawInvoice = <String>::sse_decode(deserializer);
        return shared::Bolt11Invoice {
            signed_raw_invoice: var_signedRawInvoice,
        };
    }
}

impl SseDecode for shared::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return shared::Bolt12Invoice { data: var_data };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for ldk_adapter::types::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_serverUrl = <String>::sse_decode(deserializer);
                let mut var_syncConfig =
                    <Option<ldk_adapter::types::EsploraSyncConfig>>::sse_decode(deserializer);
                return ldk_adapter::types::ChainDataSourceConfig::Esplora {
                    server_url: var_serverUrl,
                    sync_config: var_syncConfig,
                };
            }
            1 => {
                let mut var_serverUrl = <String>::sse_decode(deserializer);
                let mut var_syncConfig =
                    <Option<ldk_adapter::types::ElectrumSyncConfig>>::sse_decode(deserializer);
                return ldk_adapter::types::ChainDataSourceConfig::Electrum {
                    server_url: var_serverUrl,
                    sync_config: var_syncConfig,
                };
            }
            2 => {
                let mut var_rpcHost = <String>::sse_decode(deserializer);
                let mut var_rpcPort = <u16>::sse_decode(deserializer);
                let mut var_rpcUser = <String>::sse_decode(deserializer);
                let mut var_rpcPassword = <String>::sse_decode(deserializer);
                return ldk_adapter::types::ChainDataSourceConfig::BitcoindRpc {
                    rpc_host: var_rpcHost,
                    rpc_port: var_rpcPort,
                    rpc_user: var_rpcUser,
                    rpc_password: var_rpcPassword,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for ldk_adapter::graph::ChannelInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodeOne = <ldk_adapter::graph::NodeId>::sse_decode(deserializer);
        let mut var_oneToTwo =
            <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_decode(deserializer);
        let mut var_nodeTwo = <ldk_adapter::graph::NodeId>::sse_decode(deserializer);
        let mut var_twoToOne =
            <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_decode(deserializer);
        let mut var_capacitySats = <Option<u64>>::sse_decode(deserializer);
        return ldk_adapter::graph::ChannelInfo {
            node_one: var_nodeOne,
            one_to_two: var_oneToTwo,
            node_two: var_nodeTwo,
            two_to_one: var_twoToOne,
            capacity_sats: var_capacitySats,
        };
    }
}

impl SseDecode for ldk_adapter::graph::ChannelUpdateInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdate = <u32>::sse_decode(deserializer);
        let mut var_enabled = <bool>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_htlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_htlcMaximumMsat = <u64>::sse_decode(deserializer);
        let mut var_fees = <ldk_adapter::graph::RoutingFees>::sse_decode(deserializer);
        return ldk_adapter::graph::ChannelUpdateInfo {
            last_update: var_lastUpdate,
            enabled: var_enabled,
            cltv_expiry_delta: var_cltvExpiryDelta,
            htlc_minimum_msat: var_htlcMinimumMsat,
            htlc_maximum_msat: var_htlcMaximumMsat,
            fees: var_fees,
        };
    }
}

impl SseDecode for ldk_adapter::types::ClosureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_peerFeerateSatPerKw = <u32>::sse_decode(deserializer);
                let mut var_requiredFeerateSatPerKw = <u32>::sse_decode(deserializer);
                return ldk_adapter::types::ClosureReason::PeerFeerateTooLow {
                    peer_feerate_sat_per_kw: var_peerFeerateSatPerKw,
                    required_feerate_sat_per_kw: var_requiredFeerateSatPerKw,
                };
            }
            1 => {
                let mut var_peerMsg = <String>::sse_decode(deserializer);
                return ldk_adapter::types::ClosureReason::CounterpartyForceClosed {
                    peer_msg: var_peerMsg,
                };
            }
            2 => {
                let mut var_broadcastedLatestTxn = <Option<bool>>::sse_decode(deserializer);
                return ldk_adapter::types::ClosureReason::HolderForceClosed {
                    broadcasted_latest_txn: var_broadcastedLatestTxn,
                };
            }
            3 => {
                return ldk_adapter::types::ClosureReason::LegacyCooperativeClosure;
            }
            4 => {
                return ldk_adapter::types::ClosureReason::CounterpartyInitiatedCooperativeClosure;
            }
            5 => {
                return ldk_adapter::types::ClosureReason::LocallyInitiatedCooperativeClosure;
            }
            6 => {
                return ldk_adapter::types::ClosureReason::CommitmentTxConfirmed;
            }
            7 => {
                return ldk_adapter::types::ClosureReason::FundingTimedOut;
            }
            8 => {
                let mut var_err = <String>::sse_decode(deserializer);
                return ldk_adapter::types::ClosureReason::ProcessingError { err: var_err };
            }
            9 => {
                return ldk_adapter::types::ClosureReason::DisconnectedPeer;
            }
            10 => {
                return ldk_adapter::types::ClosureReason::OutdatedChannelManager;
            }
            11 => {
                return ldk_adapter::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel;
            }
            12 => {
                return ldk_adapter::types::ClosureReason::FundingBatchClosure;
            }
            13 => {
                return ldk_adapter::types::ClosureReason::HTLCsTimedOut;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for ldk_adapter::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_storageDirPath = <String>::sse_decode(deserializer);
        let mut var_network = <shared::Network>::sse_decode(deserializer);
        let mut var_listeningAddresses = <Option<Vec<SocketAddress>>>::sse_decode(deserializer);
        let mut var_announcementAddresses = <Option<Vec<SocketAddress>>>::sse_decode(deserializer);
        let mut var_nodeAlias = <Option<ldk_adapter::types::NodeAlias>>::sse_decode(deserializer);
        let mut var_trustedPeers0Conf = <Vec<PublicKey>>::sse_decode(deserializer);
        let mut var_probingLiquidityLimitMultiplier = <u64>::sse_decode(deserializer);
        let mut var_anchorChannelsConfig = <Option<AnchorChannelsConfig>>::sse_decode(deserializer);
        let mut var_sendingParameters =
            <Option<shared::SendingParameters>>::sse_decode(deserializer);
        return ldk_adapter::types::Config {
            storage_dir_path: var_storageDirPath,
            network: var_network,
            listening_addresses: var_listeningAddresses,
            announcement_addresses: var_announcementAddresses,
            node_alias: var_nodeAlias,
            trusted_peers_0conf: var_trustedPeers0Conf,
            probing_liquidity_limit_multiplier: var_probingLiquidityLimitMultiplier,
            anchor_channels_config: var_anchorChannelsConfig,
            sending_parameters: var_sendingParameters,
        };
    }
}

impl SseDecode for ldk_adapter::types::CustomTlvRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_typeNum = <u64>::sse_decode(deserializer);
        let mut var_value = <Vec<u8>>::sse_decode(deserializer);
        return ldk_adapter::types::CustomTlvRecord {
            type_num: var_typeNum,
            value: var_value,
        };
    }
}

impl SseDecode for ldk_adapter::types::ElectrumSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_backgroundSyncConfig =
            <Option<ldk_adapter::types::BackgroundSyncConfig>>::sse_decode(deserializer);
        return ldk_adapter::types::ElectrumSyncConfig {
            background_sync_config: var_backgroundSyncConfig,
        };
    }
}

impl SseDecode for ldk_adapter::types::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return ldk_adapter::types::EntropySourceConfig::SeedFile(var_field0);
            }
            1 => {
                let mut var_field0 = <[u8; 64]>::sse_decode(deserializer);
                return ldk_adapter::types::EntropySourceConfig::SeedBytes(var_field0);
            }
            2 => {
                let mut var_mnemonic = <shared::Mnemonic>::sse_decode(deserializer);
                let mut var_passphrase = <Option<String>>::sse_decode(deserializer);
                return ldk_adapter::types::EntropySourceConfig::Bip39Mnemonic {
                    mnemonic: var_mnemonic,
                    passphrase: var_passphrase,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for ldk_adapter::types::EsploraSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_backgroundSyncConfig =
            <Option<ldk_adapter::types::BackgroundSyncConfig>>::sse_decode(deserializer);
        return ldk_adapter::types::EsploraSyncConfig {
            background_sync_config: var_backgroundSyncConfig,
        };
    }
}

impl SseDecode for ldk_adapter::types::Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_paymentId = <shared::PaymentId>::sse_decode(deserializer);
                let mut var_paymentHash = <shared::PaymentHash>::sse_decode(deserializer);
                let mut var_claimableAmountMsat = <u64>::sse_decode(deserializer);
                let mut var_claimDeadline = <Option<u32>>::sse_decode(deserializer);
                let mut var_customRecords =
                    <Vec<ldk_adapter::types::CustomTlvRecord>>::sse_decode(deserializer);
                return ldk_adapter::types::Event::PaymentClaimable {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    claimable_amount_msat: var_claimableAmountMsat,
                    claim_deadline: var_claimDeadline,
                    custom_records: var_customRecords,
                };
            }
            1 => {
                let mut var_paymentId = <Option<shared::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash = <shared::PaymentHash>::sse_decode(deserializer);
                let mut var_feePaidMsat = <Option<u64>>::sse_decode(deserializer);
                let mut var_preimage = <Option<shared::PaymentPreimage>>::sse_decode(deserializer);
                return ldk_adapter::types::Event::PaymentSuccessful {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    fee_paid_msat: var_feePaidMsat,
                    preimage: var_preimage,
                };
            }
            2 => {
                let mut var_paymentId = <Option<shared::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash = <Option<shared::PaymentHash>>::sse_decode(deserializer);
                let mut var_reason =
                    <Option<ldk_adapter::types::PaymentFailureReason>>::sse_decode(deserializer);
                return ldk_adapter::types::Event::PaymentFailed {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    reason: var_reason,
                };
            }
            3 => {
                let mut var_paymentId = <Option<shared::PaymentId>>::sse_decode(deserializer);
                let mut var_paymentHash = <shared::PaymentHash>::sse_decode(deserializer);
                let mut var_amountMsat = <u64>::sse_decode(deserializer);
                let mut var_customRecords =
                    <Vec<ldk_adapter::types::CustomTlvRecord>>::sse_decode(deserializer);
                return ldk_adapter::types::Event::PaymentReceived {
                    payment_id: var_paymentId,
                    payment_hash: var_paymentHash,
                    amount_msat: var_amountMsat,
                    custom_records: var_customRecords,
                };
            }
            4 => {
                let mut var_channelId = <ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId = <UserChannelId>::sse_decode(deserializer);
                let mut var_formerTemporaryChannelId = <ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId = <PublicKey>::sse_decode(deserializer);
                let mut var_fundingTxo = <shared::OutPoint>::sse_decode(deserializer);
                return ldk_adapter::types::Event::ChannelPending {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    former_temporary_channel_id: var_formerTemporaryChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    funding_txo: var_fundingTxo,
                };
            }
            5 => {
                let mut var_channelId = <ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId = <UserChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId = <Option<PublicKey>>::sse_decode(deserializer);
                return ldk_adapter::types::Event::ChannelReady {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                };
            }
            6 => {
                let mut var_channelId = <ChannelId>::sse_decode(deserializer);
                let mut var_userChannelId = <UserChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId = <Option<PublicKey>>::sse_decode(deserializer);
                let mut var_reason =
                    <Option<ldk_adapter::types::ClosureReason>>::sse_decode(deserializer);
                return ldk_adapter::types::Event::ChannelClosed {
                    channel_id: var_channelId,
                    user_channel_id: var_userChannelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    reason: var_reason,
                };
            }
            7 => {
                let mut var_prevChannelId = <ChannelId>::sse_decode(deserializer);
                let mut var_nextChannelId = <ChannelId>::sse_decode(deserializer);
                let mut var_prevUserChannelId = <Option<UserChannelId>>::sse_decode(deserializer);
                let mut var_nextUserChannelId = <Option<UserChannelId>>::sse_decode(deserializer);
                let mut var_prevNodeId = <Option<PublicKey>>::sse_decode(deserializer);
                let mut var_nextNodeId = <Option<PublicKey>>::sse_decode(deserializer);
                let mut var_totalFeeEarnedMsat = <Option<u64>>::sse_decode(deserializer);
                let mut var_skimmedFeeMsat = <Option<u64>>::sse_decode(deserializer);
                let mut var_claimFromOnchainTx = <bool>::sse_decode(deserializer);
                let mut var_outboundAmountForwardedMsat = <Option<u64>>::sse_decode(deserializer);
                return ldk_adapter::types::Event::PaymentForwarded {
                    prev_channel_id: var_prevChannelId,
                    next_channel_id: var_nextChannelId,
                    prev_user_channel_id: var_prevUserChannelId,
                    next_user_channel_id: var_nextUserChannelId,
                    prev_node_id: var_prevNodeId,
                    next_node_id: var_nextNodeId,
                    total_fee_earned_msat: var_totalFeeEarnedMsat,
                    skimmed_fee_msat: var_skimmedFeeMsat,
                    claim_from_onchain_tx: var_claimFromOnchainTx,
                    outbound_amount_forwarded_msat: var_outboundAmountForwardedMsat,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for ldk_adapter::types::FfiLogRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_level = <ldk_adapter::types::LogLevel>::sse_decode(deserializer);
        let mut var_args = <String>::sse_decode(deserializer);
        let mut var_modulePath = <String>::sse_decode(deserializer);
        let mut var_line = <u32>::sse_decode(deserializer);
        return ldk_adapter::types::FfiLogRecord {
            level: var_level,
            args: var_args,
            module_path: var_modulePath,
            line: var_line,
        };
    }
}

impl SseDecode for ldk_adapter::types::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return ldk_adapter::types::GossipSourceConfig::P2PNetwork;
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return ldk_adapter::types::GossipSourceConfig::RapidGossipSync(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for ldk_adapter::types::LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_channelId = <ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId = <PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_transactionFeeSatoshis = <u64>::sse_decode(deserializer);
                let mut var_outboundPaymentHtlcRoundedMsat = <u64>::sse_decode(deserializer);
                let mut var_outboundForwardedHtlcRoundedMsat = <u64>::sse_decode(deserializer);
                let mut var_inboundClaimingHtlcRoundedMsat = <u64>::sse_decode(deserializer);
                let mut var_inboundHtlcRoundedMsat = <u64>::sse_decode(deserializer);
                return ldk_adapter::types::LightningBalance::ClaimableOnChannelClose {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    transaction_fee_satoshis: var_transactionFeeSatoshis,
                    outbound_payment_htlc_rounded_msat: var_outboundPaymentHtlcRoundedMsat,
                    outbound_forwarded_htlc_rounded_msat: var_outboundForwardedHtlcRoundedMsat,
                    inbound_claiming_htlc_rounded_msat: var_inboundClaimingHtlcRoundedMsat,
                    inbound_htlc_rounded_msat: var_inboundHtlcRoundedMsat,
                };
            }
            1 => {
                let mut var_channelId = <ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId = <PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_confirmationHeight = <u32>::sse_decode(deserializer);
                let mut var_source = <ldk_adapter::types::BalanceSource>::sse_decode(deserializer);
                return ldk_adapter::types::LightningBalance::ClaimableAwaitingConfirmations {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    confirmation_height: var_confirmationHeight,
                    source: var_source,
                };
            }
            2 => {
                let mut var_channelId = <ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId = <PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_timeoutHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash = <shared::PaymentHash>::sse_decode(deserializer);
                let mut var_paymentPreimage = <shared::PaymentPreimage>::sse_decode(deserializer);
                return ldk_adapter::types::LightningBalance::ContentiousClaimable {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    timeout_height: var_timeoutHeight,
                    payment_hash: var_paymentHash,
                    payment_preimage: var_paymentPreimage,
                };
            }
            3 => {
                let mut var_channelId = <ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId = <PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_claimableHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash = <shared::PaymentHash>::sse_decode(deserializer);
                let mut var_outboundPayment = <bool>::sse_decode(deserializer);
                return ldk_adapter::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    claimable_height: var_claimableHeight,
                    payment_hash: var_paymentHash,
                    outbound_payment: var_outboundPayment,
                };
            }
            4 => {
                let mut var_channelId = <ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId = <PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                let mut var_expiryHeight = <u32>::sse_decode(deserializer);
                let mut var_paymentHash = <shared::PaymentHash>::sse_decode(deserializer);
                return ldk_adapter::types::LightningBalance::MaybePreimageClaimableHTLC {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                    expiry_height: var_expiryHeight,
                    payment_hash: var_paymentHash,
                };
            }
            5 => {
                let mut var_channelId = <ChannelId>::sse_decode(deserializer);
                let mut var_counterpartyNodeId = <PublicKey>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return ldk_adapter::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                    channel_id: var_channelId,
                    counterparty_node_id: var_counterpartyNodeId,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for ldk_adapter::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lsps2Service =
            <(SocketAddress, PublicKey, Option<String>)>::sse_decode(deserializer);
        return ldk_adapter::types::LiquiditySourceConfig {
            lsps2_service: var_lsps2Service,
        };
    }
}

impl SseDecode for Vec<ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ChannelDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<PeerDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<PublicKey>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<SocketAddress>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ldk_adapter::types::CustomTlvRecord> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ldk_adapter::types::CustomTlvRecord>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ldk_adapter::types::LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ldk_adapter::types::LightningBalance>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<u8>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ldk_adapter::graph::NodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ldk_adapter::graph::NodeId>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ldk_adapter::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ldk_adapter::types::PaymentDetails>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ldk_adapter::types::PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ldk_adapter::types::PendingSweepBalance>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<shared::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<shared::TxIn>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<shared::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<shared::TxOut>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for ldk_adapter::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::LogLevel::Gossip,
            1 => ldk_adapter::types::LogLevel::Trace,
            2 => ldk_adapter::types::LogLevel::Debug,
            3 => ldk_adapter::types::LogLevel::Info,
            4 => ldk_adapter::types::LogLevel::Warn,
            5 => ldk_adapter::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", inner),
        };
    }
}

impl SseDecode for ldk_adapter::types::LSPFeeLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxTotalOpeningFeeMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_maxProportionalOpeningFeePpmMsat = <Option<u64>>::sse_decode(deserializer);
        return ldk_adapter::types::LSPFeeLimits {
            max_total_opening_fee_msat: var_maxTotalOpeningFeeMsat,
            max_proportional_opening_fee_ppm_msat: var_maxProportionalOpeningFeePpmMsat,
        };
    }
}

impl SseDecode for shared::Mnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_words = <Vec<String>>::sse_decode(deserializer);
        return shared::Mnemonic { words: var_words };
    }
}

impl SseDecode for shared::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => shared::Network::Bitcoin,
            1 => shared::Network::Testnet,
            2 => shared::Network::Testnet4,
            3 => shared::Network::Signet,
            4 => shared::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for ldk_adapter::types::NodeAlias {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return ldk_adapter::types::NodeAlias(var_field0);
    }
}

impl SseDecode for ldk_adapter::graph::NodeAnnouncementInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdate = <u32>::sse_decode(deserializer);
        let mut var_alias = <String>::sse_decode(deserializer);
        let mut var_addresses = <Vec<SocketAddress>>::sse_decode(deserializer);
        return ldk_adapter::graph::NodeAnnouncementInfo {
            last_update: var_lastUpdate,
            alias: var_alias,
            addresses: var_addresses,
        };
    }
}

impl SseDecode for ldk_adapter::graph::NodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_compressed = <Vec<u8>>::sse_decode(deserializer);
        return ldk_adapter::graph::NodeId {
            compressed: var_compressed,
        };
    }
}

impl SseDecode for ldk_adapter::graph::NodeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channels = <Vec<u64>>::sse_decode(deserializer);
        let mut var_announcementInfo =
            <Option<ldk_adapter::graph::NodeAnnouncementInfo>>::sse_decode(deserializer);
        return ldk_adapter::graph::NodeInfo {
            channels: var_channels,
            announcement_info: var_announcementInfo,
        };
    }
}

impl SseDecode for ldk_adapter::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isRunning = <bool>::sse_decode(deserializer);
        let mut var_isListening = <bool>::sse_decode(deserializer);
        let mut var_currentBestBlock = <ldk_adapter::types::BestBlock>::sse_decode(deserializer);
        let mut var_latestLightningWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestOnchainWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestFeeRateCacheUpdateTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestRgsSnapshotTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestNodeAnnouncementBroadcastTimestamp =
            <Option<u64>>::sse_decode(deserializer);
        let mut var_latestChannelMonitorArchivalHeight = <Option<u32>>::sse_decode(deserializer);
        return ldk_adapter::types::NodeStatus {
            is_running: var_isRunning,
            is_listening: var_isListening,
            current_best_block: var_currentBestBlock,
            latest_lightning_wallet_sync_timestamp: var_latestLightningWalletSyncTimestamp,
            latest_onchain_wallet_sync_timestamp: var_latestOnchainWalletSyncTimestamp,
            latest_fee_rate_cache_update_timestamp: var_latestFeeRateCacheUpdateTimestamp,
            latest_rgs_snapshot_timestamp: var_latestRgsSnapshotTimestamp,
            latest_node_announcement_broadcast_timestamp:
                var_latestNodeAnnouncementBroadcastTimestamp,
            latest_channel_monitor_archival_height: var_latestChannelMonitorArchivalHeight,
        };
    }
}

impl SseDecode for shared::Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return shared::Offer { s: var_s };
    }
}

impl SseDecode for ldk_adapter::types::OfferId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return ldk_adapter::types::OfferId(var_field0);
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<AnchorChannelsConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<AnchorChannelsConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ChannelConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ChannelId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<PublicKey>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<UserChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<UserChannelId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::BackgroundSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::BackgroundSyncConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::ChainDataSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::ChannelInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::ChannelInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::ChannelUpdateInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::ChannelUpdateInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::ClosureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::ClosureReason>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::ElectrumSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::ElectrumSyncConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::EntropySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::EsploraSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::EsploraSyncConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::Event>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::GossipSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::LiquiditySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::LogLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::LogLevel>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::NodeAlias> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::NodeAlias>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::NodeAnnouncementInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::NodeAnnouncementInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::NodeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::NodeInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::OfferId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::OfferId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<shared::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<shared::OutPoint>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::PaymentDetails>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::PaymentFailureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::PaymentFailureReason>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<shared::PaymentHash> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<shared::PaymentHash>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<shared::PaymentId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<shared::PaymentId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<shared::PaymentPreimage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<shared::PaymentPreimage>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::PaymentSecret>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<shared::SendingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<shared::SendingParameters>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u16>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<SocketAddress>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for shared::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <shared::Txid>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return shared::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for ldk_adapter::types::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <shared::PaymentId>::sse_decode(deserializer);
        let mut var_kind = <ldk_adapter::types::PaymentKind>::sse_decode(deserializer);
        let mut var_amountMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_direction = <ldk_adapter::types::PaymentDirection>::sse_decode(deserializer);
        let mut var_status = <ldk_adapter::types::PaymentStatus>::sse_decode(deserializer);
        let mut var_latestUpdateTimestamp = <u64>::sse_decode(deserializer);
        return ldk_adapter::types::PaymentDetails {
            id: var_id,
            kind: var_kind,
            amount_msat: var_amountMsat,
            direction: var_direction,
            status: var_status,
            latest_update_timestamp: var_latestUpdateTimestamp,
        };
    }
}

impl SseDecode for ldk_adapter::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::PaymentDirection::Inbound,
            1 => ldk_adapter::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", inner),
        };
    }
}

impl SseDecode for ldk_adapter::types::PaymentFailureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::PaymentFailureReason::RecipientRejected,
            1 => ldk_adapter::types::PaymentFailureReason::UserAbandoned,
            2 => ldk_adapter::types::PaymentFailureReason::RetriesExhausted,
            3 => ldk_adapter::types::PaymentFailureReason::PaymentExpired,
            4 => ldk_adapter::types::PaymentFailureReason::RouteNotFound,
            5 => ldk_adapter::types::PaymentFailureReason::UnexpectedError,
            6 => ldk_adapter::types::PaymentFailureReason::UnknownRequiredFeatures,
            7 => ldk_adapter::types::PaymentFailureReason::InvoiceRequestExpired,
            8 => ldk_adapter::types::PaymentFailureReason::InvoiceRequestRejected,
            9 => ldk_adapter::types::PaymentFailureReason::BlindedPathCreationFailed,
            _ => unreachable!("Invalid variant for PaymentFailureReason: {}", inner),
        };
    }
}

impl SseDecode for shared::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return shared::PaymentHash { data: var_data };
    }
}

impl SseDecode for shared::PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return shared::PaymentId { data: var_data };
    }
}

impl SseDecode for ldk_adapter::types::PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_txid = <shared::Txid>::sse_decode(deserializer);
                let mut var_status = <ConfirmationStatus>::sse_decode(deserializer);
                return ldk_adapter::types::PaymentKind::Onchain {
                    txid: var_txid,
                    status: var_status,
                };
            }
            1 => {
                let mut var_hash = <shared::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage = <Option<shared::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<ldk_adapter::types::PaymentSecret>>::sse_decode(deserializer);
                return ldk_adapter::types::PaymentKind::Bolt11 {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                };
            }
            2 => {
                let mut var_hash = <shared::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage = <Option<shared::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<ldk_adapter::types::PaymentSecret>>::sse_decode(deserializer);
                let mut var_lspFeeLimits =
                    <ldk_adapter::types::LSPFeeLimits>::sse_decode(deserializer);
                let mut var_counterpartySkimmedFeeMsat = <Option<u64>>::sse_decode(deserializer);
                return ldk_adapter::types::PaymentKind::Bolt11Jit {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                    lsp_fee_limits: var_lspFeeLimits,
                    counterparty_skimmed_fee_msat: var_counterpartySkimmedFeeMsat,
                };
            }
            3 => {
                let mut var_hash = <shared::PaymentHash>::sse_decode(deserializer);
                let mut var_preimage = <Option<shared::PaymentPreimage>>::sse_decode(deserializer);
                return ldk_adapter::types::PaymentKind::Spontaneous {
                    hash: var_hash,
                    preimage: var_preimage,
                };
            }
            4 => {
                let mut var_hash = <Option<shared::PaymentHash>>::sse_decode(deserializer);
                let mut var_preimage = <Option<shared::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<ldk_adapter::types::PaymentSecret>>::sse_decode(deserializer);
                let mut var_offerId = <ldk_adapter::types::OfferId>::sse_decode(deserializer);
                let mut var_payerNote = <Option<String>>::sse_decode(deserializer);
                let mut var_quantity = <Option<u64>>::sse_decode(deserializer);
                return ldk_adapter::types::PaymentKind::Bolt12Offer {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                    offer_id: var_offerId,
                    payer_note: var_payerNote,
                    quantity: var_quantity,
                };
            }
            5 => {
                let mut var_hash = <Option<shared::PaymentHash>>::sse_decode(deserializer);
                let mut var_preimage = <Option<shared::PaymentPreimage>>::sse_decode(deserializer);
                let mut var_secret =
                    <Option<ldk_adapter::types::PaymentSecret>>::sse_decode(deserializer);
                let mut var_payerNote = <Option<String>>::sse_decode(deserializer);
                let mut var_quantity = <Option<u64>>::sse_decode(deserializer);
                return ldk_adapter::types::PaymentKind::Bolt12Refund {
                    hash: var_hash,
                    preimage: var_preimage,
                    secret: var_secret,
                    payer_note: var_payerNote,
                    quantity: var_quantity,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for shared::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return shared::PaymentPreimage { data: var_data };
    }
}

impl SseDecode for ldk_adapter::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return ldk_adapter::types::PaymentSecret { data: var_data };
    }
}

impl SseDecode for ldk_adapter::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::PaymentStatus::Pending,
            1 => ldk_adapter::types::PaymentStatus::Succeeded,
            2 => ldk_adapter::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", inner),
        };
    }
}

impl SseDecode for ldk_adapter::types::PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_channelId = <Option<ChannelId>>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return ldk_adapter::types::PendingSweepBalance::PendingBroadcast {
                    channel_id: var_channelId,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            1 => {
                let mut var_channelId = <Option<ChannelId>>::sse_decode(deserializer);
                let mut var_latestBroadcastHeight = <u32>::sse_decode(deserializer);
                let mut var_latestSpendingTxid = <shared::Txid>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return ldk_adapter::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                    channel_id: var_channelId,
                    latest_broadcast_height: var_latestBroadcastHeight,
                    latest_spending_txid: var_latestSpendingTxid,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            2 => {
                let mut var_channelId = <Option<ChannelId>>::sse_decode(deserializer);
                let mut var_latestSpendingTxid = <shared::Txid>::sse_decode(deserializer);
                let mut var_confirmationHash = <String>::sse_decode(deserializer);
                let mut var_confirmationHeight = <u32>::sse_decode(deserializer);
                let mut var_amountSatoshis = <u64>::sse_decode(deserializer);
                return ldk_adapter::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                    channel_id: var_channelId,
                    latest_spending_txid: var_latestSpendingTxid,
                    confirmation_hash: var_confirmationHash,
                    confirmation_height: var_confirmationHeight,
                    amount_satoshis: var_amountSatoshis,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for shared::Psbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inner = <String>::sse_decode(deserializer);
        return shared::Psbt { inner: var_inner };
    }
}

impl SseDecode for (SocketAddress, PublicKey, Option<String>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <SocketAddress>::sse_decode(deserializer);
        let mut var_field1 = <PublicKey>::sse_decode(deserializer);
        let mut var_field2 = <Option<String>>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for shared::Refund {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return shared::Refund { s: var_s };
    }
}

impl SseDecode for ldk_adapter::graph::RoutingFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_baseMsat = <u32>::sse_decode(deserializer);
        let mut var_proportionalMillionths = <u32>::sse_decode(deserializer);
        return ldk_adapter::graph::RoutingFees {
            base_msat: var_baseMsat,
            proportional_millionths: var_proportionalMillionths,
        };
    }
}

impl SseDecode for shared::ScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inner = <Vec<u8>>::sse_decode(deserializer);
        return shared::ScriptBuf { inner: var_inner };
    }
}

impl SseDecode for shared::SendingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxTotalRoutingFeeMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_maxTotalCltvExpiryDelta = <Option<u32>>::sse_decode(deserializer);
        let mut var_maxPathCount = <Option<u8>>::sse_decode(deserializer);
        let mut var_maxChannelSaturationPowerOfHalf = <Option<u8>>::sse_decode(deserializer);
        return shared::SendingParameters {
            max_total_routing_fee_msat: var_maxTotalRoutingFeeMsat,
            max_total_cltv_expiry_delta: var_maxTotalCltvExpiryDelta,
            max_path_count: var_maxPathCount,
            max_channel_saturation_power_of_half: var_maxChannelSaturationPowerOfHalf,
        };
    }
}

impl SseDecode for shared::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_previousOutput = <shared::OutPoint>::sse_decode(deserializer);
        let mut var_scriptSig = <shared::ScriptBuf>::sse_decode(deserializer);
        let mut var_sequence = <u32>::sse_decode(deserializer);
        let mut var_witness = <Vec<Vec<u8>>>::sse_decode(deserializer);
        return shared::TxIn {
            previous_output: var_previousOutput,
            script_sig: var_scriptSig,
            sequence: var_sequence,
            witness: var_witness,
        };
    }
}

impl SseDecode for shared::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_scriptPubkey = <shared::ScriptBuf>::sse_decode(deserializer);
        return shared::TxOut {
            value: var_value,
            script_pubkey: var_scriptPubkey,
        };
    }
}

impl SseDecode for shared::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        return shared::Txid { hash: var_hash };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for shared::WTxid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        return shared::WTxid { hash: var_hash };
    }
}

impl SseDecode for shared::WitnessProgram {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_version = <u8>::sse_decode(deserializer);
        let mut var_program = <Vec<u8>>::sse_decode(deserializer);
        return shared::WitnessProgram {
            version: var_version,
            program: var_program,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AddressData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AddressData> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AddressData>> for AddressData {
    fn into_into_dart(self) -> FrbWrapper<AddressData> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AnchorChannelsConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<AnchorChannelsConfig>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AnchorChannelsConfig>> for AnchorChannelsConfig {
    fn into_into_dart(self) -> FrbWrapper<AnchorChannelsConfig> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinAddress> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BitcoinAddress> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinAddress>> for BitcoinAddress {
    fn into_into_dart(self) -> FrbWrapper<BitcoinAddress> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinAddressInner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<BitcoinAddressInner>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinAddressInner>> for BitcoinAddressInner {
    fn into_into_dart(self) -> FrbWrapper<BitcoinAddressInner> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinTransactionInner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<BitcoinTransactionInner>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinTransactionInner>>
    for BitcoinTransactionInner
{
    fn into_into_dart(self) -> FrbWrapper<BitcoinTransactionInner> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Bolt11Payment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Bolt11Payment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Bolt11Payment>> for Bolt11Payment {
    fn into_into_dart(self) -> FrbWrapper<Bolt11Payment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Bolt12Payment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Bolt12Payment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Bolt12Payment>> for Bolt12Payment {
    fn into_into_dart(self) -> FrbWrapper<Bolt12Payment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelConfig> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelConfig>> for ChannelConfig {
    fn into_into_dart(self) -> FrbWrapper<ChannelConfig> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelDetails> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelDetails>> for ChannelDetails {
    fn into_into_dart(self) -> FrbWrapper<ChannelDetails> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelId> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelId>> for ChannelId {
    fn into_into_dart(self) -> FrbWrapper<ChannelId> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ConfirmationStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ConfirmationStatus>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ConfirmationStatus>> for ConfirmationStatus {
    fn into_into_dart(self) -> FrbWrapper<ConfirmationStatus> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<LdkBuilder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<LdkBuilder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<LdkBuilder>> for LdkBuilder {
    fn into_into_dart(self) -> FrbWrapper<LdkBuilder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MaxDustHTLCExposure> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MaxDustHTLCExposure>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MaxDustHTLCExposure>> for MaxDustHTLCExposure {
    fn into_into_dart(self) -> FrbWrapper<MaxDustHTLCExposure> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<NetworkGraph> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<NetworkGraph> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<NetworkGraph>> for NetworkGraph {
    fn into_into_dart(self) -> FrbWrapper<NetworkGraph> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Node> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Node> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Node>> for Node {
    fn into_into_dart(self) -> FrbWrapper<Node> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<OnChainPayment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<OnChainPayment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OnChainPayment>> for OnChainPayment {
    fn into_into_dart(self) -> FrbWrapper<OnChainPayment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PeerDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PeerDetails> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PeerDetails>> for PeerDetails {
    fn into_into_dart(self) -> FrbWrapper<PeerDetails> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PublicKey> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PublicKey> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PublicKey>> for PublicKey {
    fn into_into_dart(self) -> FrbWrapper<PublicKey> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<QrPaymentResult> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<QrPaymentResult> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<QrPaymentResult>> for QrPaymentResult {
    fn into_into_dart(self) -> FrbWrapper<QrPaymentResult> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SocketAddress> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<SocketAddress> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SocketAddress>> for SocketAddress {
    fn into_into_dart(self) -> FrbWrapper<SocketAddress> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SpontaneousPayment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<SpontaneousPayment>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SpontaneousPayment>> for SpontaneousPayment {
    fn into_into_dart(self) -> FrbWrapper<SpontaneousPayment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TaprootSpendInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<TaprootSpendInfo> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TaprootSpendInfo>> for TaprootSpendInfo {
    fn into_into_dart(self) -> FrbWrapper<TaprootSpendInfo> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TaprootSpendInfoInner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<TaprootSpendInfoInner>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TaprootSpendInfoInner>>
    for TaprootSpendInfoInner
{
    fn into_into_dart(self) -> FrbWrapper<TaprootSpendInfoInner> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Transaction> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Transaction> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Transaction>> for Transaction {
    fn into_into_dart(self) -> FrbWrapper<Transaction> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<UnifiedQrPayment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<UnifiedQrPayment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<UnifiedQrPayment>> for UnifiedQrPayment {
    fn into_into_dart(self) -> FrbWrapper<UnifiedQrPayment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<UserChannelId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<UserChannelId> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<UserChannelId>> for UserChannelId {
    fn into_into_dart(self) -> FrbWrapper<UserChannelId> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::BackgroundSyncConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .onchain_wallet_sync_interval_secs
                .into_into_dart()
                .into_dart(),
            self.0
                .lightning_wallet_sync_interval_secs
                .into_into_dart()
                .into_dart(),
            self.0
                .fee_rate_cache_update_interval_secs
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::BackgroundSyncConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::BackgroundSyncConfig>>
    for ldk_adapter::types::BackgroundSyncConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::BackgroundSyncConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::BalanceDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .total_onchain_balance_sats
                .into_into_dart()
                .into_dart(),
            self.0
                .spendable_onchain_balance_sats
                .into_into_dart()
                .into_dart(),
            self.0
                .total_lightning_balance_sats
                .into_into_dart()
                .into_dart(),
            self.0.lightning_balances.into_into_dart().into_dart(),
            self.0
                .pending_balances_from_channel_closures
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::BalanceDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::BalanceDetails>>
    for ldk_adapter::types::BalanceDetails
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::BalanceDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::BalanceSource> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::BalanceSource::HolderForceClosed => 0.into_dart(),
            ldk_adapter::types::BalanceSource::CounterpartyForceClosed => 1.into_dart(),
            ldk_adapter::types::BalanceSource::CoopClose => 2.into_dart(),
            ldk_adapter::types::BalanceSource::Htlc => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::BalanceSource>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::BalanceSource>>
    for ldk_adapter::types::BalanceSource
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::BalanceSource> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::BestBlock> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.block_hash.into_into_dart().into_dart(),
            self.0.height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::BestBlock>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::BestBlock>>
    for ldk_adapter::types::BestBlock
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::BestBlock> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Bolt11Invoice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.signed_raw_invoice.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::Bolt11Invoice>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Bolt11Invoice>>
    for shared::Bolt11Invoice
{
    fn into_into_dart(self) -> FrbWrapper<shared::Bolt11Invoice> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Bolt12Invoice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::Bolt12Invoice>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Bolt12Invoice>>
    for shared::Bolt12Invoice
{
    fn into_into_dart(self) -> FrbWrapper<shared::Bolt12Invoice> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::ChainDataSourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::ChainDataSourceConfig::Esplora {
                server_url,
                sync_config,
            } => [
                0.into_dart(),
                server_url.into_into_dart().into_dart(),
                sync_config.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::ChainDataSourceConfig::Electrum {
                server_url,
                sync_config,
            } => [
                1.into_dart(),
                server_url.into_into_dart().into_dart(),
                sync_config.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::ChainDataSourceConfig::BitcoindRpc {
                rpc_host,
                rpc_port,
                rpc_user,
                rpc_password,
            } => [
                2.into_dart(),
                rpc_host.into_into_dart().into_dart(),
                rpc_port.into_into_dart().into_dart(),
                rpc_user.into_into_dart().into_dart(),
                rpc_password.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::ChainDataSourceConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::ChainDataSourceConfig>>
    for ldk_adapter::types::ChainDataSourceConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::ChainDataSourceConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::ChannelInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.node_one.into_into_dart().into_dart(),
            self.0.one_to_two.into_into_dart().into_dart(),
            self.0.node_two.into_into_dart().into_dart(),
            self.0.two_to_one.into_into_dart().into_dart(),
            self.0.capacity_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::ChannelInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::ChannelInfo>>
    for ldk_adapter::graph::ChannelInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::ChannelInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.last_update.into_into_dart().into_dart(),
            self.0.enabled.into_into_dart().into_dart(),
            self.0.cltv_expiry_delta.into_into_dart().into_dart(),
            self.0.htlc_minimum_msat.into_into_dart().into_dart(),
            self.0.htlc_maximum_msat.into_into_dart().into_dart(),
            self.0.fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo>>
    for ldk_adapter::graph::ChannelUpdateInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::ClosureReason> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::ClosureReason::PeerFeerateTooLow {
                peer_feerate_sat_per_kw,
                required_feerate_sat_per_kw,
            } => [
                0.into_dart(),
                peer_feerate_sat_per_kw.into_into_dart().into_dart(),
                required_feerate_sat_per_kw.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::ClosureReason::CounterpartyForceClosed { peer_msg } => {
                [1.into_dart(), peer_msg.into_into_dart().into_dart()].into_dart()
            }
            ldk_adapter::types::ClosureReason::HolderForceClosed {
                broadcasted_latest_txn,
            } => [
                2.into_dart(),
                broadcasted_latest_txn.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::ClosureReason::LegacyCooperativeClosure => {
                [3.into_dart()].into_dart()
            }
            ldk_adapter::types::ClosureReason::CounterpartyInitiatedCooperativeClosure => {
                [4.into_dart()].into_dart()
            }
            ldk_adapter::types::ClosureReason::LocallyInitiatedCooperativeClosure => {
                [5.into_dart()].into_dart()
            }
            ldk_adapter::types::ClosureReason::CommitmentTxConfirmed => [6.into_dart()].into_dart(),
            ldk_adapter::types::ClosureReason::FundingTimedOut => [7.into_dart()].into_dart(),
            ldk_adapter::types::ClosureReason::ProcessingError { err } => {
                [8.into_dart(), err.into_into_dart().into_dart()].into_dart()
            }
            ldk_adapter::types::ClosureReason::DisconnectedPeer => [9.into_dart()].into_dart(),
            ldk_adapter::types::ClosureReason::OutdatedChannelManager => {
                [10.into_dart()].into_dart()
            }
            ldk_adapter::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel => {
                [11.into_dart()].into_dart()
            }
            ldk_adapter::types::ClosureReason::FundingBatchClosure => [12.into_dart()].into_dart(),
            ldk_adapter::types::ClosureReason::HTLCsTimedOut => [13.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::ClosureReason>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::ClosureReason>>
    for ldk_adapter::types::ClosureReason
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::ClosureReason> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::Config> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.storage_dir_path.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.listening_addresses.into_into_dart().into_dart(),
            self.0.announcement_addresses.into_into_dart().into_dart(),
            self.0.node_alias.into_into_dart().into_dart(),
            self.0.trusted_peers_0conf.into_into_dart().into_dart(),
            self.0
                .probing_liquidity_limit_multiplier
                .into_into_dart()
                .into_dart(),
            self.0.anchor_channels_config.into_into_dart().into_dart(),
            self.0.sending_parameters.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::Config>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::Config>>
    for ldk_adapter::types::Config
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::Config> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::CustomTlvRecord> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.type_num.into_into_dart().into_dart(),
            self.0.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::CustomTlvRecord>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::CustomTlvRecord>>
    for ldk_adapter::types::CustomTlvRecord
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::CustomTlvRecord> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::ElectrumSyncConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.background_sync_config.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::ElectrumSyncConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::ElectrumSyncConfig>>
    for ldk_adapter::types::ElectrumSyncConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::ElectrumSyncConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::EntropySourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::EntropySourceConfig::SeedFile(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            ldk_adapter::types::EntropySourceConfig::SeedBytes(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            ldk_adapter::types::EntropySourceConfig::Bip39Mnemonic {
                mnemonic,
                passphrase,
            } => [
                2.into_dart(),
                mnemonic.into_into_dart().into_dart(),
                passphrase.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::EntropySourceConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::EntropySourceConfig>>
    for ldk_adapter::types::EntropySourceConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::EntropySourceConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::EsploraSyncConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.background_sync_config.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::EsploraSyncConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::EsploraSyncConfig>>
    for ldk_adapter::types::EsploraSyncConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::EsploraSyncConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::Event> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::Event::PaymentClaimable {
                payment_id,
                payment_hash,
                claimable_amount_msat,
                claim_deadline,
                custom_records,
            } => [
                0.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                claimable_amount_msat.into_into_dart().into_dart(),
                claim_deadline.into_into_dart().into_dart(),
                custom_records.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::Event::PaymentSuccessful {
                payment_id,
                payment_hash,
                fee_paid_msat,
                preimage,
            } => [
                1.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                fee_paid_msat.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::Event::PaymentFailed {
                payment_id,
                payment_hash,
                reason,
            } => [
                2.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                reason.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::Event::PaymentReceived {
                payment_id,
                payment_hash,
                amount_msat,
                custom_records,
            } => [
                3.into_dart(),
                payment_id.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                amount_msat.into_into_dart().into_dart(),
                custom_records.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::Event::ChannelPending {
                channel_id,
                user_channel_id,
                former_temporary_channel_id,
                counterparty_node_id,
                funding_txo,
            } => [
                4.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                former_temporary_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                funding_txo.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::Event::ChannelReady {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => [
                5.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::Event::ChannelClosed {
                channel_id,
                user_channel_id,
                counterparty_node_id,
                reason,
            } => [
                6.into_dart(),
                channel_id.into_into_dart().into_dart(),
                user_channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                reason.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::Event::PaymentForwarded {
                prev_channel_id,
                next_channel_id,
                prev_user_channel_id,
                next_user_channel_id,
                prev_node_id,
                next_node_id,
                total_fee_earned_msat,
                skimmed_fee_msat,
                claim_from_onchain_tx,
                outbound_amount_forwarded_msat,
            } => [
                7.into_dart(),
                prev_channel_id.into_into_dart().into_dart(),
                next_channel_id.into_into_dart().into_dart(),
                prev_user_channel_id.into_into_dart().into_dart(),
                next_user_channel_id.into_into_dart().into_dart(),
                prev_node_id.into_into_dart().into_dart(),
                next_node_id.into_into_dart().into_dart(),
                total_fee_earned_msat.into_into_dart().into_dart(),
                skimmed_fee_msat.into_into_dart().into_dart(),
                claim_from_onchain_tx.into_into_dart().into_dart(),
                outbound_amount_forwarded_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::Event>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::Event>>
    for ldk_adapter::types::Event
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::Event> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::FfiLogRecord> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.level.into_into_dart().into_dart(),
            self.0.args.into_into_dart().into_dart(),
            self.0.module_path.into_into_dart().into_dart(),
            self.0.line.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::FfiLogRecord>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::FfiLogRecord>>
    for ldk_adapter::types::FfiLogRecord
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::FfiLogRecord> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::GossipSourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::GossipSourceConfig::P2PNetwork => [0.into_dart()].into_dart(),
            ldk_adapter::types::GossipSourceConfig::RapidGossipSync(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::GossipSourceConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::GossipSourceConfig>>
    for ldk_adapter::types::GossipSourceConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::GossipSourceConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::LightningBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::LightningBalance::ClaimableOnChannelClose {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                transaction_fee_satoshis,
                outbound_payment_htlc_rounded_msat,
                outbound_forwarded_htlc_rounded_msat,
                inbound_claiming_htlc_rounded_msat,
                inbound_htlc_rounded_msat,
            } => [
                0.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                transaction_fee_satoshis.into_into_dart().into_dart(),
                outbound_payment_htlc_rounded_msat
                    .into_into_dart()
                    .into_dart(),
                outbound_forwarded_htlc_rounded_msat
                    .into_into_dart()
                    .into_dart(),
                inbound_claiming_htlc_rounded_msat
                    .into_into_dart()
                    .into_dart(),
                inbound_htlc_rounded_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::LightningBalance::ClaimableAwaitingConfirmations {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                confirmation_height,
                source,
            } => [
                1.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                confirmation_height.into_into_dart().into_dart(),
                source.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::LightningBalance::ContentiousClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                timeout_height,
                payment_hash,
                payment_preimage,
            } => [
                2.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                timeout_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                payment_preimage.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                claimable_height,
                payment_hash,
                outbound_payment,
            } => [
                3.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                claimable_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
                outbound_payment.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::LightningBalance::MaybePreimageClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                expiry_height,
                payment_hash,
            } => [
                4.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
                expiry_height.into_into_dart().into_dart(),
                payment_hash.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => [
                5.into_dart(),
                channel_id.into_into_dart().into_dart(),
                counterparty_node_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::LightningBalance>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::LightningBalance>>
    for ldk_adapter::types::LightningBalance
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::LightningBalance> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::LiquiditySourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.lsps2_service.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::LiquiditySourceConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::LiquiditySourceConfig>>
    for ldk_adapter::types::LiquiditySourceConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::LiquiditySourceConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::LogLevel> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::LogLevel::Gossip => 0.into_dart(),
            ldk_adapter::types::LogLevel::Trace => 1.into_dart(),
            ldk_adapter::types::LogLevel::Debug => 2.into_dart(),
            ldk_adapter::types::LogLevel::Info => 3.into_dart(),
            ldk_adapter::types::LogLevel::Warn => 4.into_dart(),
            ldk_adapter::types::LogLevel::Error => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::LogLevel>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::LogLevel>>
    for ldk_adapter::types::LogLevel
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::LogLevel> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::LSPFeeLimits> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .max_total_opening_fee_msat
                .into_into_dart()
                .into_dart(),
            self.0
                .max_proportional_opening_fee_ppm_msat
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::LSPFeeLimits>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::LSPFeeLimits>>
    for ldk_adapter::types::LSPFeeLimits
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::LSPFeeLimits> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Mnemonic> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.words.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Mnemonic> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Mnemonic>> for shared::Mnemonic {
    fn into_into_dart(self) -> FrbWrapper<shared::Mnemonic> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Network> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            shared::Network::Bitcoin => 0.into_dart(),
            shared::Network::Testnet => 1.into_dart(),
            shared::Network::Testnet4 => 2.into_dart(),
            shared::Network::Signet => 3.into_dart(),
            shared::Network::Regtest => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Network> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Network>> for shared::Network {
    fn into_into_dart(self) -> FrbWrapper<shared::Network> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::NodeAlias> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::NodeAlias>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::NodeAlias>>
    for ldk_adapter::types::NodeAlias
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::NodeAlias> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.last_update.into_into_dart().into_dart(),
            self.0.alias.into_into_dart().into_dart(),
            self.0.addresses.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo>>
    for ldk_adapter::graph::NodeAnnouncementInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::NodeId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.compressed.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::NodeId>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::NodeId>>
    for ldk_adapter::graph::NodeId
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::NodeId> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::NodeInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.channels.into_into_dart().into_dart(),
            self.0.announcement_info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::NodeInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::NodeInfo>>
    for ldk_adapter::graph::NodeInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::NodeInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::NodeStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.is_running.into_into_dart().into_dart(),
            self.0.is_listening.into_into_dart().into_dart(),
            self.0.current_best_block.into_into_dart().into_dart(),
            self.0
                .latest_lightning_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_onchain_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_fee_rate_cache_update_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_rgs_snapshot_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_node_announcement_broadcast_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_channel_monitor_archival_height
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::NodeStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::NodeStatus>>
    for ldk_adapter::types::NodeStatus
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::NodeStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Offer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Offer> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Offer>> for shared::Offer {
    fn into_into_dart(self) -> FrbWrapper<shared::Offer> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::OfferId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::OfferId>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::OfferId>>
    for ldk_adapter::types::OfferId
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::OfferId> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::OutPoint> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.txid.into_into_dart().into_dart(),
            self.0.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::OutPoint> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::OutPoint>> for shared::OutPoint {
    fn into_into_dart(self) -> FrbWrapper<shared::OutPoint> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.id.into_into_dart().into_dart(),
            self.0.kind.into_into_dart().into_dart(),
            self.0.amount_msat.into_into_dart().into_dart(),
            self.0.direction.into_into_dart().into_dart(),
            self.0.status.into_into_dart().into_dart(),
            self.0.latest_update_timestamp.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentDetails>>
    for ldk_adapter::types::PaymentDetails
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentDirection> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::PaymentDirection::Inbound => 0.into_dart(),
            ldk_adapter::types::PaymentDirection::Outbound => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentDirection>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentDirection>>
    for ldk_adapter::types::PaymentDirection
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentDirection> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentFailureReason> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::PaymentFailureReason::RecipientRejected => 0.into_dart(),
            ldk_adapter::types::PaymentFailureReason::UserAbandoned => 1.into_dart(),
            ldk_adapter::types::PaymentFailureReason::RetriesExhausted => 2.into_dart(),
            ldk_adapter::types::PaymentFailureReason::PaymentExpired => 3.into_dart(),
            ldk_adapter::types::PaymentFailureReason::RouteNotFound => 4.into_dart(),
            ldk_adapter::types::PaymentFailureReason::UnexpectedError => 5.into_dart(),
            ldk_adapter::types::PaymentFailureReason::UnknownRequiredFeatures => 6.into_dart(),
            ldk_adapter::types::PaymentFailureReason::InvoiceRequestExpired => 7.into_dart(),
            ldk_adapter::types::PaymentFailureReason::InvoiceRequestRejected => 8.into_dart(),
            ldk_adapter::types::PaymentFailureReason::BlindedPathCreationFailed => 9.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentFailureReason>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentFailureReason>>
    for ldk_adapter::types::PaymentFailureReason
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentFailureReason> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::PaymentHash> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::PaymentHash>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::PaymentHash>> for shared::PaymentHash {
    fn into_into_dart(self) -> FrbWrapper<shared::PaymentHash> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::PaymentId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::PaymentId> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::PaymentId>> for shared::PaymentId {
    fn into_into_dart(self) -> FrbWrapper<shared::PaymentId> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentKind> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::PaymentKind::Onchain { txid, status } => [
                0.into_dart(),
                txid.into_into_dart().into_dart(),
                status.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::PaymentKind::Bolt11 {
                hash,
                preimage,
                secret,
            } => [
                1.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::PaymentKind::Bolt11Jit {
                hash,
                preimage,
                secret,
                lsp_fee_limits,
                counterparty_skimmed_fee_msat,
            } => [
                2.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
                lsp_fee_limits.into_into_dart().into_dart(),
                counterparty_skimmed_fee_msat.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::PaymentKind::Spontaneous { hash, preimage } => [
                3.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::PaymentKind::Bolt12Offer {
                hash,
                preimage,
                secret,
                offer_id,
                payer_note,
                quantity,
            } => [
                4.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
                offer_id.into_into_dart().into_dart(),
                payer_note.into_into_dart().into_dart(),
                quantity.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::PaymentKind::Bolt12Refund {
                hash,
                preimage,
                secret,
                payer_note,
                quantity,
            } => [
                5.into_dart(),
                hash.into_into_dart().into_dart(),
                preimage.into_into_dart().into_dart(),
                secret.into_into_dart().into_dart(),
                payer_note.into_into_dart().into_dart(),
                quantity.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentKind>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentKind>>
    for ldk_adapter::types::PaymentKind
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentKind> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::PaymentPreimage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::PaymentPreimage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::PaymentPreimage>>
    for shared::PaymentPreimage
{
    fn into_into_dart(self) -> FrbWrapper<shared::PaymentPreimage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentSecret> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentSecret>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentSecret>>
    for ldk_adapter::types::PaymentSecret
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentSecret> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::PaymentStatus::Pending => 0.into_dart(),
            ldk_adapter::types::PaymentStatus::Succeeded => 1.into_dart(),
            ldk_adapter::types::PaymentStatus::Failed => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentStatus>>
    for ldk_adapter::types::PaymentStatus
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PendingSweepBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::PendingSweepBalance::PendingBroadcast {
                channel_id,
                amount_satoshis,
            } => [
                0.into_dart(),
                channel_id.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                channel_id,
                latest_broadcast_height,
                latest_spending_txid,
                amount_satoshis,
            } => [
                1.into_dart(),
                channel_id.into_into_dart().into_dart(),
                latest_broadcast_height.into_into_dart().into_dart(),
                latest_spending_txid.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            ldk_adapter::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                channel_id,
                latest_spending_txid,
                confirmation_hash,
                confirmation_height,
                amount_satoshis,
            } => [
                2.into_dart(),
                channel_id.into_into_dart().into_dart(),
                latest_spending_txid.into_into_dart().into_dart(),
                confirmation_hash.into_into_dart().into_dart(),
                confirmation_height.into_into_dart().into_dart(),
                amount_satoshis.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PendingSweepBalance>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PendingSweepBalance>>
    for ldk_adapter::types::PendingSweepBalance
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PendingSweepBalance> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Psbt> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.inner.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Psbt> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Psbt>> for shared::Psbt {
    fn into_into_dart(self) -> FrbWrapper<shared::Psbt> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Refund> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Refund> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Refund>> for shared::Refund {
    fn into_into_dart(self) -> FrbWrapper<shared::Refund> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::RoutingFees> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.base_msat.into_into_dart().into_dart(),
            self.0.proportional_millionths.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::RoutingFees>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::RoutingFees>>
    for ldk_adapter::graph::RoutingFees
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::RoutingFees> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::ScriptBuf> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.inner.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::ScriptBuf> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::ScriptBuf>> for shared::ScriptBuf {
    fn into_into_dart(self) -> FrbWrapper<shared::ScriptBuf> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::SendingParameters> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .max_total_routing_fee_msat
                .into_into_dart()
                .into_dart(),
            self.0
                .max_total_cltv_expiry_delta
                .into_into_dart()
                .into_dart(),
            self.0.max_path_count.into_into_dart().into_dart(),
            self.0
                .max_channel_saturation_power_of_half
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::SendingParameters>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::SendingParameters>>
    for shared::SendingParameters
{
    fn into_into_dart(self) -> FrbWrapper<shared::SendingParameters> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::TxIn> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.previous_output.into_into_dart().into_dart(),
            self.0.script_sig.into_into_dart().into_dart(),
            self.0.sequence.into_into_dart().into_dart(),
            self.0.witness.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::TxIn> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::TxIn>> for shared::TxIn {
    fn into_into_dart(self) -> FrbWrapper<shared::TxIn> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::TxOut> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.value.into_into_dart().into_dart(),
            self.0.script_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::TxOut> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::TxOut>> for shared::TxOut {
    fn into_into_dart(self) -> FrbWrapper<shared::TxOut> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Txid> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.hash.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Txid> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Txid>> for shared::Txid {
    fn into_into_dart(self) -> FrbWrapper<shared::Txid> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::WTxid> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.hash.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::WTxid> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::WTxid>> for shared::WTxid {
    fn into_into_dart(self) -> FrbWrapper<shared::WTxid> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::WitnessProgram> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.version.into_into_dart().into_dart(),
            self.0.program.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::WitnessProgram>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::WitnessProgram>>
    for shared::WitnessProgram
{
    fn into_into_dart(self) -> FrbWrapper<shared::WitnessProgram> {
        self.into()
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for AddressData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for AnchorChannelsConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for BitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for BitcoinAddressInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for BitcoinTransactionInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Bolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Bolt12Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ConfirmationStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfirmationStatus>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for LdkBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for NetworkGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Node {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for OnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for QrPaymentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for SpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for TaprootSpendInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for TaprootSpendInfoInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Transaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for UnifiedQrPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfirmationStatus>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for ldk_adapter::types::BackgroundSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.onchain_wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.lightning_wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.fee_rate_cache_update_interval_secs, serializer);
    }
}

impl SseEncode for ldk_adapter::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.total_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.spendable_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.total_lightning_balance_sats, serializer);
        <Vec<ldk_adapter::types::LightningBalance>>::sse_encode(
            self.lightning_balances,
            serializer,
        );
        <Vec<ldk_adapter::types::PendingSweepBalance>>::sse_encode(
            self.pending_balances_from_channel_closures,
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::BalanceSource {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::BalanceSource::HolderForceClosed => 0,
                ldk_adapter::types::BalanceSource::CounterpartyForceClosed => 1,
                ldk_adapter::types::BalanceSource::CoopClose => 2,
                ldk_adapter::types::BalanceSource::Htlc => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.block_hash, serializer);
        <u32>::sse_encode(self.height, serializer);
    }
}

impl SseEncode for shared::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.signed_raw_invoice, serializer);
    }
}

impl SseEncode for shared::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for ldk_adapter::types::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            ldk_adapter::types::ChainDataSourceConfig::Esplora {
                server_url,
                sync_config,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(server_url, serializer);
                <Option<ldk_adapter::types::EsploraSyncConfig>>::sse_encode(
                    sync_config,
                    serializer,
                );
            }
            ldk_adapter::types::ChainDataSourceConfig::Electrum {
                server_url,
                sync_config,
            } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(server_url, serializer);
                <Option<ldk_adapter::types::ElectrumSyncConfig>>::sse_encode(
                    sync_config,
                    serializer,
                );
            }
            ldk_adapter::types::ChainDataSourceConfig::BitcoindRpc {
                rpc_host,
                rpc_port,
                rpc_user,
                rpc_password,
            } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(rpc_host, serializer);
                <u16>::sse_encode(rpc_port, serializer);
                <String>::sse_encode(rpc_user, serializer);
                <String>::sse_encode(rpc_password, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for ldk_adapter::graph::ChannelInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <ldk_adapter::graph::NodeId>::sse_encode(self.node_one, serializer);
        <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_encode(self.one_to_two, serializer);
        <ldk_adapter::graph::NodeId>::sse_encode(self.node_two, serializer);
        <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_encode(self.two_to_one, serializer);
        <Option<u64>>::sse_encode(self.capacity_sats, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::ChannelUpdateInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.last_update, serializer);
        <bool>::sse_encode(self.enabled, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.htlc_minimum_msat, serializer);
        <u64>::sse_encode(self.htlc_maximum_msat, serializer);
        <ldk_adapter::graph::RoutingFees>::sse_encode(self.fees, serializer);
    }
}

impl SseEncode for ldk_adapter::types::ClosureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            ldk_adapter::types::ClosureReason::PeerFeerateTooLow {
                peer_feerate_sat_per_kw,
                required_feerate_sat_per_kw,
            } => {
                <i32>::sse_encode(0, serializer);
                <u32>::sse_encode(peer_feerate_sat_per_kw, serializer);
                <u32>::sse_encode(required_feerate_sat_per_kw, serializer);
            }
            ldk_adapter::types::ClosureReason::CounterpartyForceClosed { peer_msg } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(peer_msg, serializer);
            }
            ldk_adapter::types::ClosureReason::HolderForceClosed {
                broadcasted_latest_txn,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<bool>>::sse_encode(broadcasted_latest_txn, serializer);
            }
            ldk_adapter::types::ClosureReason::LegacyCooperativeClosure => {
                <i32>::sse_encode(3, serializer);
            }
            ldk_adapter::types::ClosureReason::CounterpartyInitiatedCooperativeClosure => {
                <i32>::sse_encode(4, serializer);
            }
            ldk_adapter::types::ClosureReason::LocallyInitiatedCooperativeClosure => {
                <i32>::sse_encode(5, serializer);
            }
            ldk_adapter::types::ClosureReason::CommitmentTxConfirmed => {
                <i32>::sse_encode(6, serializer);
            }
            ldk_adapter::types::ClosureReason::FundingTimedOut => {
                <i32>::sse_encode(7, serializer);
            }
            ldk_adapter::types::ClosureReason::ProcessingError { err } => {
                <i32>::sse_encode(8, serializer);
                <String>::sse_encode(err, serializer);
            }
            ldk_adapter::types::ClosureReason::DisconnectedPeer => {
                <i32>::sse_encode(9, serializer);
            }
            ldk_adapter::types::ClosureReason::OutdatedChannelManager => {
                <i32>::sse_encode(10, serializer);
            }
            ldk_adapter::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel => {
                <i32>::sse_encode(11, serializer);
            }
            ldk_adapter::types::ClosureReason::FundingBatchClosure => {
                <i32>::sse_encode(12, serializer);
            }
            ldk_adapter::types::ClosureReason::HTLCsTimedOut => {
                <i32>::sse_encode(13, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for ldk_adapter::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.storage_dir_path, serializer);
        <shared::Network>::sse_encode(self.network, serializer);
        <Option<Vec<SocketAddress>>>::sse_encode(self.listening_addresses, serializer);
        <Option<Vec<SocketAddress>>>::sse_encode(self.announcement_addresses, serializer);
        <Option<ldk_adapter::types::NodeAlias>>::sse_encode(self.node_alias, serializer);
        <Vec<PublicKey>>::sse_encode(self.trusted_peers_0conf, serializer);
        <u64>::sse_encode(self.probing_liquidity_limit_multiplier, serializer);
        <Option<AnchorChannelsConfig>>::sse_encode(self.anchor_channels_config, serializer);
        <Option<shared::SendingParameters>>::sse_encode(self.sending_parameters, serializer);
    }
}

impl SseEncode for ldk_adapter::types::CustomTlvRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.type_num, serializer);
        <Vec<u8>>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for ldk_adapter::types::ElectrumSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<ldk_adapter::types::BackgroundSyncConfig>>::sse_encode(
            self.background_sync_config,
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            ldk_adapter::types::EntropySourceConfig::SeedFile(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            ldk_adapter::types::EntropySourceConfig::SeedBytes(field0) => {
                <i32>::sse_encode(1, serializer);
                <[u8; 64]>::sse_encode(field0, serializer);
            }
            ldk_adapter::types::EntropySourceConfig::Bip39Mnemonic {
                mnemonic,
                passphrase,
            } => {
                <i32>::sse_encode(2, serializer);
                <shared::Mnemonic>::sse_encode(mnemonic, serializer);
                <Option<String>>::sse_encode(passphrase, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for ldk_adapter::types::EsploraSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<ldk_adapter::types::BackgroundSyncConfig>>::sse_encode(
            self.background_sync_config,
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            ldk_adapter::types::Event::PaymentClaimable {
                payment_id,
                payment_hash,
                claimable_amount_msat,
                claim_deadline,
                custom_records,
            } => {
                <i32>::sse_encode(0, serializer);
                <shared::PaymentId>::sse_encode(payment_id, serializer);
                <shared::PaymentHash>::sse_encode(payment_hash, serializer);
                <u64>::sse_encode(claimable_amount_msat, serializer);
                <Option<u32>>::sse_encode(claim_deadline, serializer);
                <Vec<ldk_adapter::types::CustomTlvRecord>>::sse_encode(custom_records, serializer);
            }
            ldk_adapter::types::Event::PaymentSuccessful {
                payment_id,
                payment_hash,
                fee_paid_msat,
                preimage,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<shared::PaymentId>>::sse_encode(payment_id, serializer);
                <shared::PaymentHash>::sse_encode(payment_hash, serializer);
                <Option<u64>>::sse_encode(fee_paid_msat, serializer);
                <Option<shared::PaymentPreimage>>::sse_encode(preimage, serializer);
            }
            ldk_adapter::types::Event::PaymentFailed {
                payment_id,
                payment_hash,
                reason,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<shared::PaymentId>>::sse_encode(payment_id, serializer);
                <Option<shared::PaymentHash>>::sse_encode(payment_hash, serializer);
                <Option<ldk_adapter::types::PaymentFailureReason>>::sse_encode(reason, serializer);
            }
            ldk_adapter::types::Event::PaymentReceived {
                payment_id,
                payment_hash,
                amount_msat,
                custom_records,
            } => {
                <i32>::sse_encode(3, serializer);
                <Option<shared::PaymentId>>::sse_encode(payment_id, serializer);
                <shared::PaymentHash>::sse_encode(payment_hash, serializer);
                <u64>::sse_encode(amount_msat, serializer);
                <Vec<ldk_adapter::types::CustomTlvRecord>>::sse_encode(custom_records, serializer);
            }
            ldk_adapter::types::Event::ChannelPending {
                channel_id,
                user_channel_id,
                former_temporary_channel_id,
                counterparty_node_id,
                funding_txo,
            } => {
                <i32>::sse_encode(4, serializer);
                <ChannelId>::sse_encode(channel_id, serializer);
                <UserChannelId>::sse_encode(user_channel_id, serializer);
                <ChannelId>::sse_encode(former_temporary_channel_id, serializer);
                <PublicKey>::sse_encode(counterparty_node_id, serializer);
                <shared::OutPoint>::sse_encode(funding_txo, serializer);
            }
            ldk_adapter::types::Event::ChannelReady {
                channel_id,
                user_channel_id,
                counterparty_node_id,
            } => {
                <i32>::sse_encode(5, serializer);
                <ChannelId>::sse_encode(channel_id, serializer);
                <UserChannelId>::sse_encode(user_channel_id, serializer);
                <Option<PublicKey>>::sse_encode(counterparty_node_id, serializer);
            }
            ldk_adapter::types::Event::ChannelClosed {
                channel_id,
                user_channel_id,
                counterparty_node_id,
                reason,
            } => {
                <i32>::sse_encode(6, serializer);
                <ChannelId>::sse_encode(channel_id, serializer);
                <UserChannelId>::sse_encode(user_channel_id, serializer);
                <Option<PublicKey>>::sse_encode(counterparty_node_id, serializer);
                <Option<ldk_adapter::types::ClosureReason>>::sse_encode(reason, serializer);
            }
            ldk_adapter::types::Event::PaymentForwarded {
                prev_channel_id,
                next_channel_id,
                prev_user_channel_id,
                next_user_channel_id,
                prev_node_id,
                next_node_id,
                total_fee_earned_msat,
                skimmed_fee_msat,
                claim_from_onchain_tx,
                outbound_amount_forwarded_msat,
            } => {
                <i32>::sse_encode(7, serializer);
                <ChannelId>::sse_encode(prev_channel_id, serializer);
                <ChannelId>::sse_encode(next_channel_id, serializer);
                <Option<UserChannelId>>::sse_encode(prev_user_channel_id, serializer);
                <Option<UserChannelId>>::sse_encode(next_user_channel_id, serializer);
                <Option<PublicKey>>::sse_encode(prev_node_id, serializer);
                <Option<PublicKey>>::sse_encode(next_node_id, serializer);
                <Option<u64>>::sse_encode(total_fee_earned_msat, serializer);
                <Option<u64>>::sse_encode(skimmed_fee_msat, serializer);
                <bool>::sse_encode(claim_from_onchain_tx, serializer);
                <Option<u64>>::sse_encode(outbound_amount_forwarded_msat, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for ldk_adapter::types::FfiLogRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <ldk_adapter::types::LogLevel>::sse_encode(self.level, serializer);
        <String>::sse_encode(self.args, serializer);
        <String>::sse_encode(self.module_path, serializer);
        <u32>::sse_encode(self.line, serializer);
    }
}

impl SseEncode for ldk_adapter::types::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            ldk_adapter::types::GossipSourceConfig::P2PNetwork => {
                <i32>::sse_encode(0, serializer);
            }
            ldk_adapter::types::GossipSourceConfig::RapidGossipSync(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for ldk_adapter::types::LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            ldk_adapter::types::LightningBalance::ClaimableOnChannelClose {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                transaction_fee_satoshis,
                outbound_payment_htlc_rounded_msat,
                outbound_forwarded_htlc_rounded_msat,
                inbound_claiming_htlc_rounded_msat,
                inbound_htlc_rounded_msat,
            } => {
                <i32>::sse_encode(0, serializer);
                <ChannelId>::sse_encode(channel_id, serializer);
                <PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u64>::sse_encode(transaction_fee_satoshis, serializer);
                <u64>::sse_encode(outbound_payment_htlc_rounded_msat, serializer);
                <u64>::sse_encode(outbound_forwarded_htlc_rounded_msat, serializer);
                <u64>::sse_encode(inbound_claiming_htlc_rounded_msat, serializer);
                <u64>::sse_encode(inbound_htlc_rounded_msat, serializer);
            }
            ldk_adapter::types::LightningBalance::ClaimableAwaitingConfirmations {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                confirmation_height,
                source,
            } => {
                <i32>::sse_encode(1, serializer);
                <ChannelId>::sse_encode(channel_id, serializer);
                <PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(confirmation_height, serializer);
                <ldk_adapter::types::BalanceSource>::sse_encode(source, serializer);
            }
            ldk_adapter::types::LightningBalance::ContentiousClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                timeout_height,
                payment_hash,
                payment_preimage,
            } => {
                <i32>::sse_encode(2, serializer);
                <ChannelId>::sse_encode(channel_id, serializer);
                <PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(timeout_height, serializer);
                <shared::PaymentHash>::sse_encode(payment_hash, serializer);
                <shared::PaymentPreimage>::sse_encode(payment_preimage, serializer);
            }
            ldk_adapter::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                claimable_height,
                payment_hash,
                outbound_payment,
            } => {
                <i32>::sse_encode(3, serializer);
                <ChannelId>::sse_encode(channel_id, serializer);
                <PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(claimable_height, serializer);
                <shared::PaymentHash>::sse_encode(payment_hash, serializer);
                <bool>::sse_encode(outbound_payment, serializer);
            }
            ldk_adapter::types::LightningBalance::MaybePreimageClaimableHTLC {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
                expiry_height,
                payment_hash,
            } => {
                <i32>::sse_encode(4, serializer);
                <ChannelId>::sse_encode(channel_id, serializer);
                <PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
                <u32>::sse_encode(expiry_height, serializer);
                <shared::PaymentHash>::sse_encode(payment_hash, serializer);
            }
            ldk_adapter::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                channel_id,
                counterparty_node_id,
                amount_satoshis,
            } => {
                <i32>::sse_encode(5, serializer);
                <ChannelId>::sse_encode(channel_id, serializer);
                <PublicKey>::sse_encode(counterparty_node_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for ldk_adapter::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <(SocketAddress, PublicKey, Option<String>)>::sse_encode(self.lsps2_service, serializer);
    }
}

impl SseEncode for Vec<ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ChannelDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <PeerDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <PublicKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <SocketAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ldk_adapter::types::CustomTlvRecord> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ldk_adapter::types::CustomTlvRecord>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ldk_adapter::types::LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ldk_adapter::types::LightningBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<u8>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ldk_adapter::graph::NodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ldk_adapter::graph::NodeId>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ldk_adapter::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ldk_adapter::types::PaymentDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ldk_adapter::types::PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ldk_adapter::types::PendingSweepBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<shared::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <shared::TxIn>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<shared::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <shared::TxOut>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for ldk_adapter::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::LogLevel::Gossip => 0,
                ldk_adapter::types::LogLevel::Trace => 1,
                ldk_adapter::types::LogLevel::Debug => 2,
                ldk_adapter::types::LogLevel::Info => 3,
                ldk_adapter::types::LogLevel::Warn => 4,
                ldk_adapter::types::LogLevel::Error => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::LSPFeeLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.max_total_opening_fee_msat, serializer);
        <Option<u64>>::sse_encode(self.max_proportional_opening_fee_ppm_msat, serializer);
    }
}

impl SseEncode for shared::Mnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.words, serializer);
    }
}

impl SseEncode for shared::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                shared::Network::Bitcoin => 0,
                shared::Network::Testnet => 1,
                shared::Network::Testnet4 => 2,
                shared::Network::Signet => 3,
                shared::Network::Regtest => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::NodeAlias {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::NodeAnnouncementInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.last_update, serializer);
        <String>::sse_encode(self.alias, serializer);
        <Vec<SocketAddress>>::sse_encode(self.addresses, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::NodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.compressed, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::NodeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u64>>::sse_encode(self.channels, serializer);
        <Option<ldk_adapter::graph::NodeAnnouncementInfo>>::sse_encode(
            self.announcement_info,
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_running, serializer);
        <bool>::sse_encode(self.is_listening, serializer);
        <ldk_adapter::types::BestBlock>::sse_encode(self.current_best_block, serializer);
        <Option<u64>>::sse_encode(self.latest_lightning_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_onchain_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_fee_rate_cache_update_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_rgs_snapshot_timestamp, serializer);
        <Option<u64>>::sse_encode(
            self.latest_node_announcement_broadcast_timestamp,
            serializer,
        );
        <Option<u32>>::sse_encode(self.latest_channel_monitor_archival_height, serializer);
    }
}

impl SseEncode for shared::Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for ldk_adapter::types::OfferId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<AnchorChannelsConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <AnchorChannelsConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ChannelConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ChannelId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <PublicKey>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<UserChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <UserChannelId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::BackgroundSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::BackgroundSyncConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::ChainDataSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::ChannelInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::ChannelInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::ChannelUpdateInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::ChannelUpdateInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::ClosureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::ClosureReason>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::ElectrumSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::ElectrumSyncConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::EntropySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::EsploraSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::EsploraSyncConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::Event>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::GossipSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::LiquiditySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::LogLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::LogLevel>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::NodeAlias> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::NodeAlias>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::NodeAnnouncementInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::NodeAnnouncementInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::NodeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::NodeInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::OfferId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::OfferId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<shared::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <shared::OutPoint>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::PaymentDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::PaymentFailureReason> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::PaymentFailureReason>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<shared::PaymentHash> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <shared::PaymentHash>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<shared::PaymentId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <shared::PaymentId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<shared::PaymentPreimage> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <shared::PaymentPreimage>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::PaymentSecret>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<shared::SendingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <shared::SendingParameters>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u16>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<SocketAddress>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for shared::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <shared::Txid>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for ldk_adapter::types::PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <shared::PaymentId>::sse_encode(self.id, serializer);
        <ldk_adapter::types::PaymentKind>::sse_encode(self.kind, serializer);
        <Option<u64>>::sse_encode(self.amount_msat, serializer);
        <ldk_adapter::types::PaymentDirection>::sse_encode(self.direction, serializer);
        <ldk_adapter::types::PaymentStatus>::sse_encode(self.status, serializer);
        <u64>::sse_encode(self.latest_update_timestamp, serializer);
    }
}

impl SseEncode for ldk_adapter::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::PaymentDirection::Inbound => 0,
                ldk_adapter::types::PaymentDirection::Outbound => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::PaymentFailureReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::PaymentFailureReason::RecipientRejected => 0,
                ldk_adapter::types::PaymentFailureReason::UserAbandoned => 1,
                ldk_adapter::types::PaymentFailureReason::RetriesExhausted => 2,
                ldk_adapter::types::PaymentFailureReason::PaymentExpired => 3,
                ldk_adapter::types::PaymentFailureReason::RouteNotFound => 4,
                ldk_adapter::types::PaymentFailureReason::UnexpectedError => 5,
                ldk_adapter::types::PaymentFailureReason::UnknownRequiredFeatures => 6,
                ldk_adapter::types::PaymentFailureReason::InvoiceRequestExpired => 7,
                ldk_adapter::types::PaymentFailureReason::InvoiceRequestRejected => 8,
                ldk_adapter::types::PaymentFailureReason::BlindedPathCreationFailed => 9,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for shared::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for shared::PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for ldk_adapter::types::PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            ldk_adapter::types::PaymentKind::Onchain { txid, status } => {
                <i32>::sse_encode(0, serializer);
                <shared::Txid>::sse_encode(txid, serializer);
                <ConfirmationStatus>::sse_encode(status, serializer);
            }
            ldk_adapter::types::PaymentKind::Bolt11 {
                hash,
                preimage,
                secret,
            } => {
                <i32>::sse_encode(1, serializer);
                <shared::PaymentHash>::sse_encode(hash, serializer);
                <Option<shared::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<ldk_adapter::types::PaymentSecret>>::sse_encode(secret, serializer);
            }
            ldk_adapter::types::PaymentKind::Bolt11Jit {
                hash,
                preimage,
                secret,
                lsp_fee_limits,
                counterparty_skimmed_fee_msat,
            } => {
                <i32>::sse_encode(2, serializer);
                <shared::PaymentHash>::sse_encode(hash, serializer);
                <Option<shared::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<ldk_adapter::types::PaymentSecret>>::sse_encode(secret, serializer);
                <ldk_adapter::types::LSPFeeLimits>::sse_encode(lsp_fee_limits, serializer);
                <Option<u64>>::sse_encode(counterparty_skimmed_fee_msat, serializer);
            }
            ldk_adapter::types::PaymentKind::Spontaneous { hash, preimage } => {
                <i32>::sse_encode(3, serializer);
                <shared::PaymentHash>::sse_encode(hash, serializer);
                <Option<shared::PaymentPreimage>>::sse_encode(preimage, serializer);
            }
            ldk_adapter::types::PaymentKind::Bolt12Offer {
                hash,
                preimage,
                secret,
                offer_id,
                payer_note,
                quantity,
            } => {
                <i32>::sse_encode(4, serializer);
                <Option<shared::PaymentHash>>::sse_encode(hash, serializer);
                <Option<shared::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<ldk_adapter::types::PaymentSecret>>::sse_encode(secret, serializer);
                <ldk_adapter::types::OfferId>::sse_encode(offer_id, serializer);
                <Option<String>>::sse_encode(payer_note, serializer);
                <Option<u64>>::sse_encode(quantity, serializer);
            }
            ldk_adapter::types::PaymentKind::Bolt12Refund {
                hash,
                preimage,
                secret,
                payer_note,
                quantity,
            } => {
                <i32>::sse_encode(5, serializer);
                <Option<shared::PaymentHash>>::sse_encode(hash, serializer);
                <Option<shared::PaymentPreimage>>::sse_encode(preimage, serializer);
                <Option<ldk_adapter::types::PaymentSecret>>::sse_encode(secret, serializer);
                <Option<String>>::sse_encode(payer_note, serializer);
                <Option<u64>>::sse_encode(quantity, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for shared::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for ldk_adapter::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for ldk_adapter::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::PaymentStatus::Pending => 0,
                ldk_adapter::types::PaymentStatus::Succeeded => 1,
                ldk_adapter::types::PaymentStatus::Failed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            ldk_adapter::types::PendingSweepBalance::PendingBroadcast {
                channel_id,
                amount_satoshis,
            } => {
                <i32>::sse_encode(0, serializer);
                <Option<ChannelId>>::sse_encode(channel_id, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            ldk_adapter::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                channel_id,
                latest_broadcast_height,
                latest_spending_txid,
                amount_satoshis,
            } => {
                <i32>::sse_encode(1, serializer);
                <Option<ChannelId>>::sse_encode(channel_id, serializer);
                <u32>::sse_encode(latest_broadcast_height, serializer);
                <shared::Txid>::sse_encode(latest_spending_txid, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            ldk_adapter::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                channel_id,
                latest_spending_txid,
                confirmation_hash,
                confirmation_height,
                amount_satoshis,
            } => {
                <i32>::sse_encode(2, serializer);
                <Option<ChannelId>>::sse_encode(channel_id, serializer);
                <shared::Txid>::sse_encode(latest_spending_txid, serializer);
                <String>::sse_encode(confirmation_hash, serializer);
                <u32>::sse_encode(confirmation_height, serializer);
                <u64>::sse_encode(amount_satoshis, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for shared::Psbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for (SocketAddress, PublicKey, Option<String>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <SocketAddress>::sse_encode(self.0, serializer);
        <PublicKey>::sse_encode(self.1, serializer);
        <Option<String>>::sse_encode(self.2, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for shared::Refund {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::RoutingFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.base_msat, serializer);
        <u32>::sse_encode(self.proportional_millionths, serializer);
    }
}

impl SseEncode for shared::ScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for shared::SendingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.max_total_routing_fee_msat, serializer);
        <Option<u32>>::sse_encode(self.max_total_cltv_expiry_delta, serializer);
        <Option<u8>>::sse_encode(self.max_path_count, serializer);
        <Option<u8>>::sse_encode(self.max_channel_saturation_power_of_half, serializer);
    }
}

impl SseEncode for shared::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <shared::OutPoint>::sse_encode(self.previous_output, serializer);
        <shared::ScriptBuf>::sse_encode(self.script_sig, serializer);
        <u32>::sse_encode(self.sequence, serializer);
        <Vec<Vec<u8>>>::sse_encode(self.witness, serializer);
    }
}

impl SseEncode for shared::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.value, serializer);
        <shared::ScriptBuf>::sse_encode(self.script_pubkey, serializer);
    }
}

impl SseEncode for shared::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for shared::WTxid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
    }
}

impl SseEncode for shared::WitnessProgram {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.version, serializer);
        <Vec<u8>>::sse_encode(self.program, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};
    use ldk_adapter::bolt11::*;
    use ldk_adapter::bolt12::*;
    use ldk_adapter::builder::*;
    use ldk_adapter::graph::*;
    use ldk_adapter::node::*;
    use ldk_adapter::on_chain::*;
    use ldk_adapter::spontaneous::*;
    use ldk_adapter::types::*;
    use ldk_adapter::unified_qr::*;
    use shared::*;

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<AddressData> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> AddressData {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<AnchorChannelsConfig> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> AnchorChannelsConfig {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<BitcoinAddress> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> BitcoinAddress {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<BitcoinAddressInner> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> BitcoinAddressInner {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<BitcoinTransactionInner> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> BitcoinTransactionInner {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                        BitcoinTransactionInner,
                    >,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Bolt11Payment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Bolt11Payment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Bolt12Payment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Bolt12Payment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ChannelConfig> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelConfig {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ChannelDetails> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelDetails {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ChannelId> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ConfirmationStatus> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ConfirmationStatus {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfirmationStatus>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<LdkBuilder> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> LdkBuilder {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<MaxDustHTLCExposure> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> MaxDustHTLCExposure {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<NetworkGraph> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> NetworkGraph {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Node> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Node {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<OnChainPayment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> OnChainPayment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PeerDetails> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PeerDetails {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PublicKey> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PublicKey {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<QrPaymentResult> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> QrPaymentResult {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<SocketAddress> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> SocketAddress {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<SpontaneousPayment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> SpontaneousPayment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<TaprootSpendInfo> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> TaprootSpendInfo {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<TaprootSpendInfoInner> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> TaprootSpendInfoInner {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Transaction> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Transaction {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<UnifiedQrPayment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> UnifiedQrPayment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<UserChannelId> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> UserChannelId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<std::collections::HashMap<String, String>>
        for *mut wire_cst_list_record_string_string
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> std::collections::HashMap<String, String> {
            let vec: Vec<(String, String)> = self.cst_decode();
            vec.into_iter().collect()
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfirmationStatus>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfirmationStatus>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<ldk_adapter::types::BackgroundSyncConfig> for wire_cst_background_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::BackgroundSyncConfig {
            ldk_adapter::types::BackgroundSyncConfig {
                onchain_wallet_sync_interval_secs: self
                    .onchain_wallet_sync_interval_secs
                    .cst_decode(),
                lightning_wallet_sync_interval_secs: self
                    .lightning_wallet_sync_interval_secs
                    .cst_decode(),
                fee_rate_cache_update_interval_secs: self
                    .fee_rate_cache_update_interval_secs
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::BalanceDetails> for wire_cst_balance_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::BalanceDetails {
            ldk_adapter::types::BalanceDetails {
                total_onchain_balance_sats: self.total_onchain_balance_sats.cst_decode(),
                spendable_onchain_balance_sats: self.spendable_onchain_balance_sats.cst_decode(),
                total_lightning_balance_sats: self.total_lightning_balance_sats.cst_decode(),
                lightning_balances: self.lightning_balances.cst_decode(),
                pending_balances_from_channel_closures: self
                    .pending_balances_from_channel_closures
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::BestBlock> for wire_cst_best_block {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::BestBlock {
            ldk_adapter::types::BestBlock {
                block_hash: self.block_hash.cst_decode(),
                height: self.height.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Bolt11Invoice> for wire_cst_bolt_11_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Bolt11Invoice {
            shared::Bolt11Invoice {
                signed_raw_invoice: self.signed_raw_invoice.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Bolt12Invoice> for wire_cst_bolt_12_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Bolt12Invoice {
            shared::Bolt12Invoice {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<AnchorChannelsConfig> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> AnchorChannelsConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<AnchorChannelsConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ChannelConfig> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ChannelConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ChannelId> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ChannelId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<PublicKey> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PublicKey {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<PublicKey>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<UserChannelId> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> UserChannelId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<UserChannelId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::BackgroundSyncConfig> for *mut wire_cst_background_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::BackgroundSyncConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::BackgroundSyncConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Bolt11Invoice> for *mut wire_cst_bolt_11_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Bolt11Invoice {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Bolt11Invoice>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<bool> for *mut bool {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<ldk_adapter::types::ChainDataSourceConfig>
        for *mut wire_cst_chain_data_source_config
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::ChainDataSourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::ChainDataSourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelInfo> for *mut wire_cst_channel_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::ChannelInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelUpdateInfo> for *mut wire_cst_channel_update_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelUpdateInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::ChannelUpdateInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::ClosureReason> for *mut wire_cst_closure_reason {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::ClosureReason {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::ClosureReason>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::Config> for *mut wire_cst_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::Config {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::Config>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::CustomTlvRecord> for *mut wire_cst_custom_tlv_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::CustomTlvRecord {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::CustomTlvRecord>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::ElectrumSyncConfig> for *mut wire_cst_electrum_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::ElectrumSyncConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::ElectrumSyncConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::EntropySourceConfig> for *mut wire_cst_entropy_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::EntropySourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::EntropySourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::EsploraSyncConfig> for *mut wire_cst_esplora_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::EsploraSyncConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::EsploraSyncConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::Event> for *mut wire_cst_event {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::Event {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::Event>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::FfiLogRecord> for *mut wire_cst_ffi_log_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::FfiLogRecord {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::FfiLogRecord>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::GossipSourceConfig> for *mut wire_cst_gossip_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::GossipSourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::GossipSourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::LiquiditySourceConfig>
        for *mut wire_cst_liquidity_source_config
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LiquiditySourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::LiquiditySourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::LogLevel> for *mut i32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LogLevel {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::LogLevel>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::LSPFeeLimits> for *mut wire_cst_lsp_fee_limits {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LSPFeeLimits {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::LSPFeeLimits>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Mnemonic> for *mut wire_cst_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Mnemonic {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Mnemonic>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::NodeAlias> for *mut wire_cst_node_alias {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::NodeAlias {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::NodeAlias>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeAnnouncementInfo> for *mut wire_cst_node_announcement_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeAnnouncementInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::NodeAnnouncementInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeId> for *mut wire_cst_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::NodeId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeInfo> for *mut wire_cst_node_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::NodeInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Offer> for *mut wire_cst_offer {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Offer {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Offer>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::OfferId> for *mut wire_cst_offer_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::OfferId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::OfferId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::OutPoint> for *mut wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::OutPoint {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::OutPoint>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::PaymentDetails> for *mut wire_cst_payment_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::PaymentDetails {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::PaymentDetails>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::PaymentFailureReason> for *mut i32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::PaymentFailureReason {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::PaymentFailureReason>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::PaymentHash> for *mut wire_cst_payment_hash {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentHash {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::PaymentHash>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::PaymentId> for *mut wire_cst_payment_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::PaymentId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::PaymentKind> for *mut wire_cst_payment_kind {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::PaymentKind {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::PaymentKind>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::PaymentPreimage> for *mut wire_cst_payment_preimage {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentPreimage {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::PaymentPreimage>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::PaymentSecret> for *mut wire_cst_payment_secret {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::PaymentSecret {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::PaymentSecret>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Psbt> for *mut wire_cst_psbt {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Psbt {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Psbt>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Refund> for *mut wire_cst_refund {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Refund {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Refund>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::ScriptBuf> for *mut wire_cst_script_buf {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::ScriptBuf {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::ScriptBuf>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::SendingParameters> for *mut wire_cst_sending_parameters {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::SendingParameters {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::SendingParameters>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Txid> for *mut wire_cst_txid {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Txid {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Txid>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u16> for *mut u16 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u16 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u64> for *mut u64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u8> for *mut u8 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<ldk_adapter::types::ChainDataSourceConfig> for wire_cst_chain_data_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::ChainDataSourceConfig {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Esplora };
                    ldk_adapter::types::ChainDataSourceConfig::Esplora {
                        server_url: ans.server_url.cst_decode(),
                        sync_config: ans.sync_config.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Electrum };
                    ldk_adapter::types::ChainDataSourceConfig::Electrum {
                        server_url: ans.server_url.cst_decode(),
                        sync_config: ans.sync_config.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.BitcoindRpc };
                    ldk_adapter::types::ChainDataSourceConfig::BitcoindRpc {
                        rpc_host: ans.rpc_host.cst_decode(),
                        rpc_port: ans.rpc_port.cst_decode(),
                        rpc_user: ans.rpc_user.cst_decode(),
                        rpc_password: ans.rpc_password.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelInfo> for wire_cst_channel_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelInfo {
            ldk_adapter::graph::ChannelInfo {
                node_one: self.node_one.cst_decode(),
                one_to_two: self.one_to_two.cst_decode(),
                node_two: self.node_two.cst_decode(),
                two_to_one: self.two_to_one.cst_decode(),
                capacity_sats: self.capacity_sats.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelUpdateInfo> for wire_cst_channel_update_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelUpdateInfo {
            ldk_adapter::graph::ChannelUpdateInfo {
                last_update: self.last_update.cst_decode(),
                enabled: self.enabled.cst_decode(),
                cltv_expiry_delta: self.cltv_expiry_delta.cst_decode(),
                htlc_minimum_msat: self.htlc_minimum_msat.cst_decode(),
                htlc_maximum_msat: self.htlc_maximum_msat.cst_decode(),
                fees: self.fees.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::ClosureReason> for wire_cst_closure_reason {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::ClosureReason {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.PeerFeerateTooLow };
                    ldk_adapter::types::ClosureReason::PeerFeerateTooLow {
                        peer_feerate_sat_per_kw: ans.peer_feerate_sat_per_kw.cst_decode(),
                        required_feerate_sat_per_kw: ans.required_feerate_sat_per_kw.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.CounterpartyForceClosed };
                    ldk_adapter::types::ClosureReason::CounterpartyForceClosed {
                        peer_msg: ans.peer_msg.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.HolderForceClosed };
                    ldk_adapter::types::ClosureReason::HolderForceClosed {
                        broadcasted_latest_txn: ans.broadcasted_latest_txn.cst_decode(),
                    }
                }
                3 => ldk_adapter::types::ClosureReason::LegacyCooperativeClosure,
                4 => ldk_adapter::types::ClosureReason::CounterpartyInitiatedCooperativeClosure,
                5 => ldk_adapter::types::ClosureReason::LocallyInitiatedCooperativeClosure,
                6 => ldk_adapter::types::ClosureReason::CommitmentTxConfirmed,
                7 => ldk_adapter::types::ClosureReason::FundingTimedOut,
                8 => {
                    let ans = unsafe { self.kind.ProcessingError };
                    ldk_adapter::types::ClosureReason::ProcessingError {
                        err: ans.err.cst_decode(),
                    }
                }
                9 => ldk_adapter::types::ClosureReason::DisconnectedPeer,
                10 => ldk_adapter::types::ClosureReason::OutdatedChannelManager,
                11 => ldk_adapter::types::ClosureReason::CounterpartyCoopClosedUnfundedChannel,
                12 => ldk_adapter::types::ClosureReason::FundingBatchClosure,
                13 => ldk_adapter::types::ClosureReason::HTLCsTimedOut,
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::Config> for wire_cst_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::Config {
            ldk_adapter::types::Config {
                storage_dir_path: self.storage_dir_path.cst_decode(),
                network: self.network.cst_decode(),
                listening_addresses: self.listening_addresses.cst_decode(),
                announcement_addresses: self.announcement_addresses.cst_decode(),
                node_alias: self.node_alias.cst_decode(),
                trusted_peers_0conf: self.trusted_peers_0conf.cst_decode(),
                probing_liquidity_limit_multiplier: self
                    .probing_liquidity_limit_multiplier
                    .cst_decode(),
                anchor_channels_config: self.anchor_channels_config.cst_decode(),
                sending_parameters: self.sending_parameters.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::CustomTlvRecord> for wire_cst_custom_tlv_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::CustomTlvRecord {
            ldk_adapter::types::CustomTlvRecord {
                type_num: self.type_num.cst_decode(),
                value: self.value.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::ElectrumSyncConfig> for wire_cst_electrum_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::ElectrumSyncConfig {
            ldk_adapter::types::ElectrumSyncConfig {
                background_sync_config: self.background_sync_config.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::EntropySourceConfig> for wire_cst_entropy_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::EntropySourceConfig {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.SeedFile };
                    ldk_adapter::types::EntropySourceConfig::SeedFile(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.SeedBytes };
                    ldk_adapter::types::EntropySourceConfig::SeedBytes(ans.field0.cst_decode())
                }
                2 => {
                    let ans = unsafe { self.kind.Bip39Mnemonic };
                    ldk_adapter::types::EntropySourceConfig::Bip39Mnemonic {
                        mnemonic: ans.mnemonic.cst_decode(),
                        passphrase: ans.passphrase.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::EsploraSyncConfig> for wire_cst_esplora_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::EsploraSyncConfig {
            ldk_adapter::types::EsploraSyncConfig {
                background_sync_config: self.background_sync_config.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::Event> for wire_cst_event {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::Event {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.PaymentClaimable };
                    ldk_adapter::types::Event::PaymentClaimable {
                        payment_id: ans.payment_id.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        claimable_amount_msat: ans.claimable_amount_msat.cst_decode(),
                        claim_deadline: ans.claim_deadline.cst_decode(),
                        custom_records: ans.custom_records.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.PaymentSuccessful };
                    ldk_adapter::types::Event::PaymentSuccessful {
                        payment_id: ans.payment_id.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        fee_paid_msat: ans.fee_paid_msat.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.PaymentFailed };
                    ldk_adapter::types::Event::PaymentFailed {
                        payment_id: ans.payment_id.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        reason: ans.reason.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.PaymentReceived };
                    ldk_adapter::types::Event::PaymentReceived {
                        payment_id: ans.payment_id.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        amount_msat: ans.amount_msat.cst_decode(),
                        custom_records: ans.custom_records.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.ChannelPending };
                    ldk_adapter::types::Event::ChannelPending {
                        channel_id: ans.channel_id.cst_decode(),
                        user_channel_id: ans.user_channel_id.cst_decode(),
                        former_temporary_channel_id: ans.former_temporary_channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        funding_txo: ans.funding_txo.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.ChannelReady };
                    ldk_adapter::types::Event::ChannelReady {
                        channel_id: ans.channel_id.cst_decode(),
                        user_channel_id: ans.user_channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                    }
                }
                6 => {
                    let ans = unsafe { self.kind.ChannelClosed };
                    ldk_adapter::types::Event::ChannelClosed {
                        channel_id: ans.channel_id.cst_decode(),
                        user_channel_id: ans.user_channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        reason: ans.reason.cst_decode(),
                    }
                }
                7 => {
                    let ans = unsafe { self.kind.PaymentForwarded };
                    ldk_adapter::types::Event::PaymentForwarded {
                        prev_channel_id: ans.prev_channel_id.cst_decode(),
                        next_channel_id: ans.next_channel_id.cst_decode(),
                        prev_user_channel_id: ans.prev_user_channel_id.cst_decode(),
                        next_user_channel_id: ans.next_user_channel_id.cst_decode(),
                        prev_node_id: ans.prev_node_id.cst_decode(),
                        next_node_id: ans.next_node_id.cst_decode(),
                        total_fee_earned_msat: ans.total_fee_earned_msat.cst_decode(),
                        skimmed_fee_msat: ans.skimmed_fee_msat.cst_decode(),
                        claim_from_onchain_tx: ans.claim_from_onchain_tx.cst_decode(),
                        outbound_amount_forwarded_msat: ans
                            .outbound_amount_forwarded_msat
                            .cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::FfiLogRecord> for wire_cst_ffi_log_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::FfiLogRecord {
            ldk_adapter::types::FfiLogRecord {
                level: self.level.cst_decode(),
                args: self.args.cst_decode(),
                module_path: self.module_path.cst_decode(),
                line: self.line.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::GossipSourceConfig> for wire_cst_gossip_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::GossipSourceConfig {
            match self.tag {
                0 => ldk_adapter::types::GossipSourceConfig::P2PNetwork,
                1 => {
                    let ans = unsafe { self.kind.RapidGossipSync };
                    ldk_adapter::types::GossipSourceConfig::RapidGossipSync(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::LightningBalance> for wire_cst_lightning_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LightningBalance {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.ClaimableOnChannelClose };
                    ldk_adapter::types::LightningBalance::ClaimableOnChannelClose {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                        transaction_fee_satoshis: ans.transaction_fee_satoshis.cst_decode(),
                        outbound_payment_htlc_rounded_msat: ans
                            .outbound_payment_htlc_rounded_msat
                            .cst_decode(),
                        outbound_forwarded_htlc_rounded_msat: ans
                            .outbound_forwarded_htlc_rounded_msat
                            .cst_decode(),
                        inbound_claiming_htlc_rounded_msat: ans
                            .inbound_claiming_htlc_rounded_msat
                            .cst_decode(),
                        inbound_htlc_rounded_msat: ans.inbound_htlc_rounded_msat.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.ClaimableAwaitingConfirmations };
                    ldk_adapter::types::LightningBalance::ClaimableAwaitingConfirmations {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                        confirmation_height: ans.confirmation_height.cst_decode(),
                        source: ans.source.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.ContentiousClaimable };
                    ldk_adapter::types::LightningBalance::ContentiousClaimable {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                        timeout_height: ans.timeout_height.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        payment_preimage: ans.payment_preimage.cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.MaybeTimeoutClaimableHTLC };
                    ldk_adapter::types::LightningBalance::MaybeTimeoutClaimableHTLC {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                        claimable_height: ans.claimable_height.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                        outbound_payment: ans.outbound_payment.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.MaybePreimageClaimableHTLC };
                    ldk_adapter::types::LightningBalance::MaybePreimageClaimableHTLC {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                        expiry_height: ans.expiry_height.cst_decode(),
                        payment_hash: ans.payment_hash.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.CounterpartyRevokedOutputClaimable };
                    ldk_adapter::types::LightningBalance::CounterpartyRevokedOutputClaimable {
                        channel_id: ans.channel_id.cst_decode(),
                        counterparty_node_id: ans.counterparty_node_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::LiquiditySourceConfig> for wire_cst_liquidity_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LiquiditySourceConfig {
            ldk_adapter::types::LiquiditySourceConfig {
                lsps2_service: self.lsps2_service.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<ChannelDetails>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<ChannelDetails> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<PeerDetails>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<PeerDetails> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<PublicKey>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<PublicKey> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<SocketAddress>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<SocketAddress> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<String>> for *mut wire_cst_list_String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<ldk_adapter::types::CustomTlvRecord>> for *mut wire_cst_list_custom_tlv_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<ldk_adapter::types::CustomTlvRecord> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<ldk_adapter::types::LightningBalance>> for *mut wire_cst_list_lightning_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<ldk_adapter::types::LightningBalance> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<Vec<u8>>> for *mut wire_cst_list_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<Vec<u8>> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<ldk_adapter::graph::NodeId>> for *mut wire_cst_list_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<ldk_adapter::graph::NodeId> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<ldk_adapter::types::PaymentDetails>> for *mut wire_cst_list_payment_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<ldk_adapter::types::PaymentDetails> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<ldk_adapter::types::PendingSweepBalance>>
        for *mut wire_cst_list_pending_sweep_balance
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<ldk_adapter::types::PendingSweepBalance> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<u64>> for *mut wire_cst_list_prim_u_64_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u64> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<(String, String)>> for *mut wire_cst_list_record_string_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(String, String)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<shared::TxIn>> for *mut wire_cst_list_tx_in {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<shared::TxIn> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<shared::TxOut>> for *mut wire_cst_list_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<shared::TxOut> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<ldk_adapter::types::LSPFeeLimits> for wire_cst_lsp_fee_limits {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LSPFeeLimits {
            ldk_adapter::types::LSPFeeLimits {
                max_total_opening_fee_msat: self.max_total_opening_fee_msat.cst_decode(),
                max_proportional_opening_fee_ppm_msat: self
                    .max_proportional_opening_fee_ppm_msat
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Mnemonic> for wire_cst_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Mnemonic {
            shared::Mnemonic {
                words: self.words.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::NodeAlias> for wire_cst_node_alias {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::NodeAlias {
            ldk_adapter::types::NodeAlias(self.field0.cst_decode())
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeAnnouncementInfo> for wire_cst_node_announcement_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeAnnouncementInfo {
            ldk_adapter::graph::NodeAnnouncementInfo {
                last_update: self.last_update.cst_decode(),
                alias: self.alias.cst_decode(),
                addresses: self.addresses.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeId> for wire_cst_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeId {
            ldk_adapter::graph::NodeId {
                compressed: self.compressed.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeInfo> for wire_cst_node_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeInfo {
            ldk_adapter::graph::NodeInfo {
                channels: self.channels.cst_decode(),
                announcement_info: self.announcement_info.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::NodeStatus> for wire_cst_node_status {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::NodeStatus {
            ldk_adapter::types::NodeStatus {
                is_running: self.is_running.cst_decode(),
                is_listening: self.is_listening.cst_decode(),
                current_best_block: self.current_best_block.cst_decode(),
                latest_lightning_wallet_sync_timestamp: self
                    .latest_lightning_wallet_sync_timestamp
                    .cst_decode(),
                latest_onchain_wallet_sync_timestamp: self
                    .latest_onchain_wallet_sync_timestamp
                    .cst_decode(),
                latest_fee_rate_cache_update_timestamp: self
                    .latest_fee_rate_cache_update_timestamp
                    .cst_decode(),
                latest_rgs_snapshot_timestamp: self.latest_rgs_snapshot_timestamp.cst_decode(),
                latest_node_announcement_broadcast_timestamp: self
                    .latest_node_announcement_broadcast_timestamp
                    .cst_decode(),
                latest_channel_monitor_archival_height: self
                    .latest_channel_monitor_archival_height
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Offer> for wire_cst_offer {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Offer {
            shared::Offer {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::OfferId> for wire_cst_offer_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::OfferId {
            ldk_adapter::types::OfferId(self.field0.cst_decode())
        }
    }
    impl CstDecode<shared::OutPoint> for wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::OutPoint {
            shared::OutPoint {
                txid: self.txid.cst_decode(),
                vout: self.vout.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::PaymentDetails> for wire_cst_payment_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::PaymentDetails {
            ldk_adapter::types::PaymentDetails {
                id: self.id.cst_decode(),
                kind: self.kind.cst_decode(),
                amount_msat: self.amount_msat.cst_decode(),
                direction: self.direction.cst_decode(),
                status: self.status.cst_decode(),
                latest_update_timestamp: self.latest_update_timestamp.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::PaymentHash> for wire_cst_payment_hash {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentHash {
            shared::PaymentHash {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::PaymentId> for wire_cst_payment_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentId {
            shared::PaymentId {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::PaymentKind> for wire_cst_payment_kind {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::PaymentKind {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Onchain };
                    ldk_adapter::types::PaymentKind::Onchain {
                        txid: ans.txid.cst_decode(),
                        status: ans.status.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Bolt11 };
                    ldk_adapter::types::PaymentKind::Bolt11 {
                        hash: ans.hash.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                        secret: ans.secret.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.Bolt11Jit };
                    ldk_adapter::types::PaymentKind::Bolt11Jit {
                        hash: ans.hash.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                        secret: ans.secret.cst_decode(),
                        lsp_fee_limits: ans.lsp_fee_limits.cst_decode(),
                        counterparty_skimmed_fee_msat: ans
                            .counterparty_skimmed_fee_msat
                            .cst_decode(),
                    }
                }
                3 => {
                    let ans = unsafe { self.kind.Spontaneous };
                    ldk_adapter::types::PaymentKind::Spontaneous {
                        hash: ans.hash.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                    }
                }
                4 => {
                    let ans = unsafe { self.kind.Bolt12Offer };
                    ldk_adapter::types::PaymentKind::Bolt12Offer {
                        hash: ans.hash.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                        secret: ans.secret.cst_decode(),
                        offer_id: ans.offer_id.cst_decode(),
                        payer_note: ans.payer_note.cst_decode(),
                        quantity: ans.quantity.cst_decode(),
                    }
                }
                5 => {
                    let ans = unsafe { self.kind.Bolt12Refund };
                    ldk_adapter::types::PaymentKind::Bolt12Refund {
                        hash: ans.hash.cst_decode(),
                        preimage: ans.preimage.cst_decode(),
                        secret: ans.secret.cst_decode(),
                        payer_note: ans.payer_note.cst_decode(),
                        quantity: ans.quantity.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<shared::PaymentPreimage> for wire_cst_payment_preimage {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentPreimage {
            shared::PaymentPreimage {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::PaymentSecret> for wire_cst_payment_secret {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::PaymentSecret {
            ldk_adapter::types::PaymentSecret {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::PendingSweepBalance> for wire_cst_pending_sweep_balance {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::PendingSweepBalance {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.PendingBroadcast };
                    ldk_adapter::types::PendingSweepBalance::PendingBroadcast {
                        channel_id: ans.channel_id.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.BroadcastAwaitingConfirmation };
                    ldk_adapter::types::PendingSweepBalance::BroadcastAwaitingConfirmation {
                        channel_id: ans.channel_id.cst_decode(),
                        latest_broadcast_height: ans.latest_broadcast_height.cst_decode(),
                        latest_spending_txid: ans.latest_spending_txid.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.AwaitingThresholdConfirmations };
                    ldk_adapter::types::PendingSweepBalance::AwaitingThresholdConfirmations {
                        channel_id: ans.channel_id.cst_decode(),
                        latest_spending_txid: ans.latest_spending_txid.cst_decode(),
                        confirmation_hash: ans.confirmation_hash.cst_decode(),
                        confirmation_height: ans.confirmation_height.cst_decode(),
                        amount_satoshis: ans.amount_satoshis.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<shared::Psbt> for wire_cst_psbt {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Psbt {
            shared::Psbt {
                inner: self.inner.cst_decode(),
            }
        }
    }
    impl CstDecode<(SocketAddress,PublicKey,Option<String>,)> for wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_public_key_opt_string {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> (SocketAddress,PublicKey,Option<String>,) {
                (self.field0.cst_decode(),self.field1.cst_decode(),self.field2.cst_decode(),)
            }
        }
    impl CstDecode<(String, String)> for wire_cst_record_string_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (String, String) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<shared::Refund> for wire_cst_refund {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Refund {
            shared::Refund {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::RoutingFees> for wire_cst_routing_fees {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::RoutingFees {
            ldk_adapter::graph::RoutingFees {
                base_msat: self.base_msat.cst_decode(),
                proportional_millionths: self.proportional_millionths.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::ScriptBuf> for wire_cst_script_buf {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::ScriptBuf {
            shared::ScriptBuf {
                inner: self.inner.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::SendingParameters> for wire_cst_sending_parameters {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::SendingParameters {
            shared::SendingParameters {
                max_total_routing_fee_msat: self.max_total_routing_fee_msat.cst_decode(),
                max_total_cltv_expiry_delta: self.max_total_cltv_expiry_delta.cst_decode(),
                max_path_count: self.max_path_count.cst_decode(),
                max_channel_saturation_power_of_half: self
                    .max_channel_saturation_power_of_half
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<shared::TxIn> for wire_cst_tx_in {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::TxIn {
            shared::TxIn {
                previous_output: self.previous_output.cst_decode(),
                script_sig: self.script_sig.cst_decode(),
                sequence: self.sequence.cst_decode(),
                witness: self.witness.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::TxOut> for wire_cst_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::TxOut {
            shared::TxOut {
                value: self.value.cst_decode(),
                script_pubkey: self.script_pubkey.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Txid> for wire_cst_txid {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Txid {
            shared::Txid {
                hash: self.hash.cst_decode(),
            }
        }
    }
    impl CstDecode<[u8; 32]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 32] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<[u8; 64]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 64] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<shared::WTxid> for wire_cst_w_txid {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::WTxid {
            shared::WTxid {
                hash: self.hash.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::WitnessProgram> for wire_cst_witness_program {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::WitnessProgram {
            shared::WitnessProgram {
                version: self.version.cst_decode(),
                program: self.program.cst_decode(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_background_sync_config {
        fn new_with_null_ptr() -> Self {
            Self {
                onchain_wallet_sync_interval_secs: Default::default(),
                lightning_wallet_sync_interval_secs: Default::default(),
                fee_rate_cache_update_interval_secs: Default::default(),
            }
        }
    }
    impl Default for wire_cst_background_sync_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_balance_details {
        fn new_with_null_ptr() -> Self {
            Self {
                total_onchain_balance_sats: Default::default(),
                spendable_onchain_balance_sats: Default::default(),
                total_lightning_balance_sats: Default::default(),
                lightning_balances: core::ptr::null_mut(),
                pending_balances_from_channel_closures: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_balance_details {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_best_block {
        fn new_with_null_ptr() -> Self {
            Self {
                block_hash: core::ptr::null_mut(),
                height: Default::default(),
            }
        }
    }
    impl Default for wire_cst_best_block {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bolt_11_invoice {
        fn new_with_null_ptr() -> Self {
            Self {
                signed_raw_invoice: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bolt_11_invoice {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bolt_12_invoice {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bolt_12_invoice {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_chain_data_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: ChainDataSourceConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_chain_data_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_info {
        fn new_with_null_ptr() -> Self {
            Self {
                node_one: Default::default(),
                one_to_two: core::ptr::null_mut(),
                node_two: Default::default(),
                two_to_one: core::ptr::null_mut(),
                capacity_sats: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_channel_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_update_info {
        fn new_with_null_ptr() -> Self {
            Self {
                last_update: Default::default(),
                enabled: Default::default(),
                cltv_expiry_delta: Default::default(),
                htlc_minimum_msat: Default::default(),
                htlc_maximum_msat: Default::default(),
                fees: Default::default(),
            }
        }
    }
    impl Default for wire_cst_channel_update_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_closure_reason {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: ClosureReasonKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_closure_reason {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_config {
        fn new_with_null_ptr() -> Self {
            Self {
                storage_dir_path: core::ptr::null_mut(),
                network: Default::default(),
                listening_addresses: core::ptr::null_mut(),
                announcement_addresses: core::ptr::null_mut(),
                node_alias: core::ptr::null_mut(),
                trusted_peers_0conf: core::ptr::null_mut(),
                probing_liquidity_limit_multiplier: Default::default(),
                anchor_channels_config: core::ptr::null_mut(),
                sending_parameters: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_custom_tlv_record {
        fn new_with_null_ptr() -> Self {
            Self {
                type_num: Default::default(),
                value: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_custom_tlv_record {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_electrum_sync_config {
        fn new_with_null_ptr() -> Self {
            Self {
                background_sync_config: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_electrum_sync_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_entropy_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: EntropySourceConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_entropy_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_esplora_sync_config {
        fn new_with_null_ptr() -> Self {
            Self {
                background_sync_config: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_esplora_sync_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_event {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: EventKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_event {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_log_record {
        fn new_with_null_ptr() -> Self {
            Self {
                level: Default::default(),
                args: core::ptr::null_mut(),
                module_path: core::ptr::null_mut(),
                line: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_log_record {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_gossip_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: GossipSourceConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_gossip_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_lightning_balance {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: LightningBalanceKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_lightning_balance {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_liquidity_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                lsps2_service: Default::default(),
            }
        }
    }
    impl Default for wire_cst_liquidity_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_lsp_fee_limits {
        fn new_with_null_ptr() -> Self {
            Self {
                max_total_opening_fee_msat: core::ptr::null_mut(),
                max_proportional_opening_fee_ppm_msat: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_lsp_fee_limits {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_mnemonic {
        fn new_with_null_ptr() -> Self {
            Self {
                words: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_mnemonic {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_alias {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_alias {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_announcement_info {
        fn new_with_null_ptr() -> Self {
            Self {
                last_update: Default::default(),
                alias: core::ptr::null_mut(),
                addresses: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_announcement_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_id {
        fn new_with_null_ptr() -> Self {
            Self {
                compressed: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_info {
        fn new_with_null_ptr() -> Self {
            Self {
                channels: core::ptr::null_mut(),
                announcement_info: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_status {
        fn new_with_null_ptr() -> Self {
            Self {
                is_running: Default::default(),
                is_listening: Default::default(),
                current_best_block: Default::default(),
                latest_lightning_wallet_sync_timestamp: core::ptr::null_mut(),
                latest_onchain_wallet_sync_timestamp: core::ptr::null_mut(),
                latest_fee_rate_cache_update_timestamp: core::ptr::null_mut(),
                latest_rgs_snapshot_timestamp: core::ptr::null_mut(),
                latest_node_announcement_broadcast_timestamp: core::ptr::null_mut(),
                latest_channel_monitor_archival_height: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_status {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_offer {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_offer {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_offer_id {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_offer_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_out_point {
        fn new_with_null_ptr() -> Self {
            Self {
                txid: Default::default(),
                vout: Default::default(),
            }
        }
    }
    impl Default for wire_cst_out_point {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_details {
        fn new_with_null_ptr() -> Self {
            Self {
                id: Default::default(),
                kind: Default::default(),
                amount_msat: core::ptr::null_mut(),
                direction: Default::default(),
                status: Default::default(),
                latest_update_timestamp: Default::default(),
            }
        }
    }
    impl Default for wire_cst_payment_details {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_hash {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_hash {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_id {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_kind {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: PaymentKindKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_payment_kind {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_preimage {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_preimage {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_secret {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_secret {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_pending_sweep_balance {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: PendingSweepBalanceKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_pending_sweep_balance {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_psbt {
        fn new_with_null_ptr() -> Self {
            Self {
                inner: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_psbt {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_public_key_opt_string {
            fn new_with_null_ptr() -> Self {
                Self { field0: Default::default(),
field1: Default::default(),
field2: core::ptr::null_mut(), }
            }
        }
    impl Default for wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_public_key_opt_string {
            fn default() -> Self {
                Self::new_with_null_ptr()
            }
        }
    impl NewWithNullPtr for wire_cst_record_string_string {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
                field1: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_string_string {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_refund {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_refund {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_routing_fees {
        fn new_with_null_ptr() -> Self {
            Self {
                base_msat: Default::default(),
                proportional_millionths: Default::default(),
            }
        }
    }
    impl Default for wire_cst_routing_fees {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_script_buf {
        fn new_with_null_ptr() -> Self {
            Self {
                inner: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_script_buf {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sending_parameters {
        fn new_with_null_ptr() -> Self {
            Self {
                max_total_routing_fee_msat: core::ptr::null_mut(),
                max_total_cltv_expiry_delta: core::ptr::null_mut(),
                max_path_count: core::ptr::null_mut(),
                max_channel_saturation_power_of_half: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_sending_parameters {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_in {
        fn new_with_null_ptr() -> Self {
            Self {
                previous_output: Default::default(),
                script_sig: Default::default(),
                sequence: Default::default(),
                witness: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_tx_in {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_out {
        fn new_with_null_ptr() -> Self {
            Self {
                value: Default::default(),
                script_pubkey: Default::default(),
            }
        }
    }
    impl Default for wire_cst_tx_out {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_txid {
        fn new_with_null_ptr() -> Self {
            Self {
                hash: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_txid {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_w_txid {
        fn new_with_null_ptr() -> Self {
            Self {
                hash: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_w_txid {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_witness_program {
        fn new_with_null_ptr() -> Self {
            Self {
                version: Default::default(),
                program: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_witness_program {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_add_trusted_peer(
        port_: i64,
        that: usize,
        peer: usize,
    ) {
        wire__ldk_adapter__types__AnchorChannelsConfig_add_trusted_peer_impl(port_, that, peer)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_get_per_channel_reserve_sats(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_get_per_channel_reserve_sats_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_get_trusted_peers_no_reserve(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_get_trusted_peers_no_reserve_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_set_per_channel_reserve_sats(
        that: usize,
        per_channel_reserve_sats: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_set_per_channel_reserve_sats_impl(that, per_channel_reserve_sats)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_set_trusted_peers_no_reserve(
        that: usize,
        trusted_peers_no_reserve: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__AnchorChannelsConfig_auto_accessor_set_trusted_peers_no_reserve_impl(that, trusted_peers_no_reserve)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_conservative(
        port_: i64,
    ) {
        wire__ldk_adapter__types__AnchorChannelsConfig_conservative_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_default(
        port_: i64,
    ) {
        wire__ldk_adapter__types__AnchorChannelsConfig_default_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_is_peer_trusted(
        port_: i64,
        that: usize,
        peer: usize,
    ) {
        wire__ldk_adapter__types__AnchorChannelsConfig_is_peer_trusted_impl(port_, that, peer)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_low_reserve(
        port_: i64,
    ) {
        wire__ldk_adapter__types__AnchorChannelsConfig_low_reserve_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_new(
        port_: i64,
        trusted_peers_no_reserve: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey,
        per_channel_reserve_sats: u64,
    ) {
        wire__ldk_adapter__types__AnchorChannelsConfig_new_impl(
            port_,
            trusted_peers_no_reserve,
            per_channel_reserve_sats,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_remove_trusted_peer(
        port_: i64,
        that: usize,
        peer: usize,
    ) {
        wire__ldk_adapter__types__AnchorChannelsConfig_remove_trusted_peer_impl(port_, that, peer)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_trusted_peers_count(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__AnchorChannelsConfig_trusted_peers_count_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__AnchorChannelsConfig_with_trusted_peers(
        port_: i64,
        trusted_peers: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey,
    ) {
        wire__ldk_adapter__types__AnchorChannelsConfig_with_trusted_peers_impl(port_, trusted_peers)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_as_string(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_as_string_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_auto_accessor_get_inner(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__BitcoinAddress_auto_accessor_get_inner_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_auto_accessor_set_inner(
        that: usize,
        inner: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__BitcoinAddress_auto_accessor_set_inner_impl(that, inner)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_from_script(
        port_: i64,
        script: *mut wire_cst_script_buf,
        network: i32,
    ) {
        wire__shared__BitcoinAddress_from_script_impl(port_, script, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_from_string(
        port_: i64,
        address: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__shared__BitcoinAddress_from_string_impl(port_, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_is_valid_for_network(
        port_: i64,
        that: usize,
        network: i32,
    ) {
        wire__shared__BitcoinAddress_is_valid_for_network_impl(port_, that, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_new(
        address: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__BitcoinAddress_new_impl(address, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_script_pubkey(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_script_pubkey_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_to_address_data(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_to_address_data_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_to_qr_uri(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_to_qr_uri_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_claim_for_hash(
        port_: i64,
        that: usize,
        payment_hash: *mut wire_cst_payment_hash,
        claimable_amount_msat: u64,
        preimage: *mut wire_cst_payment_preimage,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_claim_for_hash_impl(
            port_,
            that,
            payment_hash,
            claimable_amount_msat,
            preimage,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_fail_for_hash(
        port_: i64,
        that: usize,
        payment_hash: *mut wire_cst_payment_hash,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_fail_for_hash_impl(port_, that, payment_hash)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive(
        port_: i64,
        that: usize,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_for_hash(
        port_: i64,
        that: usize,
        payment_hash: *mut wire_cst_payment_hash,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_for_hash_impl(
            port_,
            that,
            payment_hash,
            amount_msat,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_impl(
            port_,
            that,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_for_hash(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        payment_hash: *mut wire_cst_payment_hash,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_for_hash_impl(
            port_,
            that,
            description,
            expiry_secs,
            payment_hash,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_via_jit_channel(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        max_proportional_lsp_fee_limit_ppm_msat: *mut u64,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_via_jit_channel_impl(
            port_,
            that,
            description,
            expiry_secs,
            max_proportional_lsp_fee_limit_ppm_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_via_jit_channel(
        port_: i64,
        that: usize,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        max_total_lsp_fee_limit_msat: *mut u64,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_via_jit_channel_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
            max_total_lsp_fee_limit_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send(
        port_: i64,
        that: usize,
        invoice: *mut wire_cst_bolt_11_invoice,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_impl(port_, that, invoice, sending_parameters)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send_probes(
        port_: i64,
        that: usize,
        invoice: *mut wire_cst_bolt_11_invoice,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_impl(port_, that, invoice)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_using_amount(
        port_: i64,
        that: usize,
        invoice: *mut wire_cst_bolt_11_invoice,
        amount_msat: u64,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_using_amount_impl(
            port_,
            that,
            invoice,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send_using_amount(
        port_: i64,
        that: usize,
        invoice: *mut wire_cst_bolt_11_invoice,
        amount_msat: u64,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_using_amount_impl(
            port_,
            that,
            invoice,
            amount_msat,
            sending_parameters,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_initiate_refund(
        port_: i64,
        that: usize,
        amount_msat: u64,
        expiry_secs: u32,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_initiate_refund_impl(
            port_,
            that,
            amount_msat,
            expiry_secs,
            quantity,
            payer_note,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_receive(
        port_: i64,
        that: usize,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: *mut u32,
        quantity: *mut u64,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_receive_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
            quantity,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_receive_variable_amount(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: *mut u32,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_receive_variable_amount_impl(
            port_,
            that,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_request_refund_payment(
        port_: i64,
        that: usize,
        refund: *mut wire_cst_refund,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_request_refund_payment_impl(port_, that, refund)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_send(
        port_: i64,
        that: usize,
        offer: *mut wire_cst_offer,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_send_impl(port_, that, offer, quantity, payer_note)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_send_using_amount(
        port_: i64,
        that: usize,
        offer: *mut wire_cst_offer,
        amount_msat: u64,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_send_using_amount_impl(
            port_,
            that,
            offer,
            amount_msat,
            quantity,
            payer_note,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_accept_underpaying_htlcs(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_accept_underpaying_htlcs_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_cltv_expiry_delta(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_cltv_expiry_delta_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_base_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_base_msat_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_max_dust_htlc_exposure(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_max_dust_htlc_exposure_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_accept_underpaying_htlcs(
        that: usize,
        accept_underpaying_htlcs: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_accept_underpaying_htlcs_impl(
            that,
            accept_underpaying_htlcs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_cltv_expiry_delta(
        that: usize,
        cltv_expiry_delta: u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_cltv_expiry_delta_impl(
            that,
            cltv_expiry_delta,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis(
        that: usize,
        force_close_avoidance_max_fee_satoshis: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis_impl(that, force_close_avoidance_max_fee_satoshis)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_base_msat(
        that: usize,
        forwarding_fee_base_msat: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_base_msat_impl(
            that,
            forwarding_fee_base_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths(
        that: usize,
        forwarding_fee_proportional_millionths: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths_impl(that, forwarding_fee_proportional_millionths)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_max_dust_htlc_exposure(
        that: usize,
        max_dust_htlc_exposure: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_max_dust_htlc_exposure_impl(
            that,
            max_dust_htlc_exposure,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_calculate_forwarding_fee(
        port_: i64,
        that: usize,
        amount_msat: u64,
    ) {
        wire__ldk_adapter__types__ChannelConfig_calculate_forwarding_fee_impl(
            port_,
            that,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_high_fee_routing(
        port_: i64,
    ) {
        wire__ldk_adapter__types__ChannelConfig_high_fee_routing_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_low_fee_routing(
        port_: i64,
    ) {
        wire__ldk_adapter__types__ChannelConfig_low_fee_routing_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_new(
        port_: i64,
        forwarding_fee_proportional_millionths: u32,
        forwarding_fee_base_msat: u32,
        cltv_expiry_delta: u16,
        max_dust_htlc_exposure: usize,
        force_close_avoidance_max_fee_satoshis: u64,
        accept_underpaying_htlcs: bool,
    ) {
        wire__ldk_adapter__types__ChannelConfig_new_impl(
            port_,
            forwarding_fee_proportional_millionths,
            forwarding_fee_base_msat,
            cltv_expiry_delta,
            max_dust_htlc_exposure,
            force_close_avoidance_max_fee_satoshis,
            accept_underpaying_htlcs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_value_sats(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_value_sats_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_cltv_expiry_delta(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_cltv_expiry_delta_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_config(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_config_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_required(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_required_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_node_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_node_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_force_close_spend_delay(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_force_close_spend_delay_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_funding_txo(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_funding_txo_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_capacity_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_capacity_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_channel_ready(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_channel_ready_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_outbound(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_outbound_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_usable(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_usable_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_outbound_capacity_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_outbound_capacity_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_unspendable_punishment_reserve(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_unspendable_punishment_reserve_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_user_channel_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_user_channel_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_id(
        that: usize,
        channel_id: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_id_impl(that, channel_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_value_sats(
        that: usize,
        channel_value_sats: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_value_sats_impl(
            that,
            channel_value_sats,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_cltv_expiry_delta(
        that: usize,
        cltv_expiry_delta: *mut u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_cltv_expiry_delta_impl(
            that,
            cltv_expiry_delta,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_config(
        that: usize,
        config: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_config_impl(that, config)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations(
        that: usize,
        confirmations: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_impl(
            that,
            confirmations,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_required(
        that: usize,
        confirmations_required: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_required_impl(
            that,
            confirmations_required,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta(
        that: usize,
        counterparty_forwarding_info_cltv_expiry_delta: *mut u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta_impl(that, counterparty_forwarding_info_cltv_expiry_delta)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat(
        that: usize,
        counterparty_forwarding_info_fee_base_msat: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat_impl(that, counterparty_forwarding_info_fee_base_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths(
        that: usize,
        counterparty_forwarding_info_fee_proportional_millionths: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths_impl(that, counterparty_forwarding_info_fee_proportional_millionths)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_node_id(
        that: usize,
        counterparty_node_id: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_node_id_impl(
            that,
            counterparty_node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat(
        that: usize,
        counterparty_outbound_htlc_maximum_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat_impl(that, counterparty_outbound_htlc_maximum_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat(
        that: usize,
        counterparty_outbound_htlc_minimum_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat_impl(that, counterparty_outbound_htlc_minimum_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve(
        that: usize,
        counterparty_unspendable_punishment_reserve: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve_impl(that, counterparty_unspendable_punishment_reserve)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight(
        that: usize,
        feerate_sat_per_1000_weight: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight_impl(
            that,
            feerate_sat_per_1000_weight,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_force_close_spend_delay(
        that: usize,
        force_close_spend_delay: *mut u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_force_close_spend_delay_impl(
            that,
            force_close_spend_delay,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_funding_txo(
        that: usize,
        funding_txo: *mut wire_cst_out_point,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_funding_txo_impl(
            that,
            funding_txo,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_capacity_msat(
        that: usize,
        inbound_capacity_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_capacity_msat_impl(
            that,
            inbound_capacity_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat(
        that: usize,
        inbound_htlc_maximum_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat_impl(
            that,
            inbound_htlc_maximum_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat(
        that: usize,
        inbound_htlc_minimum_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat_impl(
            that,
            inbound_htlc_minimum_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_channel_ready(
        that: usize,
        is_channel_ready: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_channel_ready_impl(
            that,
            is_channel_ready,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_outbound(
        that: usize,
        is_outbound: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_outbound_impl(
            that,
            is_outbound,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_usable(
        that: usize,
        is_usable: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_usable_impl(that, is_usable)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat(
        that: usize,
        next_outbound_htlc_limit_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat_impl(that, next_outbound_htlc_limit_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat(
        that: usize,
        next_outbound_htlc_minimum_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat_impl(that, next_outbound_htlc_minimum_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_outbound_capacity_msat(
        that: usize,
        outbound_capacity_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_outbound_capacity_msat_impl(
            that,
            outbound_capacity_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_unspendable_punishment_reserve(
        that: usize,
        unspendable_punishment_reserve: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_unspendable_punishment_reserve_impl(that, unspendable_punishment_reserve)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_user_channel_id(
        that: usize,
        user_channel_id: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_user_channel_id_impl(
            that,
            user_channel_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_balance_ratio_percent(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__ChannelDetails_balance_ratio_percent_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_can_receive(
        port_: i64,
        that: usize,
        amount_msat: u64,
    ) {
        wire__ldk_adapter__types__ChannelDetails_can_receive_impl(port_, that, amount_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_can_send(
        port_: i64,
        that: usize,
        amount_msat: u64,
    ) {
        wire__ldk_adapter__types__ChannelDetails_can_send_impl(port_, that, amount_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_capacity_sats(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__ChannelDetails_capacity_sats_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_new(
        port_: i64,
        channel_id: usize,
        counterparty_node_id: usize,
        funding_txo: *mut wire_cst_out_point,
        channel_value_sats: u64,
        unspendable_punishment_reserve: *mut u64,
        user_channel_id: usize,
        feerate_sat_per_1000_weight: u32,
        outbound_capacity_msat: u64,
        inbound_capacity_msat: u64,
        is_outbound: bool,
        is_channel_ready: bool,
        is_usable: bool,
        config: usize,
    ) {
        wire__ldk_adapter__types__ChannelDetails_new_impl(
            port_,
            channel_id,
            counterparty_node_id,
            funding_txo,
            channel_value_sats,
            unspendable_punishment_reserve,
            user_channel_id,
            feerate_sat_per_1000_weight,
            outbound_capacity_msat,
            inbound_capacity_msat,
            is_outbound,
            is_channel_ready,
            is_usable,
            config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_total_liquidity_msat(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__ChannelDetails_total_liquidity_msat_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelId_as_bytes(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__ChannelId_as_bytes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelId_auto_accessor_get_data(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelId_auto_accessor_get_data_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelId_auto_accessor_set_data(
        that: usize,
        data: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelId_auto_accessor_set_data_impl(that, data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelId_from_bytes(
        port_: i64,
        bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__types__ChannelId_from_bytes_impl(port_, bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelId_new(
        port_: i64,
        data: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__types__ChannelId_new_impl(port_, data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_build(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_build_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_build_with_fs_store(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_build_with_fs_store_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store(
        port_: i64,
        that: usize,
        vss_url: *mut wire_cst_list_prim_u_8_strict,
        store_id: *mut wire_cst_list_prim_u_8_strict,
        lnurl_auth_server_url: *mut wire_cst_list_prim_u_8_strict,
        fixed_headers: *mut wire_cst_list_record_string_string,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store_impl(
            port_,
            that,
            vss_url,
            store_id,
            lnurl_auth_server_url,
            fixed_headers,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store_and_fixed_headers(
        port_: i64,
        that: usize,
        vss_url: *mut wire_cst_list_prim_u_8_strict,
        store_id: *mut wire_cst_list_prim_u_8_strict,
        fixed_headers: *mut wire_cst_list_record_string_string,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store_and_fixed_headers_impl(
            port_,
            that,
            vss_url,
            store_id,
            fixed_headers,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_create_builder(
        port_: i64,
        config: *mut wire_cst_config,
        chain_data_source_config: *mut wire_cst_chain_data_source_config,
        entropy_source_config: *mut wire_cst_entropy_source_config,
        gossip_source_config: *mut wire_cst_gossip_source_config,
        liquidity_source_config: *mut wire_cst_liquidity_source_config,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_create_builder_impl(
            port_,
            config,
            chain_data_source_config,
            entropy_source_config,
            gossip_source_config,
            liquidity_source_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_set_entropy_seed_bytes(
        port_: i64,
        that: usize,
        seed_bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_set_entropy_seed_bytes_impl(port_, that, seed_bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_set_filesystem_logger(
        port_: i64,
        that: usize,
        log_file_path: *mut wire_cst_list_prim_u_8_strict,
        max_log_level: *mut i32,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_set_filesystem_logger_impl(
            port_,
            that,
            log_file_path,
            max_log_level,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_set_log_facade_logger(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_set_log_facade_logger_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__MaxDustHtlcExposure_conservative(
        port_: i64,
    ) {
        wire__ldk_adapter__types__MaxDustHtlcExposure_conservative_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__MaxDustHtlcExposure_default_fee_rate(
        port_: i64,
    ) {
        wire__ldk_adapter__types__MaxDustHtlcExposure_default_fee_rate_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__MaxDustHtlcExposure_new_fee_rate_multiplier(
        port_: i64,
        multiplier: u64,
    ) {
        wire__ldk_adapter__types__MaxDustHtlcExposure_new_fee_rate_multiplier_impl(
            port_, multiplier,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__MaxDustHtlcExposure_new_fixed_limit(
        port_: i64,
        limit_msat: u64,
    ) {
        wire__ldk_adapter__types__MaxDustHtlcExposure_new_fixed_limit_impl(port_, limit_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_channel(
        port_: i64,
        that: usize,
        short_channel_id: u64,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_channel_impl(port_, that, short_channel_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_list_channels(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_list_channels_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_list_nodes(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_list_nodes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_node(
        port_: i64,
        that: usize,
        node_id: *mut wire_cst_node_id,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_node_impl(port_, that, node_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_bolt11_payment(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_bolt11_payment_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_bolt12_payment(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_bolt12_payment_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_close_channel(
        port_: i64,
        that: usize,
        user_channel_id: usize,
        counterparty_node_id: usize,
    ) {
        wire__ldk_adapter__node__Node_close_channel_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_config(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_config_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_connect(
        port_: i64,
        that: usize,
        node_id: usize,
        address: usize,
        persist: bool,
    ) {
        wire__ldk_adapter__node__Node_connect_impl(port_, that, node_id, address, persist)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_disconnect(
        port_: i64,
        that: usize,
        counterparty_node_id: usize,
    ) {
        wire__ldk_adapter__node__Node_disconnect_impl(port_, that, counterparty_node_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_event_handled(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_event_handled_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_export_pathfinding_scores(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_export_pathfinding_scores_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_force_close_channel(
        port_: i64,
        that: usize,
        user_channel_id: usize,
        counterparty_node_id: usize,
    ) {
        wire__ldk_adapter__node__Node_force_close_channel_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_balances(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_balances_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_channels(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_channels_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_payments(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_payments_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_payments_with_filter(
        port_: i64,
        that: usize,
        payment_direction: i32,
    ) {
        wire__ldk_adapter__node__Node_list_payments_with_filter_impl(port_, that, payment_direction)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_peers(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_peers_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_listening_addresses(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_listening_addresses_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_network_graph(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_network_graph_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_next_event(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_next_event_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_next_event_async(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_next_event_async_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_node_id(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_node_id_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_on_chain_payment(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_on_chain_payment_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_open_announced_channel(
        port_: i64,
        that: usize,
        socket_address: usize,
        node_id: usize,
        channel_amount_sats: u64,
        push_to_counterparty_msat: *mut u64,
        channel_config: *mut usize,
    ) {
        wire__ldk_adapter__node__Node_open_announced_channel_impl(
            port_,
            that,
            socket_address,
            node_id,
            channel_amount_sats,
            push_to_counterparty_msat,
            channel_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_open_channel(
        port_: i64,
        that: usize,
        socket_address: usize,
        node_id: usize,
        channel_amount_sats: u64,
        push_to_counterparty_msat: *mut u64,
        channel_config: *mut usize,
    ) {
        wire__ldk_adapter__node__Node_open_channel_impl(
            port_,
            that,
            socket_address,
            node_id,
            channel_amount_sats,
            push_to_counterparty_msat,
            channel_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_payment(
        port_: i64,
        that: usize,
        payment_id: *mut wire_cst_payment_id,
    ) {
        wire__ldk_adapter__node__Node_payment_impl(port_, that, payment_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_remove_payment(
        port_: i64,
        that: usize,
        payment_id: *mut wire_cst_payment_id,
    ) {
        wire__ldk_adapter__node__Node_remove_payment_impl(port_, that, payment_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_sign_message(
        port_: i64,
        that: usize,
        msg: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__node__Node_sign_message_impl(port_, that, msg)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_spontaneous_payment(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_spontaneous_payment_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_start(port_: i64, that: usize) {
        wire__ldk_adapter__node__Node_start_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_status(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_status_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_stop(port_: i64, that: usize) {
        wire__ldk_adapter__node__Node_stop_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_sync_wallets(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_sync_wallets_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_unified_qr_payment(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_unified_qr_payment_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_update_channel_config(
        port_: i64,
        that: usize,
        user_channel_id: usize,
        counterparty_node_id: usize,
        channel_config: usize,
    ) {
        wire__ldk_adapter__node__Node_update_channel_config_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
            channel_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_verify_signature(
        port_: i64,
        that: usize,
        msg: *mut wire_cst_list_prim_u_8_loose,
        sig: *mut wire_cst_list_prim_u_8_strict,
        public_key: usize,
    ) {
        wire__ldk_adapter__node__Node_verify_signature_impl(port_, that, msg, sig, public_key)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_wait_next_event(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_wait_next_event_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__on_chain__OnChainPayment_new_address(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__on_chain__OnChainPayment_new_address_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__on_chain__OnChainPayment_send_all_to_address(
        port_: i64,
        that: usize,
        address: usize,
        retain_reserves: bool,
        fee_rate_sat_per_kwu: *mut u64,
    ) {
        wire__ldk_adapter__on_chain__OnChainPayment_send_all_to_address_impl(
            port_,
            that,
            address,
            retain_reserves,
            fee_rate_sat_per_kwu,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__on_chain__OnChainPayment_send_to_address(
        port_: i64,
        that: usize,
        address: usize,
        amount_sats: u64,
        fee_rate_sat_per_kwu: *mut u64,
    ) {
        wire__ldk_adapter__on_chain__OnChainPayment_send_to_address_impl(
            port_,
            that,
            address,
            amount_sats,
            fee_rate_sat_per_kwu,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_get_address(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_get_address_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_get_is_connected(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_get_is_connected_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_get_node_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_get_node_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_set_address(
        that: usize,
        address: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_set_address_impl(that, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_set_is_connected(
        that: usize,
        is_connected: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_set_is_connected_impl(
            that,
            is_connected,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_set_node_id(
        that: usize,
        node_id: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_set_node_id_impl(that, node_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_is_offline(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__PeerDetails_is_offline_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_is_online(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__PeerDetails_is_online_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_new(
        port_: i64,
        node_id: usize,
        address: usize,
        is_connected: bool,
    ) {
        wire__ldk_adapter__types__PeerDetails_new_impl(port_, node_id, address, is_connected)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_new_connected(
        port_: i64,
        node_id: usize,
        address: usize,
    ) {
        wire__ldk_adapter__types__PeerDetails_new_connected_impl(port_, node_id, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_new_disconnected(
        port_: i64,
        node_id: usize,
        address: usize,
    ) {
        wire__ldk_adapter__types__PeerDetails_new_disconnected_impl(port_, node_id, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PublicKey_auto_accessor_get_hex(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PublicKey_auto_accessor_get_hex_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PublicKey_auto_accessor_set_hex(
        that: usize,
        hex: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PublicKey_auto_accessor_set_hex_impl(that, hex)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PublicKey_new(
        hex: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PublicKey_new_impl(hex)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__SocketAddress_addr(port_: i64, that: usize) {
        wire__shared__SocketAddress_addr_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__SocketAddress_hostname(
        addr: *mut wire_cst_list_prim_u_8_strict,
        port: u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__SocketAddress_hostname_impl(addr, port)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__SocketAddress_port(port_: i64, that: usize) {
        wire__shared__SocketAddress_port_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__spontaneous__SpontaneousPayment_send_probes_unsafe(
        port_: i64,
        that: usize,
        amount_msat: u64,
        node_id: usize,
    ) {
        wire__ldk_adapter__spontaneous__SpontaneousPayment_send_probes_unsafe_impl(
            port_,
            that,
            amount_msat,
            node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__spontaneous__SpontaneousPayment_send_unsafe(
        port_: i64,
        that: usize,
        amount_msat: u64,
        node_id: usize,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__ldk_adapter__spontaneous__SpontaneousPayment_send_unsafe_impl(
            port_,
            that,
            amount_msat,
            node_id,
            sending_parameters,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__spontaneous__SpontaneousPayment_send_with_custom_tlvs_unsafe(
        port_: i64,
        that: usize,
        amount_msat: u64,
        node_id: usize,
        sending_parameters: *mut wire_cst_sending_parameters,
        custom_tlvs: *mut wire_cst_list_custom_tlv_record,
    ) {
        wire__ldk_adapter__spontaneous__SpontaneousPayment_send_with_custom_tlvs_unsafe_impl(
            port_,
            that,
            amount_msat,
            node_id,
            sending_parameters,
            custom_tlvs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__TaprootSpendInfo_auto_accessor_get_inner(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__TaprootSpendInfo_auto_accessor_get_inner_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__TaprootSpendInfo_auto_accessor_set_inner(
        that: usize,
        inner: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__TaprootSpendInfo_auto_accessor_set_inner_impl(that, inner)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_auto_accessor_get_inner(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__Transaction_auto_accessor_get_inner_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_auto_accessor_set_inner(
        that: usize,
        inner: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__Transaction_auto_accessor_set_inner_impl(that, inner)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_compute_txid(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_compute_txid_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_compute_wtxid(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_compute_wtxid_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_input(port_: i64, that: usize) {
        wire__shared__Transaction_input_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_is_coinbase(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_is_coinbase_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_is_explicitly_rbf(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_is_explicitly_rbf_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_is_lock_time_enabled(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_is_lock_time_enabled_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_lock_time(port_: i64, that: usize) {
        wire__shared__Transaction_lock_time_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_new(
        transaction_bytes: *mut wire_cst_list_prim_u_8_loose,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__Transaction_new_impl(transaction_bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_output(port_: i64, that: usize) {
        wire__shared__Transaction_output_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_total_size(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_total_size_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_version(port_: i64, that: usize) {
        wire__shared__Transaction_version_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_vsize(port_: i64, that: usize) {
        wire__shared__Transaction_vsize_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_weight(port_: i64, that: usize) {
        wire__shared__Transaction_weight_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__unified_qr__UnifiedQrPayment_receive(
        port_: i64,
        that: usize,
        amount_sats: u64,
        message: *mut wire_cst_list_prim_u_8_strict,
        expiry_sec: u32,
    ) {
        wire__ldk_adapter__unified_qr__UnifiedQrPayment_receive_impl(
            port_,
            that,
            amount_sats,
            message,
            expiry_sec,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__unified_qr__UnifiedQrPayment_send(
        port_: i64,
        that: usize,
        uri_str: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__unified_qr__UnifiedQrPayment_send_impl(port_, that, uri_str)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_as_bytes(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__UserChannelId_as_bytes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_auto_accessor_get_data(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__UserChannelId_auto_accessor_get_data_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_auto_accessor_set_data(
        that: usize,
        data: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__UserChannelId_auto_accessor_set_data_impl(that, data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_from_string(
        port_: i64,
        s: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__types__UserChannelId_from_string_impl(port_, s)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_from_u64(
        port_: i64,
        id: u64,
    ) {
        wire__ldk_adapter__types__UserChannelId_from_u64_impl(port_, id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_new(
        data: *mut wire_cst_list_prim_u_8_loose,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__UserChannelId_new_impl(data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__config_default(port_: i64) {
        wire__ldk_adapter__types__config_default_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__custom_tlv_record_from_string(
        port_: i64,
        type_num: u64,
        value: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__types__custom_tlv_record_from_string_impl(port_, type_num, value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__custom_tlv_record_from_u64(
        port_: i64,
        type_num: u64,
        value: u64,
    ) {
        wire__ldk_adapter__types__custom_tlv_record_from_u64_impl(port_, type_num, value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__custom_tlv_record_new(
        port_: i64,
        type_num: u64,
        value: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__types__custom_tlv_record_new_impl(port_, type_num, value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__custom_tlv_record_value_as_string(
        port_: i64,
        that: *mut wire_cst_custom_tlv_record,
    ) {
        wire__ldk_adapter__types__custom_tlv_record_value_as_string_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_debug(
        port_: i64,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_debug_impl(port_, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_error(
        port_: i64,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_error_impl(port_, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_formatted(
        port_: i64,
        that: *mut wire_cst_ffi_log_record,
    ) {
        wire__ldk_adapter__types__ffi_log_record_formatted_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_info(
        port_: i64,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_info_impl(port_, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_is_error(
        port_: i64,
        that: *mut wire_cst_ffi_log_record,
    ) {
        wire__ldk_adapter__types__ffi_log_record_is_error_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_is_warn(
        port_: i64,
        that: *mut wire_cst_ffi_log_record,
    ) {
        wire__ldk_adapter__types__ffi_log_record_is_warn_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_new(
        port_: i64,
        level: i32,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_new_impl(port_, level, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_trace(
        port_: i64,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_trace_impl(port_, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_warn(
        port_: i64,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_warn_impl(port_, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__lsp_fee_limits_conservative(
        port_: i64,
    ) {
        wire__ldk_adapter__types__lsp_fee_limits_conservative_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__lsp_fee_limits_new(
        port_: i64,
        max_total_opening_fee_msat: *mut u64,
        max_proportional_opening_fee_ppm_msat: *mut u64,
    ) {
        wire__ldk_adapter__types__lsp_fee_limits_new_impl(
            port_,
            max_total_opening_fee_msat,
            max_proportional_opening_fee_ppm_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__lsp_fee_limits_permissive(
        port_: i64,
    ) {
        wire__ldk_adapter__types__lsp_fee_limits_permissive_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__lsp_fee_limits_unlimited(
        port_: i64,
    ) {
        wire__ldk_adapter__types__lsp_fee_limits_unlimited_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_as_string(
        port_: i64,
        that: *mut wire_cst_mnemonic,
    ) {
        wire__shared__mnemonic_as_string_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_from_entropy(
        port_: i64,
        entropy: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__shared__mnemonic_from_entropy_impl(port_, entropy)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_from_seed_phrase(
        port_: i64,
        seed_phrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__shared__mnemonic_from_seed_phrase_impl(port_, seed_phrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_generate(port_: i64) {
        wire__shared__mnemonic_generate_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_to_seed(
        port_: i64,
        that: *mut wire_cst_mnemonic,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__shared__mnemonic_to_seed_impl(port_, that, passphrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__offer_id_as_bytes(
        port_: i64,
        that: *mut wire_cst_offer_id,
    ) {
        wire__ldk_adapter__types__offer_id_as_bytes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__offer_id_from_bytes(
        port_: i64,
        bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__types__offer_id_from_bytes_impl(port_, bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__offer_id_new(
        port_: i64,
        data: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__types__offer_id_new_impl(port_, data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_details_is_failed(
        port_: i64,
        that: *mut wire_cst_payment_details,
    ) {
        wire__ldk_adapter__types__payment_details_is_failed_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_details_is_pending(
        port_: i64,
        that: *mut wire_cst_payment_details,
    ) {
        wire__ldk_adapter__types__payment_details_is_pending_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_details_is_succeeded(
        port_: i64,
        that: *mut wire_cst_payment_details,
    ) {
        wire__ldk_adapter__types__payment_details_is_succeeded_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_details_new(
        port_: i64,
        id: *mut wire_cst_payment_id,
        kind: *mut wire_cst_payment_kind,
        amount_msat: *mut u64,
        direction: i32,
        status: i32,
        latest_update_timestamp: u64,
    ) {
        wire__ldk_adapter__types__payment_details_new_impl(
            port_,
            id,
            kind,
            amount_msat,
            direction,
            status,
            latest_update_timestamp,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_details_new_inbound_pending(
        port_: i64,
        id: *mut wire_cst_payment_id,
        kind: *mut wire_cst_payment_kind,
        amount_msat: *mut u64,
    ) {
        wire__ldk_adapter__types__payment_details_new_inbound_pending_impl(
            port_,
            id,
            kind,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_details_new_outbound_pending(
        port_: i64,
        id: *mut wire_cst_payment_id,
        kind: *mut wire_cst_payment_kind,
        amount_msat: *mut u64,
    ) {
        wire__ldk_adapter__types__payment_details_new_outbound_pending_impl(
            port_,
            id,
            kind,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_secret_as_bytes(
        port_: i64,
        that: *mut wire_cst_payment_secret,
    ) {
        wire__ldk_adapter__types__payment_secret_as_bytes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_secret_from_bytes(
        port_: i64,
        bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__types__payment_secret_from_bytes_impl(port_, bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_secret_new(
        port_: i64,
        data: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__types__payment_secret_new_impl(port_, data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__psbt_extract_tx(
        port_: i64,
        that: *mut wire_cst_psbt,
    ) {
        wire__shared__psbt_extract_tx_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__psbt_fee(port_: i64, that: *mut wire_cst_psbt) {
        wire__shared__psbt_fee_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__psbt_from_base64(
        port_: i64,
        base64: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__shared__psbt_from_base64_impl(port_, base64)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressData(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressData(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnchorChannelsConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnchorChannelsConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnchorChannelsConfig>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinTransactionInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
            >::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinTransactionInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
            >::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt11Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt11Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt12Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt12Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConfirmationStatus(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfirmationStatus>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerConfirmationStatus(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConfirmationStatus>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLdkBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLdkBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaxDustHTLCExposure(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaxDustHTLCExposure(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNetworkGraph(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNetworkGraph(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNode(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNode(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnChainPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnChainPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPaymentResult(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPaymentResult(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSpontaneousPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSpontaneousPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfo(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfo(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfoInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfoInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnifiedQrPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnifiedQrPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserChannelId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserChannelId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAnchorChannelsConfig(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelConfig(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelId(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserChannelId(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_background_sync_config(
    ) -> *mut wire_cst_background_sync_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_background_sync_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_bolt_11_invoice(
    ) -> *mut wire_cst_bolt_11_invoice {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bolt_11_invoice::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_bool(value: bool) -> *mut bool {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_chain_data_source_config(
    ) -> *mut wire_cst_chain_data_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_chain_data_source_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_channel_info(
    ) -> *mut wire_cst_channel_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_channel_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_channel_update_info(
    ) -> *mut wire_cst_channel_update_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_channel_update_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_closure_reason(
    ) -> *mut wire_cst_closure_reason {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_closure_reason::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_config() -> *mut wire_cst_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_config::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_custom_tlv_record(
    ) -> *mut wire_cst_custom_tlv_record {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_custom_tlv_record::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_electrum_sync_config(
    ) -> *mut wire_cst_electrum_sync_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_electrum_sync_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_entropy_source_config(
    ) -> *mut wire_cst_entropy_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_entropy_source_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_esplora_sync_config(
    ) -> *mut wire_cst_esplora_sync_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_esplora_sync_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_event() -> *mut wire_cst_event {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_event::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_log_record(
    ) -> *mut wire_cst_ffi_log_record {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_log_record::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_gossip_source_config(
    ) -> *mut wire_cst_gossip_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_gossip_source_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_liquidity_source_config(
    ) -> *mut wire_cst_liquidity_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_liquidity_source_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_log_level(value: i32) -> *mut i32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_lsp_fee_limits(
    ) -> *mut wire_cst_lsp_fee_limits {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_lsp_fee_limits::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_mnemonic() -> *mut wire_cst_mnemonic {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_mnemonic::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_alias() -> *mut wire_cst_node_alias {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_node_alias::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_announcement_info(
    ) -> *mut wire_cst_node_announcement_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_node_announcement_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_id() -> *mut wire_cst_node_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_node_id::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_info() -> *mut wire_cst_node_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_node_info::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_offer() -> *mut wire_cst_offer {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_offer::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_offer_id() -> *mut wire_cst_offer_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_offer_id::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_out_point() -> *mut wire_cst_out_point {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_out_point::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_details(
    ) -> *mut wire_cst_payment_details {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_details::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_failure_reason(
        value: i32,
    ) -> *mut i32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_hash(
    ) -> *mut wire_cst_payment_hash {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_hash::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_id() -> *mut wire_cst_payment_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_id::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_kind(
    ) -> *mut wire_cst_payment_kind {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_kind::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_preimage(
    ) -> *mut wire_cst_payment_preimage {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_preimage::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_secret(
    ) -> *mut wire_cst_payment_secret {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_secret::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_psbt() -> *mut wire_cst_psbt {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_psbt::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_refund() -> *mut wire_cst_refund {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_refund::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_script_buf() -> *mut wire_cst_script_buf {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_script_buf::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_sending_parameters(
    ) -> *mut wire_cst_sending_parameters {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_sending_parameters::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_txid() -> *mut wire_cst_txid {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_txid::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_16(value: u16) -> *mut u16 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_8(value: u8) -> *mut u8 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_String(len: i32) -> *mut wire_cst_list_String {
        let wrap = wire_cst_list_String {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_custom_tlv_record(
        len: i32,
    ) -> *mut wire_cst_list_custom_tlv_record {
        let wrap = wire_cst_list_custom_tlv_record {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_custom_tlv_record>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_lightning_balance(
        len: i32,
    ) -> *mut wire_cst_list_lightning_balance {
        let wrap = wire_cst_list_lightning_balance {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_lightning_balance>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_list_prim_u_8_strict {
        let wrap = wire_cst_list_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_node_id(len: i32) -> *mut wire_cst_list_node_id {
        let wrap = wire_cst_list_node_id {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_node_id>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_payment_details(
        len: i32,
    ) -> *mut wire_cst_list_payment_details {
        let wrap = wire_cst_list_payment_details {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_payment_details>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_pending_sweep_balance(
        len: i32,
    ) -> *mut wire_cst_list_pending_sweep_balance {
        let wrap = wire_cst_list_pending_sweep_balance {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_pending_sweep_balance>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_64_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_64_strict {
        let ans = wire_cst_list_prim_u_64_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_8_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_loose {
        let ans = wire_cst_list_prim_u_8_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_record_string_string(
        len: i32,
    ) -> *mut wire_cst_list_record_string_string {
        let wrap = wire_cst_list_record_string_string {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_string_string>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_tx_in(len: i32) -> *mut wire_cst_list_tx_in {
        let wrap = wire_cst_list_tx_in {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx_in>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_tx_out(len: i32) -> *mut wire_cst_list_tx_out {
        let wrap = wire_cst_list_tx_out {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx_out>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_background_sync_config {
        onchain_wallet_sync_interval_secs: u64,
        lightning_wallet_sync_interval_secs: u64,
        fee_rate_cache_update_interval_secs: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_balance_details {
        total_onchain_balance_sats: u64,
        spendable_onchain_balance_sats: u64,
        total_lightning_balance_sats: u64,
        lightning_balances: *mut wire_cst_list_lightning_balance,
        pending_balances_from_channel_closures: *mut wire_cst_list_pending_sweep_balance,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_best_block {
        block_hash: *mut wire_cst_list_prim_u_8_strict,
        height: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bolt_11_invoice {
        signed_raw_invoice: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bolt_12_invoice {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_chain_data_source_config {
        tag: i32,
        kind: ChainDataSourceConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union ChainDataSourceConfigKind {
        Esplora: wire_cst_ChainDataSourceConfig_Esplora,
        Electrum: wire_cst_ChainDataSourceConfig_Electrum,
        BitcoindRpc: wire_cst_ChainDataSourceConfig_BitcoindRpc,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ChainDataSourceConfig_Esplora {
        server_url: *mut wire_cst_list_prim_u_8_strict,
        sync_config: *mut wire_cst_esplora_sync_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ChainDataSourceConfig_Electrum {
        server_url: *mut wire_cst_list_prim_u_8_strict,
        sync_config: *mut wire_cst_electrum_sync_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ChainDataSourceConfig_BitcoindRpc {
        rpc_host: *mut wire_cst_list_prim_u_8_strict,
        rpc_port: u16,
        rpc_user: *mut wire_cst_list_prim_u_8_strict,
        rpc_password: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_info {
        node_one: wire_cst_node_id,
        one_to_two: *mut wire_cst_channel_update_info,
        node_two: wire_cst_node_id,
        two_to_one: *mut wire_cst_channel_update_info,
        capacity_sats: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_update_info {
        last_update: u32,
        enabled: bool,
        cltv_expiry_delta: u16,
        htlc_minimum_msat: u64,
        htlc_maximum_msat: u64,
        fees: wire_cst_routing_fees,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_closure_reason {
        tag: i32,
        kind: ClosureReasonKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union ClosureReasonKind {
        PeerFeerateTooLow: wire_cst_ClosureReason_PeerFeerateTooLow,
        CounterpartyForceClosed: wire_cst_ClosureReason_CounterpartyForceClosed,
        HolderForceClosed: wire_cst_ClosureReason_HolderForceClosed,
        ProcessingError: wire_cst_ClosureReason_ProcessingError,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ClosureReason_PeerFeerateTooLow {
        peer_feerate_sat_per_kw: u32,
        required_feerate_sat_per_kw: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ClosureReason_CounterpartyForceClosed {
        peer_msg: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ClosureReason_HolderForceClosed {
        broadcasted_latest_txn: *mut bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ClosureReason_ProcessingError {
        err: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_config { storage_dir_path: *mut wire_cst_list_prim_u_8_strict,
network: i32,
listening_addresses: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress,
announcement_addresses: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress,
node_alias: *mut wire_cst_node_alias,
trusted_peers_0conf: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey,
probing_liquidity_limit_multiplier: u64,
anchor_channels_config: *mut usize,
sending_parameters: *mut wire_cst_sending_parameters }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_custom_tlv_record {
        type_num: u64,
        value: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_electrum_sync_config {
        background_sync_config: *mut wire_cst_background_sync_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_entropy_source_config {
        tag: i32,
        kind: EntropySourceConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union EntropySourceConfigKind {
        SeedFile: wire_cst_EntropySourceConfig_SeedFile,
        SeedBytes: wire_cst_EntropySourceConfig_SeedBytes,
        Bip39Mnemonic: wire_cst_EntropySourceConfig_Bip39Mnemonic,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EntropySourceConfig_SeedFile {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EntropySourceConfig_SeedBytes {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EntropySourceConfig_Bip39Mnemonic {
        mnemonic: *mut wire_cst_mnemonic,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_esplora_sync_config {
        background_sync_config: *mut wire_cst_background_sync_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_event {
        tag: i32,
        kind: EventKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union EventKind {
        PaymentClaimable: wire_cst_Event_PaymentClaimable,
        PaymentSuccessful: wire_cst_Event_PaymentSuccessful,
        PaymentFailed: wire_cst_Event_PaymentFailed,
        PaymentReceived: wire_cst_Event_PaymentReceived,
        ChannelPending: wire_cst_Event_ChannelPending,
        ChannelReady: wire_cst_Event_ChannelReady,
        ChannelClosed: wire_cst_Event_ChannelClosed,
        PaymentForwarded: wire_cst_Event_PaymentForwarded,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_PaymentClaimable {
        payment_id: *mut wire_cst_payment_id,
        payment_hash: *mut wire_cst_payment_hash,
        claimable_amount_msat: u64,
        claim_deadline: *mut u32,
        custom_records: *mut wire_cst_list_custom_tlv_record,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_PaymentSuccessful {
        payment_id: *mut wire_cst_payment_id,
        payment_hash: *mut wire_cst_payment_hash,
        fee_paid_msat: *mut u64,
        preimage: *mut wire_cst_payment_preimage,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_PaymentFailed {
        payment_id: *mut wire_cst_payment_id,
        payment_hash: *mut wire_cst_payment_hash,
        reason: *mut i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_PaymentReceived {
        payment_id: *mut wire_cst_payment_id,
        payment_hash: *mut wire_cst_payment_hash,
        amount_msat: u64,
        custom_records: *mut wire_cst_list_custom_tlv_record,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_ChannelPending {
        channel_id: usize,
        user_channel_id: usize,
        former_temporary_channel_id: usize,
        counterparty_node_id: usize,
        funding_txo: *mut wire_cst_out_point,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_ChannelReady {
        channel_id: usize,
        user_channel_id: usize,
        counterparty_node_id: *mut usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_ChannelClosed {
        channel_id: usize,
        user_channel_id: usize,
        counterparty_node_id: *mut usize,
        reason: *mut wire_cst_closure_reason,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_Event_PaymentForwarded {
        prev_channel_id: usize,
        next_channel_id: usize,
        prev_user_channel_id: *mut usize,
        next_user_channel_id: *mut usize,
        prev_node_id: *mut usize,
        next_node_id: *mut usize,
        total_fee_earned_msat: *mut u64,
        skimmed_fee_msat: *mut u64,
        claim_from_onchain_tx: bool,
        outbound_amount_forwarded_msat: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_log_record {
        level: i32,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_gossip_source_config {
        tag: i32,
        kind: GossipSourceConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union GossipSourceConfigKind {
        RapidGossipSync: wire_cst_GossipSourceConfig_RapidGossipSync,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_GossipSourceConfig_RapidGossipSync {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_lightning_balance {
        tag: i32,
        kind: LightningBalanceKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union LightningBalanceKind {
        ClaimableOnChannelClose: wire_cst_LightningBalance_ClaimableOnChannelClose,
        ClaimableAwaitingConfirmations: wire_cst_LightningBalance_ClaimableAwaitingConfirmations,
        ContentiousClaimable: wire_cst_LightningBalance_ContentiousClaimable,
        MaybeTimeoutClaimableHTLC: wire_cst_LightningBalance_MaybeTimeoutClaimableHTLC,
        MaybePreimageClaimableHTLC: wire_cst_LightningBalance_MaybePreimageClaimableHTLC,
        CounterpartyRevokedOutputClaimable:
            wire_cst_LightningBalance_CounterpartyRevokedOutputClaimable,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_ClaimableOnChannelClose {
        channel_id: usize,
        counterparty_node_id: usize,
        amount_satoshis: u64,
        transaction_fee_satoshis: u64,
        outbound_payment_htlc_rounded_msat: u64,
        outbound_forwarded_htlc_rounded_msat: u64,
        inbound_claiming_htlc_rounded_msat: u64,
        inbound_htlc_rounded_msat: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_ClaimableAwaitingConfirmations {
        channel_id: usize,
        counterparty_node_id: usize,
        amount_satoshis: u64,
        confirmation_height: u32,
        source: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_ContentiousClaimable {
        channel_id: usize,
        counterparty_node_id: usize,
        amount_satoshis: u64,
        timeout_height: u32,
        payment_hash: *mut wire_cst_payment_hash,
        payment_preimage: *mut wire_cst_payment_preimage,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_MaybeTimeoutClaimableHTLC {
        channel_id: usize,
        counterparty_node_id: usize,
        amount_satoshis: u64,
        claimable_height: u32,
        payment_hash: *mut wire_cst_payment_hash,
        outbound_payment: bool,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_MaybePreimageClaimableHTLC {
        channel_id: usize,
        counterparty_node_id: usize,
        amount_satoshis: u64,
        expiry_height: u32,
        payment_hash: *mut wire_cst_payment_hash,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_LightningBalance_CounterpartyRevokedOutputClaimable {
        channel_id: usize,
        counterparty_node_id: usize,
        amount_satoshis: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_liquidity_source_config { lsps2_service: wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_public_key_opt_string }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_String {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_custom_tlv_record {
        ptr: *mut wire_cst_custom_tlv_record,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_lightning_balance {
        ptr: *mut wire_cst_lightning_balance,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_list_prim_u_8_strict {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_node_id {
        ptr: *mut wire_cst_node_id,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_payment_details {
        ptr: *mut wire_cst_payment_details,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_pending_sweep_balance {
        ptr: *mut wire_cst_pending_sweep_balance,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_64_strict {
        ptr: *mut u64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_loose {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_string_string {
        ptr: *mut wire_cst_record_string_string,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx_in {
        ptr: *mut wire_cst_tx_in,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx_out {
        ptr: *mut wire_cst_tx_out,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_lsp_fee_limits {
        max_total_opening_fee_msat: *mut u64,
        max_proportional_opening_fee_ppm_msat: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_mnemonic {
        words: *mut wire_cst_list_String,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_alias {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_announcement_info { last_update: u32,
alias: *mut wire_cst_list_prim_u_8_strict,
addresses: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_id {
        compressed: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_info {
        channels: *mut wire_cst_list_prim_u_64_strict,
        announcement_info: *mut wire_cst_node_announcement_info,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_status {
        is_running: bool,
        is_listening: bool,
        current_best_block: wire_cst_best_block,
        latest_lightning_wallet_sync_timestamp: *mut u64,
        latest_onchain_wallet_sync_timestamp: *mut u64,
        latest_fee_rate_cache_update_timestamp: *mut u64,
        latest_rgs_snapshot_timestamp: *mut u64,
        latest_node_announcement_broadcast_timestamp: *mut u64,
        latest_channel_monitor_archival_height: *mut u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_offer {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_offer_id {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_out_point {
        txid: wire_cst_txid,
        vout: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_details {
        id: wire_cst_payment_id,
        kind: wire_cst_payment_kind,
        amount_msat: *mut u64,
        direction: i32,
        status: i32,
        latest_update_timestamp: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_hash {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_id {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_kind {
        tag: i32,
        kind: PaymentKindKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union PaymentKindKind {
        Onchain: wire_cst_PaymentKind_Onchain,
        Bolt11: wire_cst_PaymentKind_Bolt11,
        Bolt11Jit: wire_cst_PaymentKind_Bolt11Jit,
        Spontaneous: wire_cst_PaymentKind_Spontaneous,
        Bolt12Offer: wire_cst_PaymentKind_Bolt12Offer,
        Bolt12Refund: wire_cst_PaymentKind_Bolt12Refund,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Onchain {
        txid: *mut wire_cst_txid,
        status: usize,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Bolt11 {
        hash: *mut wire_cst_payment_hash,
        preimage: *mut wire_cst_payment_preimage,
        secret: *mut wire_cst_payment_secret,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Bolt11Jit {
        hash: *mut wire_cst_payment_hash,
        preimage: *mut wire_cst_payment_preimage,
        secret: *mut wire_cst_payment_secret,
        lsp_fee_limits: *mut wire_cst_lsp_fee_limits,
        counterparty_skimmed_fee_msat: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Spontaneous {
        hash: *mut wire_cst_payment_hash,
        preimage: *mut wire_cst_payment_preimage,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Bolt12Offer {
        hash: *mut wire_cst_payment_hash,
        preimage: *mut wire_cst_payment_preimage,
        secret: *mut wire_cst_payment_secret,
        offer_id: *mut wire_cst_offer_id,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
        quantity: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PaymentKind_Bolt12Refund {
        hash: *mut wire_cst_payment_hash,
        preimage: *mut wire_cst_payment_preimage,
        secret: *mut wire_cst_payment_secret,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
        quantity: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_preimage {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_secret {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_pending_sweep_balance {
        tag: i32,
        kind: PendingSweepBalanceKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union PendingSweepBalanceKind {
        PendingBroadcast: wire_cst_PendingSweepBalance_PendingBroadcast,
        BroadcastAwaitingConfirmation: wire_cst_PendingSweepBalance_BroadcastAwaitingConfirmation,
        AwaitingThresholdConfirmations: wire_cst_PendingSweepBalance_AwaitingThresholdConfirmations,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PendingSweepBalance_PendingBroadcast {
        channel_id: *mut usize,
        amount_satoshis: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PendingSweepBalance_BroadcastAwaitingConfirmation {
        channel_id: *mut usize,
        latest_broadcast_height: u32,
        latest_spending_txid: *mut wire_cst_txid,
        amount_satoshis: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_PendingSweepBalance_AwaitingThresholdConfirmations {
        channel_id: *mut usize,
        latest_spending_txid: *mut wire_cst_txid,
        confirmation_hash: *mut wire_cst_list_prim_u_8_strict,
        confirmation_height: u32,
        amount_satoshis: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_psbt {
        inner: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_public_key_opt_string
    {
        field0: usize,
        field1: usize,
        field2: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_string_string {
        field0: *mut wire_cst_list_prim_u_8_strict,
        field1: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_refund {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_routing_fees {
        base_msat: u32,
        proportional_millionths: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_script_buf {
        inner: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sending_parameters {
        max_total_routing_fee_msat: *mut u64,
        max_total_cltv_expiry_delta: *mut u32,
        max_path_count: *mut u8,
        max_channel_saturation_power_of_half: *mut u8,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_in {
        previous_output: wire_cst_out_point,
        script_sig: wire_cst_script_buf,
        sequence: u32,
        witness: *mut wire_cst_list_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_out {
        value: u64,
        script_pubkey: wire_cst_script_buf,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_txid {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_w_txid {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_witness_program {
        version: u8,
        program: *mut wire_cst_list_prim_u_8_strict,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
