// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::extensions::ESocketAddress;
use crate::api::extensions::*;
use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};
use ldk_adapter::bolt11::*;
use ldk_adapter::bolt12::*;
use ldk_adapter::builder::*;
use ldk_adapter::graph::*;
use ldk_adapter::node::*;
use ldk_adapter::on_chain::*;
use ldk_adapter::spontaneous::*;
use ldk_adapter::types::*;
use ldk_adapter::unified_qr::*;
use shared::*;

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 560745451;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__shared__BitcoinAddress_as_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_as_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::BitcoinAddress::as_string(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_auto_accessor_get_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_auto_accessor_get_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inner.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__BitcoinAddress_auto_accessor_set_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
    inner: impl CstDecode<BitcoinAddressInner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_auto_accessor_set_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inner = inner.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inner = api_inner;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__BitcoinAddress_from_script_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    script: impl CstDecode<shared::ScriptBuf>,
    network: impl CstDecode<shared::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_from_script",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_script = script.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            shared::BitcoinAddress::from_script(api_script, api_network)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__BitcoinAddress_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    address: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::BitcoinAddress::from_string(api_address)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__BitcoinAddress_is_valid_for_network_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
    network: impl CstDecode<shared::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_is_valid_for_network",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        shared::BitcoinAddress::is_valid_for_network(&*api_that_guard, api_network),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    address: impl CstDecode<String>,
    network: impl CstDecode<shared::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_address = address.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::BitcoinAddress::new(api_address, api_network)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__BitcoinAddress_script_pubkey_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_script_pubkey",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(shared::BitcoinAddress::script_pubkey(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_to_address_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_to_address_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(shared::BitcoinAddress::to_address_data(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_to_qr_uri_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_to_qr_uri",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::BitcoinAddress::to_qr_uri(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Bolt11Invoice_new_impl(
    signed_raw_invoice: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Invoice_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_signed_raw_invoice = signed_raw_invoice.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(shared::Bolt11Invoice::new(api_signed_raw_invoice))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__Bolt11Invoice_to_string_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Invoice_to_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(shared::Bolt11Invoice::to_string(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_claim_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    payment_hash: impl CstDecode<PaymentHash>,
    claimable_amount_msat: impl CstDecode<u64>,
    preimage: impl CstDecode<PaymentPreimage>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_claim_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            let api_claimable_amount_msat = claimable_amount_msat.cst_decode();
            let api_preimage = preimage.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::claim_for_hash(
                            &*api_that_guard,
                            api_payment_hash,
                            api_claimable_amount_msat,
                            api_preimage,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_fail_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    payment_hash: impl CstDecode<PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_fail_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::fail_for_hash(
                            &*api_that_guard,
                            api_payment_hash,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::receive(
                            &*api_that_guard,
                            api_amount_msat,
                            api_description,
                            api_expiry_secs,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    payment_hash: impl CstDecode<PaymentHash>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::receive_for_hash(
                            &*api_that_guard,
                            api_payment_hash,
                            api_amount_msat,
                            api_description,
                            api_expiry_secs,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::receive_variable_amount(
                                &*api_that_guard,
                                api_description,
                                api_expiry_secs,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    payment_hash: impl CstDecode<PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_variable_amount_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::receive_variable_amount_for_hash(
                                &*api_that_guard,
                                api_description,
                                api_expiry_secs,
                                api_payment_hash,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_proportional_lsp_fee_limit_ppm_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Bolt11Payment_receive_variable_amount_via_jit_channel", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_description = description.cst_decode();let api_expiry_secs = expiry_secs.cst_decode();let api_max_proportional_lsp_fee_limit_ppm_msat = max_proportional_lsp_fee_limit_ppm_msat.cst_decode(); move |context|  {
                    transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = ldk_adapter::bolt11::Bolt11Payment::receive_variable_amount_via_jit_channel(&*api_that_guard, api_description, api_expiry_secs, api_max_proportional_lsp_fee_limit_ppm_msat)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_total_lsp_fee_limit_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_via_jit_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_max_total_lsp_fee_limit_msat = max_total_lsp_fee_limit_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::receive_via_jit_channel(
                                &*api_that_guard,
                                api_amount_msat,
                                api_description,
                                api_expiry_secs,
                                api_max_total_lsp_fee_limit_msat,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<Bolt11Invoice>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::send(
                            &*api_that_guard,
                            api_invoice,
                            api_sending_parameters,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<Bolt11Invoice>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::send_probes(
                            &*api_that_guard,
                            api_invoice,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send_probes_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::send_probes_using_amount(
                                &*api_that_guard,
                                api_invoice,
                                api_amount_msat,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::send_using_amount(
                            &*api_that_guard,
                            api_invoice,
                            api_amount_msat,
                            api_sending_parameters,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_initiate_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    expiry_secs: impl CstDecode<u32>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_initiate_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::initiate_refund(
                            &*api_that_guard,
                            api_amount_msat,
                            api_expiry_secs,
                            api_quantity,
                            api_payer_note,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<Option<u32>>,
    quantity: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_quantity = quantity.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::receive(
                            &*api_that_guard,
                            api_amount_msat,
                            api_description,
                            api_expiry_secs,
                            api_quantity,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt12::Bolt12Payment::receive_variable_amount(
                                &*api_that_guard,
                                api_description,
                                api_expiry_secs,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_request_refund_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    refund: impl CstDecode<shared::Refund>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_request_refund_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_refund = refund.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::request_refund_payment(
                            &*api_that_guard,
                            api_refund,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    offer: impl CstDecode<shared::Offer>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offer = offer.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::send(
                            &*api_that_guard,
                            api_offer,
                            api_quantity,
                            api_payer_note,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    offer: impl CstDecode<shared::Offer>,
    amount_msat: impl CstDecode<u64>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offer = offer.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::send_using_amount(
                            &*api_that_guard,
                            api_offer,
                            api_amount_msat,
                            api_quantity,
                            api_payer_note,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_accept_underpaying_htlcs_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_accept_underpaying_htlcs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.accept_underpaying_htlcs.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.cltv_expiry_delta.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .force_close_avoidance_max_fee_satoshis
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_forwarding_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.forwarding_fee_base_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .forwarding_fee_proportional_millionths
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_max_dust_htlc_exposure_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_max_dust_htlc_exposure",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.max_dust_htlc_exposure.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_accept_underpaying_htlcs_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    accept_underpaying_htlcs: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_accept_underpaying_htlcs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_accept_underpaying_htlcs = accept_underpaying_htlcs.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.accept_underpaying_htlcs = api_accept_underpaying_htlcs;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    cltv_expiry_delta: impl CstDecode<u16>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_cltv_expiry_delta = cltv_expiry_delta.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.cltv_expiry_delta = api_cltv_expiry_delta;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    force_close_avoidance_max_fee_satoshis: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_force_close_avoidance_max_fee_satoshis =
                force_close_avoidance_max_fee_satoshis.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.force_close_avoidance_max_fee_satoshis =
                            api_force_close_avoidance_max_fee_satoshis;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    forwarding_fee_base_msat: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_forwarding_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_forwarding_fee_base_msat = forwarding_fee_base_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.forwarding_fee_base_msat = api_forwarding_fee_base_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    forwarding_fee_proportional_millionths: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_forwarding_fee_proportional_millionths =
                forwarding_fee_proportional_millionths.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.forwarding_fee_proportional_millionths =
                            api_forwarding_fee_proportional_millionths;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_max_dust_htlc_exposure_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    max_dust_htlc_exposure: impl CstDecode<MaxDustHTLCExposure>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_max_dust_htlc_exposure",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_max_dust_htlc_exposure = max_dust_htlc_exposure.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.max_dust_htlc_exposure = api_max_dust_htlc_exposure;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_calculate_forwarding_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_calculate_forwarding_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::ChannelConfig::calculate_forwarding_fee(
                            &*api_that_guard,
                            api_amount_msat,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_high_fee_routing_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_high_fee_routing",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelConfig::high_fee_routing())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_low_fee_routing_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_low_fee_routing",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelConfig::low_fee_routing())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    forwarding_fee_proportional_millionths: impl CstDecode<u32>,
    forwarding_fee_base_msat: impl CstDecode<u32>,
    cltv_expiry_delta: impl CstDecode<u16>,
    max_dust_htlc_exposure: impl CstDecode<MaxDustHTLCExposure>,
    force_close_avoidance_max_fee_satoshis: impl CstDecode<u64>,
    accept_underpaying_htlcs: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_forwarding_fee_proportional_millionths =
                forwarding_fee_proportional_millionths.cst_decode();
            let api_forwarding_fee_base_msat = forwarding_fee_base_msat.cst_decode();
            let api_cltv_expiry_delta = cltv_expiry_delta.cst_decode();
            let api_max_dust_htlc_exposure = max_dust_htlc_exposure.cst_decode();
            let api_force_close_avoidance_max_fee_satoshis =
                force_close_avoidance_max_fee_satoshis.cst_decode();
            let api_accept_underpaying_htlcs = accept_underpaying_htlcs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::ChannelConfig::new(
                        api_forwarding_fee_proportional_millionths,
                        api_forwarding_fee_base_msat,
                        api_cltv_expiry_delta,
                        api_max_dust_htlc_exposure,
                        api_force_close_avoidance_max_fee_satoshis,
                        api_accept_underpaying_htlcs,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.channel_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_value_sats_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_channel_value_sats",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.channel_value_sats.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.cltv_expiry_delta.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_config_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_config",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.config.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_confirmations",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.confirmations.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_required_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_confirmations_required",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.confirmations_required.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_forwarding_info_cltv_expiry_delta
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_forwarding_info_fee_base_msat
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { let api_that = that.cst_decode();
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(api_that_guard.counterparty_forwarding_info_fee_proportional_millionths.clone())?;   Ok(output_ok)
                })()) })
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_counterparty_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.counterparty_node_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_outbound_htlc_maximum_msat
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_outbound_htlc_minimum_msat
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_unspendable_punishment_reserve
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.feerate_sat_per_1000_weight.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_force_close_spend_delay_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_force_close_spend_delay",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.force_close_spend_delay.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_funding_txo_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_funding_txo",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.funding_txo.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_inbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inbound_capacity_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.inbound_htlc_maximum_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.inbound_htlc_minimum_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_channel_ready_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_is_channel_ready",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_channel_ready.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_outbound_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_is_outbound",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_outbound.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_usable_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_is_usable",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_usable.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.next_outbound_htlc_limit_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.next_outbound_htlc_minimum_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_outbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_outbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.outbound_capacity_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.unspendable_punishment_reserve.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_user_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_user_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.user_channel_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    channel_id: impl CstDecode<ChannelId>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_channel_id = channel_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.channel_id = api_channel_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_value_sats_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    channel_value_sats: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_channel_value_sats",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_channel_value_sats = channel_value_sats.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.channel_value_sats = api_channel_value_sats;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    cltv_expiry_delta: impl CstDecode<Option<u16>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_cltv_expiry_delta = cltv_expiry_delta.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.cltv_expiry_delta = api_cltv_expiry_delta;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_config_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    config: impl CstDecode<ChannelConfig>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_config",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_config = config.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.config = api_config;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    confirmations: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_confirmations",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_confirmations = confirmations.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.confirmations = api_confirmations;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_required_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    confirmations_required: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_confirmations_required",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_confirmations_required = confirmations_required.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.confirmations_required = api_confirmations_required;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_forwarding_info_cltv_expiry_delta: impl CstDecode<Option<u16>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_forwarding_info_cltv_expiry_delta =
                counterparty_forwarding_info_cltv_expiry_delta.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_forwarding_info_cltv_expiry_delta =
                            api_counterparty_forwarding_info_cltv_expiry_delta;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_forwarding_info_fee_base_msat: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_forwarding_info_fee_base_msat =
                counterparty_forwarding_info_fee_base_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_forwarding_info_fee_base_msat =
                            api_counterparty_forwarding_info_fee_base_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_forwarding_info_fee_proportional_millionths: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { let api_that = that.cst_decode();let api_counterparty_forwarding_info_fee_proportional_millionths = counterparty_forwarding_info_fee_proportional_millionths.cst_decode();
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ { api_that_guard.counterparty_forwarding_info_fee_proportional_millionths = api_counterparty_forwarding_info_fee_proportional_millionths; }; })?;   Ok(output_ok)
                })()) })
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_node_id: impl CstDecode<PublicKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_counterparty_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_node_id = api_counterparty_node_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_outbound_htlc_maximum_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_outbound_htlc_maximum_msat =
                counterparty_outbound_htlc_maximum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_outbound_htlc_maximum_msat =
                            api_counterparty_outbound_htlc_maximum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_outbound_htlc_minimum_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_outbound_htlc_minimum_msat =
                counterparty_outbound_htlc_minimum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_outbound_htlc_minimum_msat =
                            api_counterparty_outbound_htlc_minimum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_unspendable_punishment_reserve: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_unspendable_punishment_reserve =
                counterparty_unspendable_punishment_reserve.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_unspendable_punishment_reserve =
                            api_counterparty_unspendable_punishment_reserve;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    feerate_sat_per_1000_weight: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_feerate_sat_per_1000_weight = feerate_sat_per_1000_weight.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.feerate_sat_per_1000_weight =
                            api_feerate_sat_per_1000_weight;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_force_close_spend_delay_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    force_close_spend_delay: impl CstDecode<Option<u16>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_force_close_spend_delay",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_force_close_spend_delay = force_close_spend_delay.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.force_close_spend_delay = api_force_close_spend_delay;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_funding_txo_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    funding_txo: impl CstDecode<Option<shared::OutPoint>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_funding_txo",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_funding_txo = funding_txo.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.funding_txo = api_funding_txo;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    inbound_capacity_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_inbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inbound_capacity_msat = inbound_capacity_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inbound_capacity_msat = api_inbound_capacity_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    inbound_htlc_maximum_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inbound_htlc_maximum_msat = inbound_htlc_maximum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inbound_htlc_maximum_msat = api_inbound_htlc_maximum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    inbound_htlc_minimum_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inbound_htlc_minimum_msat = inbound_htlc_minimum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inbound_htlc_minimum_msat = api_inbound_htlc_minimum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_channel_ready_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    is_channel_ready: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_is_channel_ready",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_channel_ready = is_channel_ready.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_channel_ready = api_is_channel_ready;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_outbound_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    is_outbound: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_is_outbound",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_outbound = is_outbound.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_outbound = api_is_outbound;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_usable_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    is_usable: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_is_usable",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_usable = is_usable.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_usable = api_is_usable;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    next_outbound_htlc_limit_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_next_outbound_htlc_limit_msat = next_outbound_htlc_limit_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.next_outbound_htlc_limit_msat =
                            api_next_outbound_htlc_limit_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    next_outbound_htlc_minimum_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_next_outbound_htlc_minimum_msat = next_outbound_htlc_minimum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.next_outbound_htlc_minimum_msat =
                            api_next_outbound_htlc_minimum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_outbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    outbound_capacity_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_outbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_outbound_capacity_msat = outbound_capacity_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.outbound_capacity_msat = api_outbound_capacity_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    unspendable_punishment_reserve: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_unspendable_punishment_reserve = unspendable_punishment_reserve.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.unspendable_punishment_reserve =
                            api_unspendable_punishment_reserve;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_user_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    user_channel_id: impl CstDecode<UserChannelId>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_user_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.user_channel_id = api_user_channel_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_balance_ratio_percent_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_balance_ratio_percent",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::ChannelDetails::balance_ratio_percent(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_can_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_can_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelDetails::can_receive(
                            &*api_that_guard,
                            api_amount_msat,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_can_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_can_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelDetails::can_send(
                            &*api_that_guard,
                            api_amount_msat,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_capacity_sats_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_capacity_sats",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::ChannelDetails::capacity_sats(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    channel_id: impl CstDecode<ChannelId>,
    counterparty_node_id: impl CstDecode<PublicKey>,
    funding_txo: impl CstDecode<Option<shared::OutPoint>>,
    channel_value_sats: impl CstDecode<u64>,
    unspendable_punishment_reserve: impl CstDecode<Option<u64>>,
    user_channel_id: impl CstDecode<UserChannelId>,
    feerate_sat_per_1000_weight: impl CstDecode<u32>,
    outbound_capacity_msat: impl CstDecode<u64>,
    inbound_capacity_msat: impl CstDecode<u64>,
    is_outbound: impl CstDecode<bool>,
    is_channel_ready: impl CstDecode<bool>,
    is_usable: impl CstDecode<bool>,
    config: impl CstDecode<ChannelConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_channel_id = channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            let api_funding_txo = funding_txo.cst_decode();
            let api_channel_value_sats = channel_value_sats.cst_decode();
            let api_unspendable_punishment_reserve = unspendable_punishment_reserve.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_feerate_sat_per_1000_weight = feerate_sat_per_1000_weight.cst_decode();
            let api_outbound_capacity_msat = outbound_capacity_msat.cst_decode();
            let api_inbound_capacity_msat = inbound_capacity_msat.cst_decode();
            let api_is_outbound = is_outbound.cst_decode();
            let api_is_channel_ready = is_channel_ready.cst_decode();
            let api_is_usable = is_usable.cst_decode();
            let api_config = config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::ChannelDetails::new(
                        api_channel_id,
                        api_counterparty_node_id,
                        api_funding_txo,
                        api_channel_value_sats,
                        api_unspendable_punishment_reserve,
                        api_user_channel_id,
                        api_feerate_sat_per_1000_weight,
                        api_outbound_capacity_msat,
                        api_inbound_capacity_msat,
                        api_is_outbound,
                        api_is_channel_ready,
                        api_is_usable,
                        api_config,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_total_liquidity_msat_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_total_liquidity_msat",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::ChannelDetails::total_liquidity_msat(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelId_as_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelId_as_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::ChannelId::as_bytes(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelId_from_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelId_from_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_bytes = bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::ChannelId::from_bytes(&api_bytes))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelId_new_impl(
    data: impl CstDecode<[u8; 32]>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelId_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_data = data.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::ChannelId::new(api_data))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_build_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<LdkBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_build",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::LdkBuilder::build(api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_build_with_fs_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<LdkBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_build_with_fs_store",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            ldk_adapter::builder::LdkBuilder::build_with_fs_store(api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>,
    >,
    vss_url: impl CstDecode<String>,
    store_id: impl CstDecode<String>,
    lnurl_auth_server_url: impl CstDecode<String>,
    fixed_headers: impl CstDecode<std::collections::HashMap<String, String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_build_with_vss_store",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_vss_url = vss_url.cst_decode();
            let api_store_id = store_id.cst_decode();
            let api_lnurl_auth_server_url = lnurl_auth_server_url.cst_decode();
            let api_fixed_headers = fixed_headers.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::builder::LdkBuilder::build_with_vss_store(
                            &*api_that_guard,
                            api_vss_url,
                            api_store_id,
                            api_lnurl_auth_server_url,
                            api_fixed_headers,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store_and_fixed_headers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>,
    >,
    vss_url: impl CstDecode<String>,
    store_id: impl CstDecode<String>,
    fixed_headers: impl CstDecode<std::collections::HashMap<String, String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "LdkBuilder_build_with_vss_store_and_fixed_headers", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_vss_url = vss_url.cst_decode();let api_store_id = store_id.cst_decode();let api_fixed_headers = fixed_headers.cst_decode(); move |context|  {
                    transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = ldk_adapter::builder::LdkBuilder::build_with_vss_store_and_fixed_headers(&*api_that_guard, api_vss_url, api_store_id, api_fixed_headers)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__ldk_adapter__builder__LdkBuilder_create_builder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    config: impl CstDecode<crate::api::extensions::Config>,
    chain_data_source_config: impl CstDecode<Option<crate::api::extensions::ChainDataSourceConfig>>,
    entropy_source_config: impl CstDecode<Option<crate::api::extensions::EntropySourceConfig>>,
    gossip_source_config: impl CstDecode<Option<crate::api::extensions::GossipSourceConfig>>,
    liquidity_source_config: impl CstDecode<Option<ldk_adapter::types::LiquiditySourceConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_create_builder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_config = config.cst_decode();
            let api_chain_data_source_config = chain_data_source_config.cst_decode();
            let api_entropy_source_config = entropy_source_config.cst_decode();
            let api_gossip_source_config = gossip_source_config.cst_decode();
            let api_liquidity_source_config = liquidity_source_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::LdkBuilder::create_builder(
                            api_config,
                            api_chain_data_source_config,
                            api_entropy_source_config,
                            api_gossip_source_config,
                            api_liquidity_source_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_set_entropy_seed_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<LdkBuilder>,
    seed_bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_set_entropy_seed_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_seed_bytes = seed_bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::LdkBuilder::set_entropy_seed_bytes(
                            api_that,
                            api_seed_bytes,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_set_filesystem_logger_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<LdkBuilder>,
    log_file_path: impl CstDecode<Option<String>>,
    max_log_level: impl CstDecode<Option<ldk_adapter::types::LogLevel>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_set_filesystem_logger",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_log_file_path = log_file_path.cst_decode();
            let api_max_log_level = max_log_level.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::LdkBuilder::set_filesystem_logger(
                            api_that,
                            api_log_file_path,
                            api_max_log_level,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__LdkBuilder_set_log_facade_logger_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<LdkBuilder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LdkBuilder_set_log_facade_logger",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            ldk_adapter::builder::LdkBuilder::set_log_facade_logger(api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__MaxDustHtlcExposure_conservative_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MaxDustHtlcExposure_conservative",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::MaxDustHTLCExposure::conservative(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__MaxDustHtlcExposure_default_fee_rate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MaxDustHtlcExposure_default_fee_rate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::MaxDustHTLCExposure::default_fee_rate(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__MaxDustHtlcExposure_new_fee_rate_multiplier_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    multiplier: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MaxDustHtlcExposure_new_fee_rate_multiplier",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_multiplier = multiplier.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::MaxDustHTLCExposure::new_fee_rate_multiplier(
                            api_multiplier,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__MaxDustHtlcExposure_new_fixed_limit_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    limit_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MaxDustHtlcExposure_new_fixed_limit",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_limit_msat = limit_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::MaxDustHTLCExposure::new_fixed_limit(api_limit_msat),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
    short_channel_id: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_short_channel_id = short_channel_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::graph::NetworkGraph::channel(
                            &*api_that_guard,
                            api_short_channel_id,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::graph::NetworkGraph::list_channels(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_list_nodes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_list_nodes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::graph::NetworkGraph::list_nodes(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
    node_id: impl CstDecode<ldk_adapter::graph::NodeId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::graph::NetworkGraph::node(&*api_that_guard, api_node_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_bolt11_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_bolt11_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::bolt11_payment(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_bolt12_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_bolt12_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::bolt12_payment(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    user_channel_id: impl CstDecode<UserChannelId>,
    counterparty_node_id: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::close_channel(
                            &*api_that_guard,
                            api_user_channel_id,
                            api_counterparty_node_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::config(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_connect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    node_id: impl CstDecode<PublicKey>,
    address: impl CstDecode<SocketAddress>,
    persist: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_connect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            let api_persist = persist.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::connect(
                            &*api_that_guard,
                            api_node_id,
                            api_address,
                            api_persist,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_disconnect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    counterparty_node_id: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_disconnect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::disconnect(
                            &*api_that_guard,
                            api_counterparty_node_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_event_handled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_event_handled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::event_handled(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_export_pathfinding_scores_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_export_pathfinding_scores",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::node::Node::export_pathfinding_scores(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_force_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    user_channel_id: impl CstDecode<UserChannelId>,
    counterparty_node_id: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_force_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::force_close_channel(
                            &*api_that_guard,
                            api_user_channel_id,
                            api_counterparty_node_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::list_balances(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::list_channels(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_payments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_payments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::list_payments(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_payments_with_filter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    payment_direction: impl CstDecode<ldk_adapter::types::PaymentDirection>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_payments_with_filter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_direction = payment_direction.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::list_payments_with_filter(
                            &*api_that_guard,
                            api_payment_direction,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::list_peers(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_listening_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_listening_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::node::Node::listening_addresses(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_network_graph_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_network_graph",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::network_graph(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::next_event(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_next_event_async_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_next_event_async",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            ldk_adapter::node::Node::next_event_async(&*api_that_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_node_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_node_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::node_id(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_on_chain_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_on_chain_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::node::Node::on_chain_payment(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_open_announced_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    socket_address: impl CstDecode<SocketAddress>,
    node_id: impl CstDecode<PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    channel_config: impl CstDecode<Option<ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_open_announced_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_socket_address = socket_address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::open_announced_channel(
                            &*api_that_guard,
                            api_socket_address,
                            api_node_id,
                            api_channel_amount_sats,
                            api_push_to_counterparty_msat,
                            api_channel_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_open_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    socket_address: impl CstDecode<SocketAddress>,
    node_id: impl CstDecode<PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    channel_config: impl CstDecode<Option<ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_open_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_socket_address = socket_address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::open_channel(
                            &*api_that_guard,
                            api_socket_address,
                            api_node_id,
                            api_channel_amount_sats,
                            api_push_to_counterparty_msat,
                            api_channel_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    payment_id: impl CstDecode<PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::payment(
                        &*api_that_guard,
                        api_payment_id,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_remove_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    payment_id: impl CstDecode<PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_remove_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::remove_payment(
                            &*api_that_guard,
                            api_payment_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_sign_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    msg: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_sign_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::sign_message(
                        &*api_that_guard,
                        api_msg,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_spontaneous_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_spontaneous_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::node::Node::spontaneous_payment(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::start(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::status(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_stop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_stop",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::stop(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_sync_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_sync_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::sync_wallets(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_unified_qr_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_unified_qr_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::node::Node::unified_qr_payment(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_update_channel_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    user_channel_id: impl CstDecode<UserChannelId>,
    counterparty_node_id: impl CstDecode<PublicKey>,
    channel_config: impl CstDecode<ChannelConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_update_channel_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::update_channel_config(
                            &*api_that_guard,
                            api_user_channel_id,
                            api_counterparty_node_id,
                            api_channel_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_verify_signature_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    msg: impl CstDecode<Vec<u8>>,
    sig: impl CstDecode<String>,
    public_key: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_verify_signature",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            let api_sig = sig.cst_decode();
            let api_public_key = public_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::verify_signature(
                            &*api_that_guard,
                            api_msg,
                            api_sig,
                            api_public_key,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_wait_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_wait_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::wait_next_event(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__on_chain__OnChainPayment_new_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnChainPayment_new_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::on_chain::OnChainPayment::new_address(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__on_chain__OnChainPayment_send_all_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
    >,
    address: impl CstDecode<BitcoinAddress>,
    retain_reserves: impl CstDecode<bool>,
    fee_rate_sat_per_kwu: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnChainPayment_send_all_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_retain_reserves = retain_reserves.cst_decode();
            let api_fee_rate_sat_per_kwu = fee_rate_sat_per_kwu.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::on_chain::OnChainPayment::send_all_to_address(
                            &*api_that_guard,
                            api_address,
                            api_retain_reserves,
                            api_fee_rate_sat_per_kwu,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__on_chain__OnChainPayment_send_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
    >,
    address: impl CstDecode<BitcoinAddress>,
    amount_sats: impl CstDecode<u64>,
    fee_rate_sat_per_kwu: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnChainPayment_send_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            let api_fee_rate_sat_per_kwu = fee_rate_sat_per_kwu.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::on_chain::OnChainPayment::send_to_address(
                            &*api_that_guard,
                            api_address,
                            api_amount_sats,
                            api_fee_rate_sat_per_kwu,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_amount_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_amount_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.amount_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_direction_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_direction",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.direction.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_kind_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_kind",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.kind.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_latest_update_timestamp_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_latest_update_timestamp",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.latest_update_timestamp.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_status_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_status",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.status.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_amount_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    amount_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_amount_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.amount_msat = api_amount_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_direction_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    direction: impl CstDecode<ldk_adapter::types::PaymentDirection>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_direction",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_direction = direction.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.direction = api_direction;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    id: impl CstDecode<PaymentId>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_id = id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.id = api_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_kind_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    kind: impl CstDecode<PaymentKind>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_kind",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_kind = kind.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.kind = api_kind;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_latest_update_timestamp_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    latest_update_timestamp: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_latest_update_timestamp",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_latest_update_timestamp = latest_update_timestamp.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.latest_update_timestamp = api_latest_update_timestamp;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_status_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    status: impl CstDecode<ldk_adapter::types::PaymentStatus>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_status",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_status = status.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.status = api_status;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_is_failed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_is_failed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentDetails::is_failed(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_is_pending_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_is_pending",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentDetails::is_pending(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_is_succeeded_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_is_succeeded",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentDetails::is_succeeded(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<PaymentId>,
    kind: impl CstDecode<PaymentKind>,
    amount_msat: impl CstDecode<Option<u64>>,
    direction: impl CstDecode<ldk_adapter::types::PaymentDirection>,
    status: impl CstDecode<ldk_adapter::types::PaymentStatus>,
    latest_update_timestamp: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_direction = direction.cst_decode();
            let api_status = status.cst_decode();
            let api_latest_update_timestamp = latest_update_timestamp.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::PaymentDetails::new(
                        api_id,
                        api_kind,
                        api_amount_msat,
                        api_direction,
                        api_status,
                        api_latest_update_timestamp,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_new_inbound_pending_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<PaymentId>,
    kind: impl CstDecode<PaymentKind>,
    amount_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_new_inbound_pending",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentDetails::new_inbound_pending(
                            api_id,
                            api_kind,
                            api_amount_msat,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_new_outbound_pending_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<PaymentId>,
    kind: impl CstDecode<PaymentKind>,
    amount_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_new_outbound_pending",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentDetails::new_outbound_pending(
                            api_id,
                            api_kind,
                            api_amount_msat,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__PaymentHash_new_impl(
    data: impl CstDecode<[u8; 32]>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentHash_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_data = data.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(shared::PaymentHash::new(api_data))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__PaymentHash_to_vec_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentHash>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentHash_to_vec",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(shared::PaymentHash::to_vec(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__PaymentId_new_impl(
    data: impl CstDecode<Vec<u8>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentId_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_data = data.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(shared::PaymentId::new(api_data))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__PaymentId_to_vec_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentId>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentId_to_vec",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(shared::PaymentId::to_vec(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__PaymentPreimage_new_impl(
    data: impl CstDecode<[u8; 32]>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentPreimage_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_data = data.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(shared::PaymentPreimage::new(api_data))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__PaymentPreimage_to_vec_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentPreimage>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentPreimage_to_vec",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(shared::PaymentPreimage::to_vec(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_get_address_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_get_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.address.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_get_is_connected_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_get_is_connected",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_connected.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_get_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_get_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.node_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_set_address_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
    address: impl CstDecode<SocketAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_set_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.address = api_address;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_set_is_connected_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
    is_connected: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_set_is_connected",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_connected = is_connected.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_connected = api_is_connected;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_set_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
    node_id: impl CstDecode<PublicKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_set_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.node_id = api_node_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_is_offline_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_is_offline",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PeerDetails::is_offline(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_is_online_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_is_online",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PeerDetails::is_online(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    node_id: impl CstDecode<PublicKey>,
    address: impl CstDecode<SocketAddress>,
    is_connected: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            let api_is_connected = is_connected.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::PeerDetails::new(
                        api_node_id,
                        api_address,
                        api_is_connected,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_new_connected_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    node_id: impl CstDecode<PublicKey>,
    address: impl CstDecode<SocketAddress>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_new_connected",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PeerDetails::new_connected(api_node_id, api_address),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_new_disconnected_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    node_id: impl CstDecode<PublicKey>,
    address: impl CstDecode<SocketAddress>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_new_disconnected",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PeerDetails::new_disconnected(api_node_id, api_address),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__PublicKey_new_impl(
    hex: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PublicKey_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_hex = hex.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(shared::PublicKey::new(api_hex))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__PublicKey_to_string_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PublicKey_to_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(shared::PublicKey::to_string(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__SocketAddress_address_type_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_address_type",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::SocketAddress::address_type(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__SocketAddress_to_hostname_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_to_hostname",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::SocketAddress::to_hostname(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__SocketAddress_to_onion_v2_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_to_onion_v2",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::SocketAddress::to_onion_v2(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__SocketAddress_to_onion_v3_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_to_onion_v3",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::SocketAddress::to_onion_v3(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__SocketAddress_to_tcp_ip_v4_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_to_tcp_ip_v4",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::SocketAddress::to_tcp_ip_v4(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__SocketAddress_to_tcp_ip_v6_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SocketAddress_to_tcp_ip_v6",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::SocketAddress::to_tcp_ip_v6(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__spontaneous__SpontaneousPayment_send_probes_unsafe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SpontaneousPayment_send_probes_unsafe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::spontaneous::SpontaneousPayment::send_probes_unsafe(
                                &*api_that_guard,
                                api_amount_msat,
                                api_node_id,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__spontaneous__SpontaneousPayment_send_unsafe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<PublicKey>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SpontaneousPayment_send_unsafe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::spontaneous::SpontaneousPayment::send_unsafe(
                            &*api_that_guard,
                            api_amount_msat,
                            api_node_id,
                            api_sending_parameters,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__spontaneous__SpontaneousPayment_send_with_custom_tlvs_unsafe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<PublicKey>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
    custom_tlvs: impl CstDecode<Vec<ldk_adapter::types::CustomTlvRecord>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SpontaneousPayment_send_with_custom_tlvs_unsafe", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_amount_msat = amount_msat.cst_decode();let api_node_id = node_id.cst_decode();let api_sending_parameters = sending_parameters.cst_decode();let api_custom_tlvs = custom_tlvs.cst_decode(); move |context|  {
                    transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = ldk_adapter::spontaneous::SpontaneousPayment::send_with_custom_tlvs_unsafe(&*api_that_guard, api_amount_msat, api_node_id, api_sending_parameters, api_custom_tlvs)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__shared__TaprootSpendInfo_auto_accessor_get_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TaprootSpendInfo_auto_accessor_get_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inner.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__TaprootSpendInfo_auto_accessor_set_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>,
    >,
    inner: impl CstDecode<TaprootSpendInfoInner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TaprootSpendInfo_auto_accessor_set_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inner = inner.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inner = api_inner;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__Transaction_auto_accessor_get_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_auto_accessor_get_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inner.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__Transaction_auto_accessor_set_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
    inner: impl CstDecode<BitcoinTransactionInner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_auto_accessor_set_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inner = inner.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inner = api_inner;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__Transaction_compute_txid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_compute_txid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::compute_txid(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_compute_wtxid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_compute_wtxid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::compute_wtxid(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_input_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_input",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::input(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_is_coinbase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_is_coinbase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::is_coinbase(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_is_explicitly_rbf_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_is_explicitly_rbf",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(shared::Transaction::is_explicitly_rbf(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_is_lock_time_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_is_lock_time_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        shared::Transaction::is_lock_time_enabled(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_lock_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_lock_time",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::lock_time(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    transaction_bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_transaction_bytes = transaction_bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Transaction::new(api_transaction_bytes)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__Transaction_output_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_output",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::output(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_total_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_total_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::total_size(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_version_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_version",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::version(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_vsize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_vsize",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::vsize(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_weight_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_weight",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::weight(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__unified_qr__UnifiedQrPayment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>,
    >,
    amount_sats: impl CstDecode<u64>,
    message: impl CstDecode<String>,
    expiry_sec: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UnifiedQrPayment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            let api_message = message.cst_decode();
            let api_expiry_sec = expiry_sec.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::unified_qr::UnifiedQrPayment::receive(
                            &*api_that_guard,
                            api_amount_sats,
                            api_message,
                            api_expiry_sec,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__unified_qr__UnifiedQrPayment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>,
    >,
    uri_str: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UnifiedQrPayment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_uri_str = uri_str.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::unified_qr::UnifiedQrPayment::send(
                            &*api_that_guard,
                            api_uri_str,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_as_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_as_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok({
                        ldk_adapter::types::UserChannelId::as_bytes(&*api_that_guard);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_as_vec_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_as_vec",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::UserChannelId::as_vec(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    s: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_s = s.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::UserChannelId::from_string(&api_s),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_from_u64_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_from_u64",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::UserChannelId::from_u64(api_id))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__UserChannelId_new_impl(
    data: impl CstDecode<Vec<u8>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UserChannelId_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_data = data.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok =
                    Result::<_, ()>::Ok(ldk_adapter::types::UserChannelId::new(api_data))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__address_hostname_as_socket_impl(
    that: impl CstDecode<crate::api::extensions::AddressHostname>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "address_hostname_as_socket",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::AddressHostname::as_socket(api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__address_onion_v_2_as_socket_impl(
    that: impl CstDecode<crate::api::extensions::AddressOnionV2>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "address_onion_v_2_as_socket",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::AddressOnionV2::as_socket(api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__address_onion_v_3_as_socket_impl(
    that: impl CstDecode<crate::api::extensions::AddressOnionV3>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "address_onion_v_3_as_socket",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::AddressOnionV3::as_socket(api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__address_tcp_ip_v_4_as_socket_impl(
    that: impl CstDecode<crate::api::extensions::AddressTcpIpV4>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "address_tcp_ip_v_4_as_socket",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::AddressTcpIpV4::as_socket(api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__extensions__address_tcp_ip_v_6_as_socket_impl(
    that: impl CstDecode<crate::api::extensions::AddressTcpIpV6>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "address_tcp_ip_v_6_as_socket",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::extensions::AddressTcpIpV6::as_socket(api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__anchor_channels_config_conservative_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "anchor_channels_config_conservative",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::AnchorChannelsConfig::conservative(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__anchor_channels_config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "anchor_channels_config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::AnchorChannelsConfig::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__anchor_channels_config_is_peer_trusted_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::AnchorChannelsConfig>,
    peer: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "anchor_channels_config_is_peer_trusted",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_peer = peer.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_peer_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_peer, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_peer_guard = Some(api_peer.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_peer_guard = api_peer_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::AnchorChannelsConfig::is_peer_trusted(
                            &api_that,
                            &*api_peer_guard,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__anchor_channels_config_low_reserve_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "anchor_channels_config_low_reserve",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::AnchorChannelsConfig::low_reserve(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__anchor_channels_config_trusted_peers_count_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::AnchorChannelsConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "anchor_channels_config_trusted_peers_count",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::AnchorChannelsConfig::trusted_peers_count(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__anchor_channels_config_with_trusted_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    trusted_peers: impl CstDecode<Vec<PublicKey>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "anchor_channels_config_with_trusted_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_trusted_peers = trusted_peers.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::AnchorChannelsConfig::with_trusted_peers(
                            api_trusted_peers,
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__extensions__config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::extensions::Config::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__custom_tlv_record_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    type_num: impl CstDecode<u64>,
    value: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "custom_tlv_record_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_type_num = type_num.cst_decode();
            let api_value = value.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::CustomTlvRecord::from_string(api_type_num, &api_value),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__custom_tlv_record_from_u64_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    type_num: impl CstDecode<u64>,
    value: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "custom_tlv_record_from_u64",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_type_num = type_num.cst_decode();
            let api_value = value.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::CustomTlvRecord::from_u64(api_type_num, api_value),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__custom_tlv_record_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    type_num: impl CstDecode<u64>,
    value: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "custom_tlv_record_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_type_num = type_num.cst_decode();
            let api_value = value.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::CustomTlvRecord::new(
                        api_type_num,
                        api_value,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__custom_tlv_record_value_as_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::CustomTlvRecord>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "custom_tlv_record_value_as_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::CustomTlvRecord::value_as_string(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_debug_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_debug",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::debug(
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_error_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_error",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::error(
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_formatted_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::FfiLogRecord>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_formatted",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::FfiLogRecord::formatted(&api_that),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_info_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_info",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::info(
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_is_error_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::FfiLogRecord>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_is_error",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::is_error(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_is_warn_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::FfiLogRecord>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_is_warn",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::is_warn(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    level: impl CstDecode<ldk_adapter::types::LogLevel>,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_level = level.cst_decode();
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::new(
                        api_level,
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_trace_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_trace",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::trace(
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__ffi_log_record_warn_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    args: impl CstDecode<String>,
    module_path: impl CstDecode<String>,
    line: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ffi_log_record_warn",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_args = args.cst_decode();
            let api_module_path = module_path.cst_decode();
            let api_line = line.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::FfiLogRecord::warn(
                        api_args,
                        api_module_path,
                        api_line,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__lsp_fee_limits_conservative_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lsp_fee_limits_conservative",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::LSPFeeLimits::conservative())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__lsp_fee_limits_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    max_total_opening_fee_msat: impl CstDecode<Option<u64>>,
    max_proportional_opening_fee_ppm_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lsp_fee_limits_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_max_total_opening_fee_msat = max_total_opening_fee_msat.cst_decode();
            let api_max_proportional_opening_fee_ppm_msat =
                max_proportional_opening_fee_ppm_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::LSPFeeLimits::new(
                        api_max_total_opening_fee_msat,
                        api_max_proportional_opening_fee_ppm_msat,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__lsp_fee_limits_permissive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lsp_fee_limits_permissive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::LSPFeeLimits::permissive())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__lsp_fee_limits_unlimited_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lsp_fee_limits_unlimited",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::LSPFeeLimits::unlimited())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__mnemonic_as_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Mnemonic>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_as_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(shared::Mnemonic::as_string(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__mnemonic_from_entropy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    entropy: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_from_entropy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_entropy = entropy.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Mnemonic::from_entropy(&api_entropy)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__mnemonic_from_seed_phrase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    seed_phrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_from_seed_phrase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_seed_phrase = seed_phrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Mnemonic::from_seed_phrase(&api_seed_phrase)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__mnemonic_generate_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(shared::Mnemonic::generate())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__mnemonic_to_seed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Mnemonic>,
    passphrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_to_seed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Mnemonic::to_seed(&api_that, &api_passphrase))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__offer_id_as_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::OfferId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "offer_id_as_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        ldk_adapter::types::OfferId::as_bytes(&api_that);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__offer_id_from_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "offer_id_from_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_bytes = bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::OfferId::from_bytes(&api_bytes))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__offer_id_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<[u8; 32]>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "offer_id_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::OfferId::new(api_data))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_secret_as_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<ldk_adapter::types::PaymentSecret>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_secret_as_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        ldk_adapter::types::PaymentSecret::as_bytes(&api_that);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_secret_from_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_secret_from_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_bytes = bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::types::PaymentSecret::from_bytes(&api_bytes),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__payment_secret_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    data: impl CstDecode<[u8; 32]>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "payment_secret_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_data = data.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::PaymentSecret::new(api_data))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__psbt_extract_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Psbt>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "psbt_extract_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Psbt::extract_tx(&api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__psbt_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Psbt>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "psbt_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Psbt::fee(&api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__psbt_from_base64_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    base64: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "psbt_from_base64",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_base64 = base64.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Psbt::from_base64(api_base64)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    {
        let AnchorChannelsConfig = None::<ldk_adapter::types::AnchorChannelsConfig>.unwrap();
        let _: Vec<PublicKey> = AnchorChannelsConfig.trusted_peers_no_reserve;
        let _: u64 = AnchorChannelsConfig.per_channel_reserve_sats;
    }
    {
        let BackgroundSyncConfig = None::<ldk_adapter::types::BackgroundSyncConfig>.unwrap();
        let _: u64 = BackgroundSyncConfig.onchain_wallet_sync_interval_secs;
        let _: u64 = BackgroundSyncConfig.lightning_wallet_sync_interval_secs;
        let _: u64 = BackgroundSyncConfig.fee_rate_cache_update_interval_secs;
    }
    {
        let BalanceDetails = None::<ldk_adapter::types::BalanceDetails>.unwrap();
        let _: u64 = BalanceDetails.total_onchain_balance_sats;
        let _: u64 = BalanceDetails.spendable_onchain_balance_sats;
        let _: u64 = BalanceDetails.total_lightning_balance_sats;
        let _: Vec<LightningBalance> = BalanceDetails.lightning_balances;
        let _: Vec<PendingSweepBalance> = BalanceDetails.pending_balances_from_channel_closures;
    }
    {
        let BestBlock = None::<ldk_adapter::types::BestBlock>.unwrap();
        let _: String = BestBlock.block_hash;
        let _: u32 = BestBlock.height;
    }
    {
        let Bolt12Invoice = None::<shared::Bolt12Invoice>.unwrap();
        let _: Vec<u8> = Bolt12Invoice.data;
    }
    match None::<crate::api::extensions::ChainDataSourceConfig>.unwrap() {
        crate::api::extensions::ChainDataSourceConfig::Esplora {
            server_url,
            sync_config,
        } => {
            let _: String = server_url;
            let _: Option<ldk_adapter::types::EsploraSyncConfig> = sync_config;
        }
        crate::api::extensions::ChainDataSourceConfig::Electrum {
            server_url,
            sync_config,
        } => {
            let _: String = server_url;
            let _: Option<ldk_adapter::types::ElectrumSyncConfig> = sync_config;
        }
        crate::api::extensions::ChainDataSourceConfig::BitcoindRpc {
            rpc_host,
            rpc_port,
            rpc_user,
            rpc_password,
        } => {
            let _: String = rpc_host;
            let _: u16 = rpc_port;
            let _: String = rpc_user;
            let _: String = rpc_password;
        }
    }
    {
        let ChannelInfo = None::<ldk_adapter::graph::ChannelInfo>.unwrap();
        let _: ldk_adapter::graph::NodeId = ChannelInfo.node_one;
        let _: Option<ldk_adapter::graph::ChannelUpdateInfo> = ChannelInfo.one_to_two;
        let _: ldk_adapter::graph::NodeId = ChannelInfo.node_two;
        let _: Option<ldk_adapter::graph::ChannelUpdateInfo> = ChannelInfo.two_to_one;
        let _: Option<u64> = ChannelInfo.capacity_sats;
    }
    {
        let ChannelUpdateInfo = None::<ldk_adapter::graph::ChannelUpdateInfo>.unwrap();
        let _: u32 = ChannelUpdateInfo.last_update;
        let _: bool = ChannelUpdateInfo.enabled;
        let _: u16 = ChannelUpdateInfo.cltv_expiry_delta;
        let _: u64 = ChannelUpdateInfo.htlc_minimum_msat;
        let _: u64 = ChannelUpdateInfo.htlc_maximum_msat;
        let _: ldk_adapter::graph::RoutingFees = ChannelUpdateInfo.fees;
    }
    {
        let Config = None::<crate::api::extensions::Config>.unwrap();
        let _: String = Config.storage_dir_path;
        let _: shared::Network = Config.network;
        let _: Option<Vec<SocketAddress>> = Config.listening_addresses;
        let _: Option<Vec<SocketAddress>> = Config.announcement_addresses;
        let _: Option<ldk_adapter::types::NodeAlias> = Config.node_alias;
        let _: Vec<PublicKey> = Config.trusted_peers_0conf;
        let _: u64 = Config.probing_liquidity_limit_multiplier;
        let _: Option<ldk_adapter::types::AnchorChannelsConfig> = Config.anchor_channels_config;
        let _: Option<shared::SendingParameters> = Config.sending_parameters;
    }
    {
        let CustomTlvRecord = None::<ldk_adapter::types::CustomTlvRecord>.unwrap();
        let _: u64 = CustomTlvRecord.type_num;
        let _: Vec<u8> = CustomTlvRecord.value;
    }
    {
        let ElectrumSyncConfig = None::<ldk_adapter::types::ElectrumSyncConfig>.unwrap();
        let _: Option<ldk_adapter::types::BackgroundSyncConfig> =
            ElectrumSyncConfig.background_sync_config;
    }
    match None::<crate::api::extensions::EntropySourceConfig>.unwrap() {
        crate::api::extensions::EntropySourceConfig::SeedFile(field0) => {
            let _: String = field0;
        }
        crate::api::extensions::EntropySourceConfig::SeedBytes(field0) => {
            let _: Vec<u8> = field0;
        }
        crate::api::extensions::EntropySourceConfig::Bip39Mnemonic(field0, field1) => {
            let _: shared::Mnemonic = field0;
            let _: Option<String> = field1;
        }
    }
    {
        let EsploraSyncConfig = None::<ldk_adapter::types::EsploraSyncConfig>.unwrap();
        let _: Option<ldk_adapter::types::BackgroundSyncConfig> =
            EsploraSyncConfig.background_sync_config;
    }
    {
        let FfiLogRecord = None::<ldk_adapter::types::FfiLogRecord>.unwrap();
        let _: ldk_adapter::types::LogLevel = FfiLogRecord.level;
        let _: String = FfiLogRecord.args;
        let _: String = FfiLogRecord.module_path;
        let _: u32 = FfiLogRecord.line;
    }
    match None::<crate::api::extensions::GossipSourceConfig>.unwrap() {
        crate::api::extensions::GossipSourceConfig::P2PNetwork => {}
        crate::api::extensions::GossipSourceConfig::RapidGossipSync(field0) => {
            let _: String = field0;
        }
    }
    {
        let LiquiditySourceConfig = None::<ldk_adapter::types::LiquiditySourceConfig>.unwrap();
        let _: (SocketAddress, PublicKey, Option<String>) = LiquiditySourceConfig.lsps2_service;
    }
    {
        let LSPFeeLimits = None::<ldk_adapter::types::LSPFeeLimits>.unwrap();
        let _: Option<u64> = LSPFeeLimits.max_total_opening_fee_msat;
        let _: Option<u64> = LSPFeeLimits.max_proportional_opening_fee_ppm_msat;
    }
    {
        let Mnemonic = None::<shared::Mnemonic>.unwrap();
        let _: Vec<String> = Mnemonic.words;
    }
    {
        let NodeAlias_ = None::<ldk_adapter::types::NodeAlias>.unwrap();
        let _: [u8; 32] = NodeAlias_.0;
    }
    {
        let NodeAnnouncementInfo = None::<ldk_adapter::graph::NodeAnnouncementInfo>.unwrap();
        let _: u32 = NodeAnnouncementInfo.last_update;
        let _: String = NodeAnnouncementInfo.alias;
        let _: Vec<SocketAddress> = NodeAnnouncementInfo.addresses;
    }
    {
        let NodeId = None::<ldk_adapter::graph::NodeId>.unwrap();
        let _: Vec<u8> = NodeId.compressed;
    }
    {
        let NodeInfo = None::<ldk_adapter::graph::NodeInfo>.unwrap();
        let _: Vec<u64> = NodeInfo.channels;
        let _: Option<ldk_adapter::graph::NodeAnnouncementInfo> = NodeInfo.announcement_info;
    }
    {
        let NodeStatus = None::<ldk_adapter::types::NodeStatus>.unwrap();
        let _: bool = NodeStatus.is_running;
        let _: bool = NodeStatus.is_listening;
        let _: ldk_adapter::types::BestBlock = NodeStatus.current_best_block;
        let _: Option<u64> = NodeStatus.latest_lightning_wallet_sync_timestamp;
        let _: Option<u64> = NodeStatus.latest_onchain_wallet_sync_timestamp;
        let _: Option<u64> = NodeStatus.latest_fee_rate_cache_update_timestamp;
        let _: Option<u64> = NodeStatus.latest_rgs_snapshot_timestamp;
        let _: Option<u64> = NodeStatus.latest_node_announcement_broadcast_timestamp;
        let _: Option<u32> = NodeStatus.latest_channel_monitor_archival_height;
    }
    {
        let Offer = None::<shared::Offer>.unwrap();
        let _: String = Offer.s;
    }
    {
        let OfferId_ = None::<ldk_adapter::types::OfferId>.unwrap();
        let _: [u8; 32] = OfferId_.0;
    }
    {
        let OutPoint = None::<shared::OutPoint>.unwrap();
        let _: shared::Txid = OutPoint.txid;
        let _: u32 = OutPoint.vout;
    }
    {
        let PaymentSecret = None::<ldk_adapter::types::PaymentSecret>.unwrap();
        let _: [u8; 32] = PaymentSecret.data;
    }
    {
        let Psbt = None::<shared::Psbt>.unwrap();
        let _: String = Psbt.inner;
    }
    {
        let Refund = None::<shared::Refund>.unwrap();
        let _: String = Refund.s;
    }
    {
        let RoutingFees = None::<ldk_adapter::graph::RoutingFees>.unwrap();
        let _: u32 = RoutingFees.base_msat;
        let _: u32 = RoutingFees.proportional_millionths;
    }
    {
        let ScriptBuf = None::<shared::ScriptBuf>.unwrap();
        let _: Vec<u8> = ScriptBuf.inner;
    }
    {
        let SendingParameters = None::<shared::SendingParameters>.unwrap();
        let _: Option<u64> = SendingParameters.max_total_routing_fee_msat;
        let _: Option<u32> = SendingParameters.max_total_cltv_expiry_delta;
        let _: Option<u8> = SendingParameters.max_path_count;
        let _: Option<u8> = SendingParameters.max_channel_saturation_power_of_half;
    }
    {
        let TxIn = None::<shared::TxIn>.unwrap();
        let _: shared::OutPoint = TxIn.previous_output;
        let _: shared::ScriptBuf = TxIn.script_sig;
        let _: u32 = TxIn.sequence;
        let _: Vec<Vec<u8>> = TxIn.witness;
    }
    {
        let TxOut = None::<shared::TxOut>.unwrap();
        let _: u64 = TxOut.value;
        let _: shared::ScriptBuf = TxOut.script_pubkey;
    }
    {
        let Txid = None::<shared::Txid>.unwrap();
        let _: String = Txid.hash;
    }
    {
        let WTxid = None::<shared::WTxid>.unwrap();
        let _: String = WTxid.hash;
    }
};

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<f64> for f64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<ldk_adapter::types::LogLevel> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::LogLevel {
        match self {
            0 => ldk_adapter::types::LogLevel::Gossip,
            1 => ldk_adapter::types::LogLevel::Trace,
            2 => ldk_adapter::types::LogLevel::Debug,
            3 => ldk_adapter::types::LogLevel::Info,
            4 => ldk_adapter::types::LogLevel::Warn,
            5 => ldk_adapter::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", self),
        }
    }
}
impl CstDecode<shared::Network> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> shared::Network {
        match self {
            0 => shared::Network::Bitcoin,
            1 => shared::Network::Testnet,
            2 => shared::Network::Testnet4,
            3 => shared::Network::Signet,
            4 => shared::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}
impl CstDecode<ldk_adapter::types::PaymentDirection> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::PaymentDirection {
        match self {
            0 => ldk_adapter::types::PaymentDirection::Inbound,
            1 => ldk_adapter::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", self),
        }
    }
}
impl CstDecode<ldk_adapter::types::PaymentStatus> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::PaymentStatus {
        match self {
            0 => ldk_adapter::types::PaymentStatus::Pending,
            1 => ldk_adapter::types::PaymentStatus::Succeeded,
            2 => ldk_adapter::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", self),
        }
    }
}
impl CstDecode<crate::api::extensions::SocketAddressType> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::extensions::SocketAddressType {
        match self {
            0 => crate::api::extensions::SocketAddressType::TcpIpV4,
            1 => crate::api::extensions::SocketAddressType::TcpIpV6,
            2 => crate::api::extensions::SocketAddressType::OnionV2,
            3 => crate::api::extensions::SocketAddressType::OnionV3,
            4 => crate::api::extensions::SocketAddressType::Hostname,
            _ => unreachable!("Invalid variant for SocketAddressType: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for AddressData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BitcoinAddressInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BitcoinTransactionInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Bolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Bolt12Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for LdkBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for NetworkGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Node {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for OnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentHash>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentId>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentPreimage>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for QrPaymentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TaprootSpendInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TaprootSpendInfoInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Transaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for UnifiedQrPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentHash>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentPreimage>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::extensions::AddressHostname {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_addr = <String>::sse_decode(deserializer);
        let mut var_port = <u16>::sse_decode(deserializer);
        return crate::api::extensions::AddressHostname {
            addr: var_addr,
            port: var_port,
        };
    }
}

impl SseDecode for crate::api::extensions::AddressOnionV2 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 12]>::sse_decode(deserializer);
        return crate::api::extensions::AddressOnionV2(var_field0);
    }
}

impl SseDecode for crate::api::extensions::AddressOnionV3 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ed25519Pubkey = <[u8; 32]>::sse_decode(deserializer);
        let mut var_checksum = <u16>::sse_decode(deserializer);
        let mut var_version = <u8>::sse_decode(deserializer);
        let mut var_port = <u16>::sse_decode(deserializer);
        return crate::api::extensions::AddressOnionV3 {
            ed25519_pubkey: var_ed25519Pubkey,
            checksum: var_checksum,
            version: var_version,
            port: var_port,
        };
    }
}

impl SseDecode for crate::api::extensions::AddressTcpIpV4 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_addr = <[u8; 4]>::sse_decode(deserializer);
        let mut var_port = <u16>::sse_decode(deserializer);
        return crate::api::extensions::AddressTcpIpV4 {
            addr: var_addr,
            port: var_port,
        };
    }
}

impl SseDecode for crate::api::extensions::AddressTcpIpV6 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_addr = <[u8; 16]>::sse_decode(deserializer);
        let mut var_port = <u16>::sse_decode(deserializer);
        return crate::api::extensions::AddressTcpIpV6 {
            addr: var_addr,
            port: var_port,
        };
    }
}

impl SseDecode for ldk_adapter::types::AnchorChannelsConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_trustedPeersNoReserve = <Vec<PublicKey>>::sse_decode(deserializer);
        let mut var_perChannelReserveSats = <u64>::sse_decode(deserializer);
        return ldk_adapter::types::AnchorChannelsConfig {
            trusted_peers_no_reserve: var_trustedPeersNoReserve,
            per_channel_reserve_sats: var_perChannelReserveSats,
        };
    }
}

impl SseDecode for ldk_adapter::types::BackgroundSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_onchainWalletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_lightningWalletSyncIntervalSecs = <u64>::sse_decode(deserializer);
        let mut var_feeRateCacheUpdateIntervalSecs = <u64>::sse_decode(deserializer);
        return ldk_adapter::types::BackgroundSyncConfig {
            onchain_wallet_sync_interval_secs: var_onchainWalletSyncIntervalSecs,
            lightning_wallet_sync_interval_secs: var_lightningWalletSyncIntervalSecs,
            fee_rate_cache_update_interval_secs: var_feeRateCacheUpdateIntervalSecs,
        };
    }
}

impl SseDecode for ldk_adapter::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_totalOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_spendableOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_totalLightningBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_lightningBalances = <Vec<LightningBalance>>::sse_decode(deserializer);
        let mut var_pendingBalancesFromChannelClosures =
            <Vec<PendingSweepBalance>>::sse_decode(deserializer);
        return ldk_adapter::types::BalanceDetails {
            total_onchain_balance_sats: var_totalOnchainBalanceSats,
            spendable_onchain_balance_sats: var_spendableOnchainBalanceSats,
            total_lightning_balance_sats: var_totalLightningBalanceSats,
            lightning_balances: var_lightningBalances,
            pending_balances_from_channel_closures: var_pendingBalancesFromChannelClosures,
        };
    }
}

impl SseDecode for ldk_adapter::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blockHash = <String>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        return ldk_adapter::types::BestBlock {
            block_hash: var_blockHash,
            height: var_height,
        };
    }
}

impl SseDecode for shared::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return shared::Bolt12Invoice { data: var_data };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::extensions::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_serverUrl = <String>::sse_decode(deserializer);
                let mut var_syncConfig =
                    <Option<ldk_adapter::types::EsploraSyncConfig>>::sse_decode(deserializer);
                return crate::api::extensions::ChainDataSourceConfig::Esplora {
                    server_url: var_serverUrl,
                    sync_config: var_syncConfig,
                };
            }
            1 => {
                let mut var_serverUrl = <String>::sse_decode(deserializer);
                let mut var_syncConfig =
                    <Option<ldk_adapter::types::ElectrumSyncConfig>>::sse_decode(deserializer);
                return crate::api::extensions::ChainDataSourceConfig::Electrum {
                    server_url: var_serverUrl,
                    sync_config: var_syncConfig,
                };
            }
            2 => {
                let mut var_rpcHost = <String>::sse_decode(deserializer);
                let mut var_rpcPort = <u16>::sse_decode(deserializer);
                let mut var_rpcUser = <String>::sse_decode(deserializer);
                let mut var_rpcPassword = <String>::sse_decode(deserializer);
                return crate::api::extensions::ChainDataSourceConfig::BitcoindRpc {
                    rpc_host: var_rpcHost,
                    rpc_port: var_rpcPort,
                    rpc_user: var_rpcUser,
                    rpc_password: var_rpcPassword,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for ldk_adapter::graph::ChannelInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodeOne = <ldk_adapter::graph::NodeId>::sse_decode(deserializer);
        let mut var_oneToTwo =
            <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_decode(deserializer);
        let mut var_nodeTwo = <ldk_adapter::graph::NodeId>::sse_decode(deserializer);
        let mut var_twoToOne =
            <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_decode(deserializer);
        let mut var_capacitySats = <Option<u64>>::sse_decode(deserializer);
        return ldk_adapter::graph::ChannelInfo {
            node_one: var_nodeOne,
            one_to_two: var_oneToTwo,
            node_two: var_nodeTwo,
            two_to_one: var_twoToOne,
            capacity_sats: var_capacitySats,
        };
    }
}

impl SseDecode for ldk_adapter::graph::ChannelUpdateInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdate = <u32>::sse_decode(deserializer);
        let mut var_enabled = <bool>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_htlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_htlcMaximumMsat = <u64>::sse_decode(deserializer);
        let mut var_fees = <ldk_adapter::graph::RoutingFees>::sse_decode(deserializer);
        return ldk_adapter::graph::ChannelUpdateInfo {
            last_update: var_lastUpdate,
            enabled: var_enabled,
            cltv_expiry_delta: var_cltvExpiryDelta,
            htlc_minimum_msat: var_htlcMinimumMsat,
            htlc_maximum_msat: var_htlcMaximumMsat,
            fees: var_fees,
        };
    }
}

impl SseDecode for crate::api::extensions::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_storageDirPath = <String>::sse_decode(deserializer);
        let mut var_network = <shared::Network>::sse_decode(deserializer);
        let mut var_listeningAddresses = <Option<Vec<SocketAddress>>>::sse_decode(deserializer);
        let mut var_announcementAddresses = <Option<Vec<SocketAddress>>>::sse_decode(deserializer);
        let mut var_nodeAlias = <Option<ldk_adapter::types::NodeAlias>>::sse_decode(deserializer);
        let mut var_trustedPeers0Conf = <Vec<PublicKey>>::sse_decode(deserializer);
        let mut var_probingLiquidityLimitMultiplier = <u64>::sse_decode(deserializer);
        let mut var_anchorChannelsConfig =
            <Option<ldk_adapter::types::AnchorChannelsConfig>>::sse_decode(deserializer);
        let mut var_sendingParameters =
            <Option<shared::SendingParameters>>::sse_decode(deserializer);
        return crate::api::extensions::Config {
            storage_dir_path: var_storageDirPath,
            network: var_network,
            listening_addresses: var_listeningAddresses,
            announcement_addresses: var_announcementAddresses,
            node_alias: var_nodeAlias,
            trusted_peers_0conf: var_trustedPeers0Conf,
            probing_liquidity_limit_multiplier: var_probingLiquidityLimitMultiplier,
            anchor_channels_config: var_anchorChannelsConfig,
            sending_parameters: var_sendingParameters,
        };
    }
}

impl SseDecode for ldk_adapter::types::CustomTlvRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_typeNum = <u64>::sse_decode(deserializer);
        let mut var_value = <Vec<u8>>::sse_decode(deserializer);
        return ldk_adapter::types::CustomTlvRecord {
            type_num: var_typeNum,
            value: var_value,
        };
    }
}

impl SseDecode for ldk_adapter::types::ElectrumSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_backgroundSyncConfig =
            <Option<ldk_adapter::types::BackgroundSyncConfig>>::sse_decode(deserializer);
        return ldk_adapter::types::ElectrumSyncConfig {
            background_sync_config: var_backgroundSyncConfig,
        };
    }
}

impl SseDecode for crate::api::extensions::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::extensions::EntropySourceConfig::SeedFile(var_field0);
            }
            1 => {
                let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                return crate::api::extensions::EntropySourceConfig::SeedBytes(var_field0);
            }
            2 => {
                let mut var_field0 = <shared::Mnemonic>::sse_decode(deserializer);
                let mut var_field1 = <Option<String>>::sse_decode(deserializer);
                return crate::api::extensions::EntropySourceConfig::Bip39Mnemonic(
                    var_field0, var_field1,
                );
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for ldk_adapter::types::EsploraSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_backgroundSyncConfig =
            <Option<ldk_adapter::types::BackgroundSyncConfig>>::sse_decode(deserializer);
        return ldk_adapter::types::EsploraSyncConfig {
            background_sync_config: var_backgroundSyncConfig,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for ldk_adapter::types::FfiLogRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_level = <ldk_adapter::types::LogLevel>::sse_decode(deserializer);
        let mut var_args = <String>::sse_decode(deserializer);
        let mut var_modulePath = <String>::sse_decode(deserializer);
        let mut var_line = <u32>::sse_decode(deserializer);
        return ldk_adapter::types::FfiLogRecord {
            level: var_level,
            args: var_args,
            module_path: var_modulePath,
            line: var_line,
        };
    }
}

impl SseDecode for crate::api::extensions::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::extensions::GossipSourceConfig::P2PNetwork;
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::extensions::GossipSourceConfig::RapidGossipSync(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for ldk_adapter::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lsps2Service =
            <(SocketAddress, PublicKey, Option<String>)>::sse_decode(deserializer);
        return ldk_adapter::types::LiquiditySourceConfig {
            lsps2_service: var_lsps2Service,
        };
    }
}

impl SseDecode for Vec<ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ChannelDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<LightningBalance>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<PaymentDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<PeerDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<PendingSweepBalance>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<PublicKey>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<SocketAddress>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ldk_adapter::types::CustomTlvRecord> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ldk_adapter::types::CustomTlvRecord>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<u8>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ldk_adapter::graph::NodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ldk_adapter::graph::NodeId>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<shared::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<shared::TxIn>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<shared::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<shared::TxOut>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for ldk_adapter::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::LogLevel::Gossip,
            1 => ldk_adapter::types::LogLevel::Trace,
            2 => ldk_adapter::types::LogLevel::Debug,
            3 => ldk_adapter::types::LogLevel::Info,
            4 => ldk_adapter::types::LogLevel::Warn,
            5 => ldk_adapter::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", inner),
        };
    }
}

impl SseDecode for ldk_adapter::types::LSPFeeLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxTotalOpeningFeeMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_maxProportionalOpeningFeePpmMsat = <Option<u64>>::sse_decode(deserializer);
        return ldk_adapter::types::LSPFeeLimits {
            max_total_opening_fee_msat: var_maxTotalOpeningFeeMsat,
            max_proportional_opening_fee_ppm_msat: var_maxProportionalOpeningFeePpmMsat,
        };
    }
}

impl SseDecode for shared::Mnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_words = <Vec<String>>::sse_decode(deserializer);
        return shared::Mnemonic { words: var_words };
    }
}

impl SseDecode for shared::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => shared::Network::Bitcoin,
            1 => shared::Network::Testnet,
            2 => shared::Network::Testnet4,
            3 => shared::Network::Signet,
            4 => shared::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for ldk_adapter::types::NodeAlias {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return ldk_adapter::types::NodeAlias(var_field0);
    }
}

impl SseDecode for ldk_adapter::graph::NodeAnnouncementInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdate = <u32>::sse_decode(deserializer);
        let mut var_alias = <String>::sse_decode(deserializer);
        let mut var_addresses = <Vec<SocketAddress>>::sse_decode(deserializer);
        return ldk_adapter::graph::NodeAnnouncementInfo {
            last_update: var_lastUpdate,
            alias: var_alias,
            addresses: var_addresses,
        };
    }
}

impl SseDecode for ldk_adapter::graph::NodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_compressed = <Vec<u8>>::sse_decode(deserializer);
        return ldk_adapter::graph::NodeId {
            compressed: var_compressed,
        };
    }
}

impl SseDecode for ldk_adapter::graph::NodeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channels = <Vec<u64>>::sse_decode(deserializer);
        let mut var_announcementInfo =
            <Option<ldk_adapter::graph::NodeAnnouncementInfo>>::sse_decode(deserializer);
        return ldk_adapter::graph::NodeInfo {
            channels: var_channels,
            announcement_info: var_announcementInfo,
        };
    }
}

impl SseDecode for ldk_adapter::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isRunning = <bool>::sse_decode(deserializer);
        let mut var_isListening = <bool>::sse_decode(deserializer);
        let mut var_currentBestBlock = <ldk_adapter::types::BestBlock>::sse_decode(deserializer);
        let mut var_latestLightningWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestOnchainWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestFeeRateCacheUpdateTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestRgsSnapshotTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestNodeAnnouncementBroadcastTimestamp =
            <Option<u64>>::sse_decode(deserializer);
        let mut var_latestChannelMonitorArchivalHeight = <Option<u32>>::sse_decode(deserializer);
        return ldk_adapter::types::NodeStatus {
            is_running: var_isRunning,
            is_listening: var_isListening,
            current_best_block: var_currentBestBlock,
            latest_lightning_wallet_sync_timestamp: var_latestLightningWalletSyncTimestamp,
            latest_onchain_wallet_sync_timestamp: var_latestOnchainWalletSyncTimestamp,
            latest_fee_rate_cache_update_timestamp: var_latestFeeRateCacheUpdateTimestamp,
            latest_rgs_snapshot_timestamp: var_latestRgsSnapshotTimestamp,
            latest_node_announcement_broadcast_timestamp:
                var_latestNodeAnnouncementBroadcastTimestamp,
            latest_channel_monitor_archival_height: var_latestChannelMonitorArchivalHeight,
        };
    }
}

impl SseDecode for shared::Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return shared::Offer { s: var_s };
    }
}

impl SseDecode for ldk_adapter::types::OfferId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return ldk_adapter::types::OfferId(var_field0);
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ChannelConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ChannelId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Event>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<PaymentDetails>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::extensions::AddressHostname> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::extensions::AddressHostname>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::extensions::AddressOnionV2> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::extensions::AddressOnionV2>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::extensions::AddressOnionV3> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::extensions::AddressOnionV3>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::extensions::AddressTcpIpV4> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::extensions::AddressTcpIpV4>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::extensions::AddressTcpIpV6> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::extensions::AddressTcpIpV6>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::AnchorChannelsConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::AnchorChannelsConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::BackgroundSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::BackgroundSyncConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::extensions::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::extensions::ChainDataSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::ChannelInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::ChannelInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::ChannelUpdateInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::ChannelUpdateInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::ElectrumSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::ElectrumSyncConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::extensions::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::extensions::EntropySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::EsploraSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::EsploraSyncConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::extensions::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::extensions::GossipSourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::LiquiditySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::LogLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::LogLevel>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::NodeAlias> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::NodeAlias>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::NodeAnnouncementInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::NodeAnnouncementInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::NodeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::NodeInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::OfferId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::OfferId>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<shared::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<shared::OutPoint>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::PaymentSecret>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<shared::SendingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<shared::SendingParameters>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u16>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<SocketAddress>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for shared::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <shared::Txid>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return shared::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for ldk_adapter::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::PaymentDirection::Inbound,
            1 => ldk_adapter::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", inner),
        };
    }
}

impl SseDecode for ldk_adapter::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return ldk_adapter::types::PaymentSecret { data: var_data };
    }
}

impl SseDecode for ldk_adapter::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::PaymentStatus::Pending,
            1 => ldk_adapter::types::PaymentStatus::Succeeded,
            2 => ldk_adapter::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", inner),
        };
    }
}

impl SseDecode for shared::Psbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inner = <String>::sse_decode(deserializer);
        return shared::Psbt { inner: var_inner };
    }
}

impl SseDecode for (SocketAddress, PublicKey, Option<String>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <SocketAddress>::sse_decode(deserializer);
        let mut var_field1 = <PublicKey>::sse_decode(deserializer);
        let mut var_field2 = <Option<String>>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for shared::Refund {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return shared::Refund { s: var_s };
    }
}

impl SseDecode for ldk_adapter::graph::RoutingFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_baseMsat = <u32>::sse_decode(deserializer);
        let mut var_proportionalMillionths = <u32>::sse_decode(deserializer);
        return ldk_adapter::graph::RoutingFees {
            base_msat: var_baseMsat,
            proportional_millionths: var_proportionalMillionths,
        };
    }
}

impl SseDecode for shared::ScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inner = <Vec<u8>>::sse_decode(deserializer);
        return shared::ScriptBuf { inner: var_inner };
    }
}

impl SseDecode for shared::SendingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxTotalRoutingFeeMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_maxTotalCltvExpiryDelta = <Option<u32>>::sse_decode(deserializer);
        let mut var_maxPathCount = <Option<u8>>::sse_decode(deserializer);
        let mut var_maxChannelSaturationPowerOfHalf = <Option<u8>>::sse_decode(deserializer);
        return shared::SendingParameters {
            max_total_routing_fee_msat: var_maxTotalRoutingFeeMsat,
            max_total_cltv_expiry_delta: var_maxTotalCltvExpiryDelta,
            max_path_count: var_maxPathCount,
            max_channel_saturation_power_of_half: var_maxChannelSaturationPowerOfHalf,
        };
    }
}

impl SseDecode for crate::api::extensions::SocketAddressType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::extensions::SocketAddressType::TcpIpV4,
            1 => crate::api::extensions::SocketAddressType::TcpIpV6,
            2 => crate::api::extensions::SocketAddressType::OnionV2,
            3 => crate::api::extensions::SocketAddressType::OnionV3,
            4 => crate::api::extensions::SocketAddressType::Hostname,
            _ => unreachable!("Invalid variant for SocketAddressType: {}", inner),
        };
    }
}

impl SseDecode for shared::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_previousOutput = <shared::OutPoint>::sse_decode(deserializer);
        let mut var_scriptSig = <shared::ScriptBuf>::sse_decode(deserializer);
        let mut var_sequence = <u32>::sse_decode(deserializer);
        let mut var_witness = <Vec<Vec<u8>>>::sse_decode(deserializer);
        return shared::TxIn {
            previous_output: var_previousOutput,
            script_sig: var_scriptSig,
            sequence: var_sequence,
            witness: var_witness,
        };
    }
}

impl SseDecode for shared::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_scriptPubkey = <shared::ScriptBuf>::sse_decode(deserializer);
        return shared::TxOut {
            value: var_value,
            script_pubkey: var_scriptPubkey,
        };
    }
}

impl SseDecode for shared::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        return shared::Txid { hash: var_hash };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for [u8; 12] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 16] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for shared::WTxid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        return shared::WTxid { hash: var_hash };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AddressData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AddressData> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AddressData>> for AddressData {
    fn into_into_dart(self) -> FrbWrapper<AddressData> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinAddress> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BitcoinAddress> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinAddress>> for BitcoinAddress {
    fn into_into_dart(self) -> FrbWrapper<BitcoinAddress> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinAddressInner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<BitcoinAddressInner>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinAddressInner>> for BitcoinAddressInner {
    fn into_into_dart(self) -> FrbWrapper<BitcoinAddressInner> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinTransactionInner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<BitcoinTransactionInner>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinTransactionInner>>
    for BitcoinTransactionInner
{
    fn into_into_dart(self) -> FrbWrapper<BitcoinTransactionInner> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Bolt11Invoice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Bolt11Invoice> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Bolt11Invoice>> for Bolt11Invoice {
    fn into_into_dart(self) -> FrbWrapper<Bolt11Invoice> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Bolt11Payment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Bolt11Payment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Bolt11Payment>> for Bolt11Payment {
    fn into_into_dart(self) -> FrbWrapper<Bolt11Payment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Bolt12Payment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Bolt12Payment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Bolt12Payment>> for Bolt12Payment {
    fn into_into_dart(self) -> FrbWrapper<Bolt12Payment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelConfig> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelConfig>> for ChannelConfig {
    fn into_into_dart(self) -> FrbWrapper<ChannelConfig> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelDetails> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelDetails>> for ChannelDetails {
    fn into_into_dart(self) -> FrbWrapper<ChannelDetails> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelId> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelId>> for ChannelId {
    fn into_into_dart(self) -> FrbWrapper<ChannelId> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Event> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Event> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Event>> for Event {
    fn into_into_dart(self) -> FrbWrapper<Event> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<LdkBuilder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<LdkBuilder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<LdkBuilder>> for LdkBuilder {
    fn into_into_dart(self) -> FrbWrapper<LdkBuilder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<LightningBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<LightningBalance> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<LightningBalance>> for LightningBalance {
    fn into_into_dart(self) -> FrbWrapper<LightningBalance> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MaxDustHTLCExposure> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MaxDustHTLCExposure>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MaxDustHTLCExposure>> for MaxDustHTLCExposure {
    fn into_into_dart(self) -> FrbWrapper<MaxDustHTLCExposure> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<NetworkGraph> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<NetworkGraph> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<NetworkGraph>> for NetworkGraph {
    fn into_into_dart(self) -> FrbWrapper<NetworkGraph> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Node> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Node> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Node>> for Node {
    fn into_into_dart(self) -> FrbWrapper<Node> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<OnChainPayment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<OnChainPayment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OnChainPayment>> for OnChainPayment {
    fn into_into_dart(self) -> FrbWrapper<OnChainPayment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PaymentDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PaymentDetails> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PaymentDetails>> for PaymentDetails {
    fn into_into_dart(self) -> FrbWrapper<PaymentDetails> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PaymentHash> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PaymentHash> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PaymentHash>> for PaymentHash {
    fn into_into_dart(self) -> FrbWrapper<PaymentHash> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PaymentId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PaymentId> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PaymentId>> for PaymentId {
    fn into_into_dart(self) -> FrbWrapper<PaymentId> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PaymentKind> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PaymentKind> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PaymentKind>> for PaymentKind {
    fn into_into_dart(self) -> FrbWrapper<PaymentKind> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PaymentPreimage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PaymentPreimage> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PaymentPreimage>> for PaymentPreimage {
    fn into_into_dart(self) -> FrbWrapper<PaymentPreimage> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PeerDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PeerDetails> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PeerDetails>> for PeerDetails {
    fn into_into_dart(self) -> FrbWrapper<PeerDetails> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PendingSweepBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<PendingSweepBalance>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PendingSweepBalance>> for PendingSweepBalance {
    fn into_into_dart(self) -> FrbWrapper<PendingSweepBalance> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PublicKey> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PublicKey> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PublicKey>> for PublicKey {
    fn into_into_dart(self) -> FrbWrapper<PublicKey> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<QrPaymentResult> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<QrPaymentResult> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<QrPaymentResult>> for QrPaymentResult {
    fn into_into_dart(self) -> FrbWrapper<QrPaymentResult> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SocketAddress> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<SocketAddress> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SocketAddress>> for SocketAddress {
    fn into_into_dart(self) -> FrbWrapper<SocketAddress> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SpontaneousPayment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<SpontaneousPayment>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SpontaneousPayment>> for SpontaneousPayment {
    fn into_into_dart(self) -> FrbWrapper<SpontaneousPayment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TaprootSpendInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<TaprootSpendInfo> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TaprootSpendInfo>> for TaprootSpendInfo {
    fn into_into_dart(self) -> FrbWrapper<TaprootSpendInfo> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TaprootSpendInfoInner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<TaprootSpendInfoInner>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TaprootSpendInfoInner>>
    for TaprootSpendInfoInner
{
    fn into_into_dart(self) -> FrbWrapper<TaprootSpendInfoInner> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Transaction> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Transaction> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Transaction>> for Transaction {
    fn into_into_dart(self) -> FrbWrapper<Transaction> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<UnifiedQrPayment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<UnifiedQrPayment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<UnifiedQrPayment>> for UnifiedQrPayment {
    fn into_into_dart(self) -> FrbWrapper<UnifiedQrPayment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<UserChannelId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<UserChannelId> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<UserChannelId>> for UserChannelId {
    fn into_into_dart(self) -> FrbWrapper<UserChannelId> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::extensions::AddressHostname {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.addr.into_into_dart().into_dart(),
            self.port.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::extensions::AddressHostname
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::extensions::AddressHostname>
    for crate::api::extensions::AddressHostname
{
    fn into_into_dart(self) -> crate::api::extensions::AddressHostname {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::extensions::AddressOnionV2 {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::extensions::AddressOnionV2
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::extensions::AddressOnionV2>
    for crate::api::extensions::AddressOnionV2
{
    fn into_into_dart(self) -> crate::api::extensions::AddressOnionV2 {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::extensions::AddressOnionV3 {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ed25519_pubkey.into_into_dart().into_dart(),
            self.checksum.into_into_dart().into_dart(),
            self.version.into_into_dart().into_dart(),
            self.port.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::extensions::AddressOnionV3
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::extensions::AddressOnionV3>
    for crate::api::extensions::AddressOnionV3
{
    fn into_into_dart(self) -> crate::api::extensions::AddressOnionV3 {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::extensions::AddressTcpIpV4 {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.addr.into_into_dart().into_dart(),
            self.port.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::extensions::AddressTcpIpV4
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::extensions::AddressTcpIpV4>
    for crate::api::extensions::AddressTcpIpV4
{
    fn into_into_dart(self) -> crate::api::extensions::AddressTcpIpV4 {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::extensions::AddressTcpIpV6 {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.addr.into_into_dart().into_dart(),
            self.port.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::extensions::AddressTcpIpV6
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::extensions::AddressTcpIpV6>
    for crate::api::extensions::AddressTcpIpV6
{
    fn into_into_dart(self) -> crate::api::extensions::AddressTcpIpV6 {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::AnchorChannelsConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.trusted_peers_no_reserve.into_into_dart().into_dart(),
            self.0.per_channel_reserve_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::AnchorChannelsConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::AnchorChannelsConfig>>
    for ldk_adapter::types::AnchorChannelsConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::AnchorChannelsConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::BackgroundSyncConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .onchain_wallet_sync_interval_secs
                .into_into_dart()
                .into_dart(),
            self.0
                .lightning_wallet_sync_interval_secs
                .into_into_dart()
                .into_dart(),
            self.0
                .fee_rate_cache_update_interval_secs
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::BackgroundSyncConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::BackgroundSyncConfig>>
    for ldk_adapter::types::BackgroundSyncConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::BackgroundSyncConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::BalanceDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .total_onchain_balance_sats
                .into_into_dart()
                .into_dart(),
            self.0
                .spendable_onchain_balance_sats
                .into_into_dart()
                .into_dart(),
            self.0
                .total_lightning_balance_sats
                .into_into_dart()
                .into_dart(),
            self.0.lightning_balances.into_into_dart().into_dart(),
            self.0
                .pending_balances_from_channel_closures
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::BalanceDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::BalanceDetails>>
    for ldk_adapter::types::BalanceDetails
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::BalanceDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::BestBlock> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.block_hash.into_into_dart().into_dart(),
            self.0.height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::BestBlock>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::BestBlock>>
    for ldk_adapter::types::BestBlock
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::BestBlock> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Bolt12Invoice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::Bolt12Invoice>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Bolt12Invoice>>
    for shared::Bolt12Invoice
{
    fn into_into_dart(self) -> FrbWrapper<shared::Bolt12Invoice> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::extensions::ChainDataSourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::extensions::ChainDataSourceConfig::Esplora {
                server_url,
                sync_config,
            } => [
                0.into_dart(),
                server_url.into_into_dart().into_dart(),
                sync_config.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::extensions::ChainDataSourceConfig::Electrum {
                server_url,
                sync_config,
            } => [
                1.into_dart(),
                server_url.into_into_dart().into_dart(),
                sync_config.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::extensions::ChainDataSourceConfig::BitcoindRpc {
                rpc_host,
                rpc_port,
                rpc_user,
                rpc_password,
            } => [
                2.into_dart(),
                rpc_host.into_into_dart().into_dart(),
                rpc_port.into_into_dart().into_dart(),
                rpc_user.into_into_dart().into_dart(),
                rpc_password.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::extensions::ChainDataSourceConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::extensions::ChainDataSourceConfig>>
    for crate::api::extensions::ChainDataSourceConfig
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::extensions::ChainDataSourceConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::ChannelInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.node_one.into_into_dart().into_dart(),
            self.0.one_to_two.into_into_dart().into_dart(),
            self.0.node_two.into_into_dart().into_dart(),
            self.0.two_to_one.into_into_dart().into_dart(),
            self.0.capacity_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::ChannelInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::ChannelInfo>>
    for ldk_adapter::graph::ChannelInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::ChannelInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.last_update.into_into_dart().into_dart(),
            self.0.enabled.into_into_dart().into_dart(),
            self.0.cltv_expiry_delta.into_into_dart().into_dart(),
            self.0.htlc_minimum_msat.into_into_dart().into_dart(),
            self.0.htlc_maximum_msat.into_into_dart().into_dart(),
            self.0.fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo>>
    for ldk_adapter::graph::ChannelUpdateInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::extensions::Config> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.storage_dir_path.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.listening_addresses.into_into_dart().into_dart(),
            self.0.announcement_addresses.into_into_dart().into_dart(),
            self.0.node_alias.into_into_dart().into_dart(),
            self.0.trusted_peers_0conf.into_into_dart().into_dart(),
            self.0
                .probing_liquidity_limit_multiplier
                .into_into_dart()
                .into_dart(),
            self.0.anchor_channels_config.into_into_dart().into_dart(),
            self.0.sending_parameters.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::extensions::Config>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::extensions::Config>>
    for crate::api::extensions::Config
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::extensions::Config> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::CustomTlvRecord> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.type_num.into_into_dart().into_dart(),
            self.0.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::CustomTlvRecord>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::CustomTlvRecord>>
    for ldk_adapter::types::CustomTlvRecord
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::CustomTlvRecord> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::ElectrumSyncConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.background_sync_config.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::ElectrumSyncConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::ElectrumSyncConfig>>
    for ldk_adapter::types::ElectrumSyncConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::ElectrumSyncConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::extensions::EntropySourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::extensions::EntropySourceConfig::SeedFile(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::extensions::EntropySourceConfig::SeedBytes(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::extensions::EntropySourceConfig::Bip39Mnemonic(field0, field1) => [
                2.into_dart(),
                field0.into_into_dart().into_dart(),
                field1.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::extensions::EntropySourceConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::extensions::EntropySourceConfig>>
    for crate::api::extensions::EntropySourceConfig
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::extensions::EntropySourceConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::EsploraSyncConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.background_sync_config.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::EsploraSyncConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::EsploraSyncConfig>>
    for ldk_adapter::types::EsploraSyncConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::EsploraSyncConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::FfiLogRecord> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.level.into_into_dart().into_dart(),
            self.0.args.into_into_dart().into_dart(),
            self.0.module_path.into_into_dart().into_dart(),
            self.0.line.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::FfiLogRecord>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::FfiLogRecord>>
    for ldk_adapter::types::FfiLogRecord
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::FfiLogRecord> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::extensions::GossipSourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::extensions::GossipSourceConfig::P2PNetwork => [0.into_dart()].into_dart(),
            crate::api::extensions::GossipSourceConfig::RapidGossipSync(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::extensions::GossipSourceConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::extensions::GossipSourceConfig>>
    for crate::api::extensions::GossipSourceConfig
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::extensions::GossipSourceConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::LiquiditySourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.lsps2_service.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::LiquiditySourceConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::LiquiditySourceConfig>>
    for ldk_adapter::types::LiquiditySourceConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::LiquiditySourceConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::LogLevel> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::LogLevel::Gossip => 0.into_dart(),
            ldk_adapter::types::LogLevel::Trace => 1.into_dart(),
            ldk_adapter::types::LogLevel::Debug => 2.into_dart(),
            ldk_adapter::types::LogLevel::Info => 3.into_dart(),
            ldk_adapter::types::LogLevel::Warn => 4.into_dart(),
            ldk_adapter::types::LogLevel::Error => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::LogLevel>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::LogLevel>>
    for ldk_adapter::types::LogLevel
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::LogLevel> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::LSPFeeLimits> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .max_total_opening_fee_msat
                .into_into_dart()
                .into_dart(),
            self.0
                .max_proportional_opening_fee_ppm_msat
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::LSPFeeLimits>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::LSPFeeLimits>>
    for ldk_adapter::types::LSPFeeLimits
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::LSPFeeLimits> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Mnemonic> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.words.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Mnemonic> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Mnemonic>> for shared::Mnemonic {
    fn into_into_dart(self) -> FrbWrapper<shared::Mnemonic> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Network> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            shared::Network::Bitcoin => 0.into_dart(),
            shared::Network::Testnet => 1.into_dart(),
            shared::Network::Testnet4 => 2.into_dart(),
            shared::Network::Signet => 3.into_dart(),
            shared::Network::Regtest => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Network> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Network>> for shared::Network {
    fn into_into_dart(self) -> FrbWrapper<shared::Network> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::NodeAlias> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::NodeAlias>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::NodeAlias>>
    for ldk_adapter::types::NodeAlias
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::NodeAlias> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.last_update.into_into_dart().into_dart(),
            self.0.alias.into_into_dart().into_dart(),
            self.0.addresses.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo>>
    for ldk_adapter::graph::NodeAnnouncementInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::NodeId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.compressed.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::NodeId>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::NodeId>>
    for ldk_adapter::graph::NodeId
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::NodeId> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::NodeInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.channels.into_into_dart().into_dart(),
            self.0.announcement_info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::NodeInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::NodeInfo>>
    for ldk_adapter::graph::NodeInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::NodeInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::NodeStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.is_running.into_into_dart().into_dart(),
            self.0.is_listening.into_into_dart().into_dart(),
            self.0.current_best_block.into_into_dart().into_dart(),
            self.0
                .latest_lightning_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_onchain_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_fee_rate_cache_update_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_rgs_snapshot_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_node_announcement_broadcast_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_channel_monitor_archival_height
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::NodeStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::NodeStatus>>
    for ldk_adapter::types::NodeStatus
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::NodeStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Offer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Offer> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Offer>> for shared::Offer {
    fn into_into_dart(self) -> FrbWrapper<shared::Offer> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::OfferId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::OfferId>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::OfferId>>
    for ldk_adapter::types::OfferId
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::OfferId> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::OutPoint> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.txid.into_into_dart().into_dart(),
            self.0.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::OutPoint> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::OutPoint>> for shared::OutPoint {
    fn into_into_dart(self) -> FrbWrapper<shared::OutPoint> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentDirection> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::PaymentDirection::Inbound => 0.into_dart(),
            ldk_adapter::types::PaymentDirection::Outbound => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentDirection>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentDirection>>
    for ldk_adapter::types::PaymentDirection
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentDirection> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentSecret> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentSecret>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentSecret>>
    for ldk_adapter::types::PaymentSecret
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentSecret> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::PaymentStatus::Pending => 0.into_dart(),
            ldk_adapter::types::PaymentStatus::Succeeded => 1.into_dart(),
            ldk_adapter::types::PaymentStatus::Failed => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentStatus>>
    for ldk_adapter::types::PaymentStatus
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Psbt> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.inner.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Psbt> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Psbt>> for shared::Psbt {
    fn into_into_dart(self) -> FrbWrapper<shared::Psbt> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Refund> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Refund> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Refund>> for shared::Refund {
    fn into_into_dart(self) -> FrbWrapper<shared::Refund> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::RoutingFees> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.base_msat.into_into_dart().into_dart(),
            self.0.proportional_millionths.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::RoutingFees>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::RoutingFees>>
    for ldk_adapter::graph::RoutingFees
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::RoutingFees> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::ScriptBuf> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.inner.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::ScriptBuf> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::ScriptBuf>> for shared::ScriptBuf {
    fn into_into_dart(self) -> FrbWrapper<shared::ScriptBuf> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::SendingParameters> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .max_total_routing_fee_msat
                .into_into_dart()
                .into_dart(),
            self.0
                .max_total_cltv_expiry_delta
                .into_into_dart()
                .into_dart(),
            self.0.max_path_count.into_into_dart().into_dart(),
            self.0
                .max_channel_saturation_power_of_half
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::SendingParameters>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::SendingParameters>>
    for shared::SendingParameters
{
    fn into_into_dart(self) -> FrbWrapper<shared::SendingParameters> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::extensions::SocketAddressType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::TcpIpV4 => 0.into_dart(),
            Self::TcpIpV6 => 1.into_dart(),
            Self::OnionV2 => 2.into_dart(),
            Self::OnionV3 => 3.into_dart(),
            Self::Hostname => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::extensions::SocketAddressType
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::extensions::SocketAddressType>
    for crate::api::extensions::SocketAddressType
{
    fn into_into_dart(self) -> crate::api::extensions::SocketAddressType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::TxIn> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.previous_output.into_into_dart().into_dart(),
            self.0.script_sig.into_into_dart().into_dart(),
            self.0.sequence.into_into_dart().into_dart(),
            self.0.witness.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::TxIn> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::TxIn>> for shared::TxIn {
    fn into_into_dart(self) -> FrbWrapper<shared::TxIn> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::TxOut> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.value.into_into_dart().into_dart(),
            self.0.script_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::TxOut> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::TxOut>> for shared::TxOut {
    fn into_into_dart(self) -> FrbWrapper<shared::TxOut> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Txid> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.hash.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Txid> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Txid>> for shared::Txid {
    fn into_into_dart(self) -> FrbWrapper<shared::Txid> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::WTxid> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.hash.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::WTxid> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::WTxid>> for shared::WTxid {
    fn into_into_dart(self) -> FrbWrapper<shared::WTxid> {
        self.into()
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for AddressData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for BitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for BitcoinAddressInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for BitcoinTransactionInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Bolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Bolt12Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for LdkBuilder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for NetworkGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Node {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for OnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentHash>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentId>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentPreimage>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for QrPaymentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for SpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for TaprootSpendInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for TaprootSpendInfoInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Transaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for UnifiedQrPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentHash>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentPreimage>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::extensions::AddressHostname {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.addr, serializer);
        <u16>::sse_encode(self.port, serializer);
    }
}

impl SseEncode for crate::api::extensions::AddressOnionV2 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 12]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for crate::api::extensions::AddressOnionV3 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.ed25519_pubkey, serializer);
        <u16>::sse_encode(self.checksum, serializer);
        <u8>::sse_encode(self.version, serializer);
        <u16>::sse_encode(self.port, serializer);
    }
}

impl SseEncode for crate::api::extensions::AddressTcpIpV4 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 4]>::sse_encode(self.addr, serializer);
        <u16>::sse_encode(self.port, serializer);
    }
}

impl SseEncode for crate::api::extensions::AddressTcpIpV6 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 16]>::sse_encode(self.addr, serializer);
        <u16>::sse_encode(self.port, serializer);
    }
}

impl SseEncode for ldk_adapter::types::AnchorChannelsConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<PublicKey>>::sse_encode(self.trusted_peers_no_reserve, serializer);
        <u64>::sse_encode(self.per_channel_reserve_sats, serializer);
    }
}

impl SseEncode for ldk_adapter::types::BackgroundSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.onchain_wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.lightning_wallet_sync_interval_secs, serializer);
        <u64>::sse_encode(self.fee_rate_cache_update_interval_secs, serializer);
    }
}

impl SseEncode for ldk_adapter::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.total_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.spendable_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.total_lightning_balance_sats, serializer);
        <Vec<LightningBalance>>::sse_encode(self.lightning_balances, serializer);
        <Vec<PendingSweepBalance>>::sse_encode(
            self.pending_balances_from_channel_closures,
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.block_hash, serializer);
        <u32>::sse_encode(self.height, serializer);
    }
}

impl SseEncode for shared::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::extensions::ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::extensions::ChainDataSourceConfig::Esplora {
                server_url,
                sync_config,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(server_url, serializer);
                <Option<ldk_adapter::types::EsploraSyncConfig>>::sse_encode(
                    sync_config,
                    serializer,
                );
            }
            crate::api::extensions::ChainDataSourceConfig::Electrum {
                server_url,
                sync_config,
            } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(server_url, serializer);
                <Option<ldk_adapter::types::ElectrumSyncConfig>>::sse_encode(
                    sync_config,
                    serializer,
                );
            }
            crate::api::extensions::ChainDataSourceConfig::BitcoindRpc {
                rpc_host,
                rpc_port,
                rpc_user,
                rpc_password,
            } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(rpc_host, serializer);
                <u16>::sse_encode(rpc_port, serializer);
                <String>::sse_encode(rpc_user, serializer);
                <String>::sse_encode(rpc_password, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for ldk_adapter::graph::ChannelInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <ldk_adapter::graph::NodeId>::sse_encode(self.node_one, serializer);
        <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_encode(self.one_to_two, serializer);
        <ldk_adapter::graph::NodeId>::sse_encode(self.node_two, serializer);
        <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_encode(self.two_to_one, serializer);
        <Option<u64>>::sse_encode(self.capacity_sats, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::ChannelUpdateInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.last_update, serializer);
        <bool>::sse_encode(self.enabled, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.htlc_minimum_msat, serializer);
        <u64>::sse_encode(self.htlc_maximum_msat, serializer);
        <ldk_adapter::graph::RoutingFees>::sse_encode(self.fees, serializer);
    }
}

impl SseEncode for crate::api::extensions::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.storage_dir_path, serializer);
        <shared::Network>::sse_encode(self.network, serializer);
        <Option<Vec<SocketAddress>>>::sse_encode(self.listening_addresses, serializer);
        <Option<Vec<SocketAddress>>>::sse_encode(self.announcement_addresses, serializer);
        <Option<ldk_adapter::types::NodeAlias>>::sse_encode(self.node_alias, serializer);
        <Vec<PublicKey>>::sse_encode(self.trusted_peers_0conf, serializer);
        <u64>::sse_encode(self.probing_liquidity_limit_multiplier, serializer);
        <Option<ldk_adapter::types::AnchorChannelsConfig>>::sse_encode(
            self.anchor_channels_config,
            serializer,
        );
        <Option<shared::SendingParameters>>::sse_encode(self.sending_parameters, serializer);
    }
}

impl SseEncode for ldk_adapter::types::CustomTlvRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.type_num, serializer);
        <Vec<u8>>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for ldk_adapter::types::ElectrumSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<ldk_adapter::types::BackgroundSyncConfig>>::sse_encode(
            self.background_sync_config,
            serializer,
        );
    }
}

impl SseEncode for crate::api::extensions::EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::extensions::EntropySourceConfig::SeedFile(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::api::extensions::EntropySourceConfig::SeedBytes(field0) => {
                <i32>::sse_encode(1, serializer);
                <Vec<u8>>::sse_encode(field0, serializer);
            }
            crate::api::extensions::EntropySourceConfig::Bip39Mnemonic(field0, field1) => {
                <i32>::sse_encode(2, serializer);
                <shared::Mnemonic>::sse_encode(field0, serializer);
                <Option<String>>::sse_encode(field1, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for ldk_adapter::types::EsploraSyncConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<ldk_adapter::types::BackgroundSyncConfig>>::sse_encode(
            self.background_sync_config,
            serializer,
        );
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for ldk_adapter::types::FfiLogRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <ldk_adapter::types::LogLevel>::sse_encode(self.level, serializer);
        <String>::sse_encode(self.args, serializer);
        <String>::sse_encode(self.module_path, serializer);
        <u32>::sse_encode(self.line, serializer);
    }
}

impl SseEncode for crate::api::extensions::GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::extensions::GossipSourceConfig::P2PNetwork => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::extensions::GossipSourceConfig::RapidGossipSync(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for ldk_adapter::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <(SocketAddress, PublicKey, Option<String>)>::sse_encode(self.lsps2_service, serializer);
    }
}

impl SseEncode for Vec<ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ChannelDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <LightningBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <PaymentDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <PeerDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <PendingSweepBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <PublicKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <SocketAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ldk_adapter::types::CustomTlvRecord> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ldk_adapter::types::CustomTlvRecord>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<u8>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ldk_adapter::graph::NodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ldk_adapter::graph::NodeId>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<shared::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <shared::TxIn>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<shared::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <shared::TxOut>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for ldk_adapter::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::LogLevel::Gossip => 0,
                ldk_adapter::types::LogLevel::Trace => 1,
                ldk_adapter::types::LogLevel::Debug => 2,
                ldk_adapter::types::LogLevel::Info => 3,
                ldk_adapter::types::LogLevel::Warn => 4,
                ldk_adapter::types::LogLevel::Error => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::LSPFeeLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.max_total_opening_fee_msat, serializer);
        <Option<u64>>::sse_encode(self.max_proportional_opening_fee_ppm_msat, serializer);
    }
}

impl SseEncode for shared::Mnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.words, serializer);
    }
}

impl SseEncode for shared::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                shared::Network::Bitcoin => 0,
                shared::Network::Testnet => 1,
                shared::Network::Testnet4 => 2,
                shared::Network::Signet => 3,
                shared::Network::Regtest => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::NodeAlias {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::NodeAnnouncementInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.last_update, serializer);
        <String>::sse_encode(self.alias, serializer);
        <Vec<SocketAddress>>::sse_encode(self.addresses, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::NodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.compressed, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::NodeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u64>>::sse_encode(self.channels, serializer);
        <Option<ldk_adapter::graph::NodeAnnouncementInfo>>::sse_encode(
            self.announcement_info,
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_running, serializer);
        <bool>::sse_encode(self.is_listening, serializer);
        <ldk_adapter::types::BestBlock>::sse_encode(self.current_best_block, serializer);
        <Option<u64>>::sse_encode(self.latest_lightning_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_onchain_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_fee_rate_cache_update_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_rgs_snapshot_timestamp, serializer);
        <Option<u64>>::sse_encode(
            self.latest_node_announcement_broadcast_timestamp,
            serializer,
        );
        <Option<u32>>::sse_encode(self.latest_channel_monitor_archival_height, serializer);
    }
}

impl SseEncode for shared::Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for ldk_adapter::types::OfferId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ChannelConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ChannelId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ChannelId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Event>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <PaymentDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::extensions::AddressHostname> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::extensions::AddressHostname>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::extensions::AddressOnionV2> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::extensions::AddressOnionV2>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::extensions::AddressOnionV3> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::extensions::AddressOnionV3>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::extensions::AddressTcpIpV4> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::extensions::AddressTcpIpV4>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::extensions::AddressTcpIpV6> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::extensions::AddressTcpIpV6>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::AnchorChannelsConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::AnchorChannelsConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::BackgroundSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::BackgroundSyncConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::extensions::ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::extensions::ChainDataSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::ChannelInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::ChannelInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::ChannelUpdateInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::ChannelUpdateInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::ElectrumSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::ElectrumSyncConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::extensions::EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::extensions::EntropySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::EsploraSyncConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::EsploraSyncConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::extensions::GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::extensions::GossipSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::LiquiditySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::LogLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::LogLevel>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::NodeAlias> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::NodeAlias>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::NodeAnnouncementInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::NodeAnnouncementInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::NodeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::NodeInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::OfferId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::OfferId>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<shared::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <shared::OutPoint>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::PaymentSecret> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::PaymentSecret>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<shared::SendingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <shared::SendingParameters>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u16>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<SocketAddress>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for shared::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <shared::Txid>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for ldk_adapter::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::PaymentDirection::Inbound => 0,
                ldk_adapter::types::PaymentDirection::Outbound => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::PaymentSecret {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for ldk_adapter::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::PaymentStatus::Pending => 0,
                ldk_adapter::types::PaymentStatus::Succeeded => 1,
                ldk_adapter::types::PaymentStatus::Failed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for shared::Psbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for (SocketAddress, PublicKey, Option<String>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <SocketAddress>::sse_encode(self.0, serializer);
        <PublicKey>::sse_encode(self.1, serializer);
        <Option<String>>::sse_encode(self.2, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for shared::Refund {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::RoutingFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.base_msat, serializer);
        <u32>::sse_encode(self.proportional_millionths, serializer);
    }
}

impl SseEncode for shared::ScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for shared::SendingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.max_total_routing_fee_msat, serializer);
        <Option<u32>>::sse_encode(self.max_total_cltv_expiry_delta, serializer);
        <Option<u8>>::sse_encode(self.max_path_count, serializer);
        <Option<u8>>::sse_encode(self.max_channel_saturation_power_of_half, serializer);
    }
}

impl SseEncode for crate::api::extensions::SocketAddressType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::extensions::SocketAddressType::TcpIpV4 => 0,
                crate::api::extensions::SocketAddressType::TcpIpV6 => 1,
                crate::api::extensions::SocketAddressType::OnionV2 => 2,
                crate::api::extensions::SocketAddressType::OnionV3 => 3,
                crate::api::extensions::SocketAddressType::Hostname => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for shared::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <shared::OutPoint>::sse_encode(self.previous_output, serializer);
        <shared::ScriptBuf>::sse_encode(self.script_sig, serializer);
        <u32>::sse_encode(self.sequence, serializer);
        <Vec<Vec<u8>>>::sse_encode(self.witness, serializer);
    }
}

impl SseEncode for shared::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.value, serializer);
        <shared::ScriptBuf>::sse_encode(self.script_pubkey, serializer);
    }
}

impl SseEncode for shared::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for [u8; 12] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 16] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 4] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for shared::WTxid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::extensions::ESocketAddress;
    use crate::api::extensions::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};
    use ldk_adapter::bolt11::*;
    use ldk_adapter::bolt12::*;
    use ldk_adapter::builder::*;
    use ldk_adapter::graph::*;
    use ldk_adapter::node::*;
    use ldk_adapter::on_chain::*;
    use ldk_adapter::spontaneous::*;
    use ldk_adapter::types::*;
    use ldk_adapter::unified_qr::*;
    use shared::*;

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<AddressData> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> AddressData {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<BitcoinAddress> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> BitcoinAddress {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<BitcoinAddressInner> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> BitcoinAddressInner {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<BitcoinTransactionInner> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> BitcoinTransactionInner {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                        BitcoinTransactionInner,
                    >,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Bolt11Invoice> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Bolt11Invoice {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Bolt11Payment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Bolt11Payment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Bolt12Payment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Bolt12Payment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ChannelConfig> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelConfig {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ChannelDetails> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelDetails {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ChannelId> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Event> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Event {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<LdkBuilder> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> LdkBuilder {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<LightningBalance> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> LightningBalance {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<MaxDustHTLCExposure> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> MaxDustHTLCExposure {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<NetworkGraph> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> NetworkGraph {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Node> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Node {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<OnChainPayment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> OnChainPayment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PaymentDetails> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PaymentDetails {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PaymentHash> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PaymentHash {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentHash>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PaymentId> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PaymentId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentId>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PaymentKind> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PaymentKind {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PaymentPreimage> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PaymentPreimage {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentPreimage>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PeerDetails> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PeerDetails {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PendingSweepBalance> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PendingSweepBalance {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PublicKey> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PublicKey {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<QrPaymentResult> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> QrPaymentResult {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<SocketAddress> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> SocketAddress {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<SpontaneousPayment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> SpontaneousPayment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<TaprootSpendInfo> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> TaprootSpendInfo {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<TaprootSpendInfoInner> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> TaprootSpendInfoInner {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Transaction> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Transaction {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<UnifiedQrPayment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> UnifiedQrPayment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<UserChannelId> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> UserChannelId {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<std::collections::HashMap<String, String>>
        for *mut wire_cst_list_record_string_string
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> std::collections::HashMap<String, String> {
            let vec: Vec<(String, String)> = self.cst_decode();
            vec.into_iter().collect()
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentHash>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentHash>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentId>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentId>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentPreimage>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentPreimage>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<crate::api::extensions::AddressHostname> for wire_cst_address_hostname {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::AddressHostname {
            crate::api::extensions::AddressHostname {
                addr: self.addr.cst_decode(),
                port: self.port.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::extensions::AddressOnionV2> for wire_cst_address_onion_v_2 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::AddressOnionV2 {
            crate::api::extensions::AddressOnionV2(self.field0.cst_decode())
        }
    }
    impl CstDecode<crate::api::extensions::AddressOnionV3> for wire_cst_address_onion_v_3 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::AddressOnionV3 {
            crate::api::extensions::AddressOnionV3 {
                ed25519_pubkey: self.ed25519_pubkey.cst_decode(),
                checksum: self.checksum.cst_decode(),
                version: self.version.cst_decode(),
                port: self.port.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::extensions::AddressTcpIpV4> for wire_cst_address_tcp_ip_v_4 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::AddressTcpIpV4 {
            crate::api::extensions::AddressTcpIpV4 {
                addr: self.addr.cst_decode(),
                port: self.port.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::extensions::AddressTcpIpV6> for wire_cst_address_tcp_ip_v_6 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::AddressTcpIpV6 {
            crate::api::extensions::AddressTcpIpV6 {
                addr: self.addr.cst_decode(),
                port: self.port.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::AnchorChannelsConfig> for wire_cst_anchor_channels_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::AnchorChannelsConfig {
            ldk_adapter::types::AnchorChannelsConfig {
                trusted_peers_no_reserve: self.trusted_peers_no_reserve.cst_decode(),
                per_channel_reserve_sats: self.per_channel_reserve_sats.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::BackgroundSyncConfig> for wire_cst_background_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::BackgroundSyncConfig {
            ldk_adapter::types::BackgroundSyncConfig {
                onchain_wallet_sync_interval_secs: self
                    .onchain_wallet_sync_interval_secs
                    .cst_decode(),
                lightning_wallet_sync_interval_secs: self
                    .lightning_wallet_sync_interval_secs
                    .cst_decode(),
                fee_rate_cache_update_interval_secs: self
                    .fee_rate_cache_update_interval_secs
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::BalanceDetails> for wire_cst_balance_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::BalanceDetails {
            ldk_adapter::types::BalanceDetails {
                total_onchain_balance_sats: self.total_onchain_balance_sats.cst_decode(),
                spendable_onchain_balance_sats: self.spendable_onchain_balance_sats.cst_decode(),
                total_lightning_balance_sats: self.total_lightning_balance_sats.cst_decode(),
                lightning_balances: self.lightning_balances.cst_decode(),
                pending_balances_from_channel_closures: self
                    .pending_balances_from_channel_closures
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::BestBlock> for wire_cst_best_block {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::BestBlock {
            ldk_adapter::types::BestBlock {
                block_hash: self.block_hash.cst_decode(),
                height: self.height.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Bolt12Invoice> for wire_cst_bolt_12_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Bolt12Invoice {
            shared::Bolt12Invoice {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<ChannelConfig> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ChannelConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ChannelId> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ChannelId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<Event> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Event {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<Event>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<PaymentDetails> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PaymentDetails {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<PaymentDetails>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::extensions::AddressHostname> for *mut wire_cst_address_hostname {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::AddressHostname {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::extensions::AddressHostname>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::extensions::AddressOnionV2> for *mut wire_cst_address_onion_v_2 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::AddressOnionV2 {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::extensions::AddressOnionV2>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::extensions::AddressOnionV3> for *mut wire_cst_address_onion_v_3 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::AddressOnionV3 {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::extensions::AddressOnionV3>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::extensions::AddressTcpIpV4> for *mut wire_cst_address_tcp_ip_v_4 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::AddressTcpIpV4 {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::extensions::AddressTcpIpV4>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::extensions::AddressTcpIpV6> for *mut wire_cst_address_tcp_ip_v_6 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::AddressTcpIpV6 {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::extensions::AddressTcpIpV6>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::AnchorChannelsConfig> for *mut wire_cst_anchor_channels_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::AnchorChannelsConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::AnchorChannelsConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::BackgroundSyncConfig> for *mut wire_cst_background_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::BackgroundSyncConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::BackgroundSyncConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::extensions::ChainDataSourceConfig>
        for *mut wire_cst_chain_data_source_config
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::ChainDataSourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::extensions::ChainDataSourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelInfo> for *mut wire_cst_channel_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::ChannelInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelUpdateInfo> for *mut wire_cst_channel_update_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelUpdateInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::ChannelUpdateInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::extensions::Config> for *mut wire_cst_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::Config {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::extensions::Config>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::CustomTlvRecord> for *mut wire_cst_custom_tlv_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::CustomTlvRecord {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::CustomTlvRecord>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::ElectrumSyncConfig> for *mut wire_cst_electrum_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::ElectrumSyncConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::ElectrumSyncConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::extensions::EntropySourceConfig>
        for *mut wire_cst_entropy_source_config
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::EntropySourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::extensions::EntropySourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::EsploraSyncConfig> for *mut wire_cst_esplora_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::EsploraSyncConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::EsploraSyncConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::FfiLogRecord> for *mut wire_cst_ffi_log_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::FfiLogRecord {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::FfiLogRecord>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::extensions::GossipSourceConfig> for *mut wire_cst_gossip_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::GossipSourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::extensions::GossipSourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::LiquiditySourceConfig>
        for *mut wire_cst_liquidity_source_config
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LiquiditySourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::LiquiditySourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::LogLevel> for *mut i32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LogLevel {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::LogLevel>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Mnemonic> for *mut wire_cst_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Mnemonic {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Mnemonic>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::NodeAlias> for *mut wire_cst_node_alias {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::NodeAlias {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::NodeAlias>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeAnnouncementInfo> for *mut wire_cst_node_announcement_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeAnnouncementInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::NodeAnnouncementInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeId> for *mut wire_cst_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::NodeId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeInfo> for *mut wire_cst_node_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::NodeInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Offer> for *mut wire_cst_offer {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Offer {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Offer>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::OfferId> for *mut wire_cst_offer_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::OfferId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::OfferId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::OutPoint> for *mut wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::OutPoint {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::OutPoint>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::PaymentSecret> for *mut wire_cst_payment_secret {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::PaymentSecret {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::PaymentSecret>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Psbt> for *mut wire_cst_psbt {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Psbt {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Psbt>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Refund> for *mut wire_cst_refund {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Refund {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Refund>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::ScriptBuf> for *mut wire_cst_script_buf {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::ScriptBuf {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::ScriptBuf>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::SendingParameters> for *mut wire_cst_sending_parameters {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::SendingParameters {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::SendingParameters>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u16> for *mut u16 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u16 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u64> for *mut u64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u8> for *mut u8 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<crate::api::extensions::ChainDataSourceConfig>
        for wire_cst_chain_data_source_config
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::ChainDataSourceConfig {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Esplora };
                    crate::api::extensions::ChainDataSourceConfig::Esplora {
                        server_url: ans.server_url.cst_decode(),
                        sync_config: ans.sync_config.cst_decode(),
                    }
                }
                1 => {
                    let ans = unsafe { self.kind.Electrum };
                    crate::api::extensions::ChainDataSourceConfig::Electrum {
                        server_url: ans.server_url.cst_decode(),
                        sync_config: ans.sync_config.cst_decode(),
                    }
                }
                2 => {
                    let ans = unsafe { self.kind.BitcoindRpc };
                    crate::api::extensions::ChainDataSourceConfig::BitcoindRpc {
                        rpc_host: ans.rpc_host.cst_decode(),
                        rpc_port: ans.rpc_port.cst_decode(),
                        rpc_user: ans.rpc_user.cst_decode(),
                        rpc_password: ans.rpc_password.cst_decode(),
                    }
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelInfo> for wire_cst_channel_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelInfo {
            ldk_adapter::graph::ChannelInfo {
                node_one: self.node_one.cst_decode(),
                one_to_two: self.one_to_two.cst_decode(),
                node_two: self.node_two.cst_decode(),
                two_to_one: self.two_to_one.cst_decode(),
                capacity_sats: self.capacity_sats.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelUpdateInfo> for wire_cst_channel_update_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelUpdateInfo {
            ldk_adapter::graph::ChannelUpdateInfo {
                last_update: self.last_update.cst_decode(),
                enabled: self.enabled.cst_decode(),
                cltv_expiry_delta: self.cltv_expiry_delta.cst_decode(),
                htlc_minimum_msat: self.htlc_minimum_msat.cst_decode(),
                htlc_maximum_msat: self.htlc_maximum_msat.cst_decode(),
                fees: self.fees.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::extensions::Config> for wire_cst_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::Config {
            crate::api::extensions::Config {
                storage_dir_path: self.storage_dir_path.cst_decode(),
                network: self.network.cst_decode(),
                listening_addresses: self.listening_addresses.cst_decode(),
                announcement_addresses: self.announcement_addresses.cst_decode(),
                node_alias: self.node_alias.cst_decode(),
                trusted_peers_0conf: self.trusted_peers_0conf.cst_decode(),
                probing_liquidity_limit_multiplier: self
                    .probing_liquidity_limit_multiplier
                    .cst_decode(),
                anchor_channels_config: self.anchor_channels_config.cst_decode(),
                sending_parameters: self.sending_parameters.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::CustomTlvRecord> for wire_cst_custom_tlv_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::CustomTlvRecord {
            ldk_adapter::types::CustomTlvRecord {
                type_num: self.type_num.cst_decode(),
                value: self.value.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::ElectrumSyncConfig> for wire_cst_electrum_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::ElectrumSyncConfig {
            ldk_adapter::types::ElectrumSyncConfig {
                background_sync_config: self.background_sync_config.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::extensions::EntropySourceConfig> for wire_cst_entropy_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::EntropySourceConfig {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.SeedFile };
                    crate::api::extensions::EntropySourceConfig::SeedFile(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.SeedBytes };
                    crate::api::extensions::EntropySourceConfig::SeedBytes(ans.field0.cst_decode())
                }
                2 => {
                    let ans = unsafe { self.kind.Bip39Mnemonic };
                    crate::api::extensions::EntropySourceConfig::Bip39Mnemonic(
                        ans.field0.cst_decode(),
                        ans.field1.cst_decode(),
                    )
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::EsploraSyncConfig> for wire_cst_esplora_sync_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::EsploraSyncConfig {
            ldk_adapter::types::EsploraSyncConfig {
                background_sync_config: self.background_sync_config.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::FfiLogRecord> for wire_cst_ffi_log_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::FfiLogRecord {
            ldk_adapter::types::FfiLogRecord {
                level: self.level.cst_decode(),
                args: self.args.cst_decode(),
                module_path: self.module_path.cst_decode(),
                line: self.line.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::extensions::GossipSourceConfig> for wire_cst_gossip_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::extensions::GossipSourceConfig {
            match self.tag {
                0 => crate::api::extensions::GossipSourceConfig::P2PNetwork,
                1 => {
                    let ans = unsafe { self.kind.RapidGossipSync };
                    crate::api::extensions::GossipSourceConfig::RapidGossipSync(
                        ans.field0.cst_decode(),
                    )
                }
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::LiquiditySourceConfig> for wire_cst_liquidity_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LiquiditySourceConfig {
            ldk_adapter::types::LiquiditySourceConfig {
                lsps2_service: self.lsps2_service.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<ChannelDetails>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<ChannelDetails> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<LightningBalance>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<LightningBalance> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<PaymentDetails>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<PaymentDetails> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<PeerDetails>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<PeerDetails> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<PendingSweepBalance>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<PendingSweepBalance> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<PublicKey>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<PublicKey> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<SocketAddress>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<SocketAddress> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<String>> for *mut wire_cst_list_String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<ldk_adapter::types::CustomTlvRecord>> for *mut wire_cst_list_custom_tlv_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<ldk_adapter::types::CustomTlvRecord> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<Vec<u8>>> for *mut wire_cst_list_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<Vec<u8>> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<ldk_adapter::graph::NodeId>> for *mut wire_cst_list_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<ldk_adapter::graph::NodeId> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<u64>> for *mut wire_cst_list_prim_u_64_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u64> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<(String, String)>> for *mut wire_cst_list_record_string_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(String, String)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<shared::TxIn>> for *mut wire_cst_list_tx_in {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<shared::TxIn> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<shared::TxOut>> for *mut wire_cst_list_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<shared::TxOut> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<ldk_adapter::types::LSPFeeLimits> for wire_cst_lsp_fee_limits {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LSPFeeLimits {
            ldk_adapter::types::LSPFeeLimits {
                max_total_opening_fee_msat: self.max_total_opening_fee_msat.cst_decode(),
                max_proportional_opening_fee_ppm_msat: self
                    .max_proportional_opening_fee_ppm_msat
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Mnemonic> for wire_cst_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Mnemonic {
            shared::Mnemonic {
                words: self.words.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::NodeAlias> for wire_cst_node_alias {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::NodeAlias {
            ldk_adapter::types::NodeAlias(self.field0.cst_decode())
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeAnnouncementInfo> for wire_cst_node_announcement_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeAnnouncementInfo {
            ldk_adapter::graph::NodeAnnouncementInfo {
                last_update: self.last_update.cst_decode(),
                alias: self.alias.cst_decode(),
                addresses: self.addresses.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeId> for wire_cst_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeId {
            ldk_adapter::graph::NodeId {
                compressed: self.compressed.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeInfo> for wire_cst_node_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeInfo {
            ldk_adapter::graph::NodeInfo {
                channels: self.channels.cst_decode(),
                announcement_info: self.announcement_info.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::NodeStatus> for wire_cst_node_status {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::NodeStatus {
            ldk_adapter::types::NodeStatus {
                is_running: self.is_running.cst_decode(),
                is_listening: self.is_listening.cst_decode(),
                current_best_block: self.current_best_block.cst_decode(),
                latest_lightning_wallet_sync_timestamp: self
                    .latest_lightning_wallet_sync_timestamp
                    .cst_decode(),
                latest_onchain_wallet_sync_timestamp: self
                    .latest_onchain_wallet_sync_timestamp
                    .cst_decode(),
                latest_fee_rate_cache_update_timestamp: self
                    .latest_fee_rate_cache_update_timestamp
                    .cst_decode(),
                latest_rgs_snapshot_timestamp: self.latest_rgs_snapshot_timestamp.cst_decode(),
                latest_node_announcement_broadcast_timestamp: self
                    .latest_node_announcement_broadcast_timestamp
                    .cst_decode(),
                latest_channel_monitor_archival_height: self
                    .latest_channel_monitor_archival_height
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Offer> for wire_cst_offer {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Offer {
            shared::Offer {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::OfferId> for wire_cst_offer_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::OfferId {
            ldk_adapter::types::OfferId(self.field0.cst_decode())
        }
    }
    impl CstDecode<shared::OutPoint> for wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::OutPoint {
            shared::OutPoint {
                txid: self.txid.cst_decode(),
                vout: self.vout.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::PaymentSecret> for wire_cst_payment_secret {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::PaymentSecret {
            ldk_adapter::types::PaymentSecret {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Psbt> for wire_cst_psbt {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Psbt {
            shared::Psbt {
                inner: self.inner.cst_decode(),
            }
        }
    }
    impl CstDecode<(SocketAddress,PublicKey,Option<String>,)> for wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_public_key_opt_string {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> (SocketAddress,PublicKey,Option<String>,) {
                (self.field0.cst_decode(),self.field1.cst_decode(),self.field2.cst_decode(),)
            }
        }
    impl CstDecode<(String, String)> for wire_cst_record_string_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (String, String) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<shared::Refund> for wire_cst_refund {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Refund {
            shared::Refund {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::RoutingFees> for wire_cst_routing_fees {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::RoutingFees {
            ldk_adapter::graph::RoutingFees {
                base_msat: self.base_msat.cst_decode(),
                proportional_millionths: self.proportional_millionths.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::ScriptBuf> for wire_cst_script_buf {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::ScriptBuf {
            shared::ScriptBuf {
                inner: self.inner.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::SendingParameters> for wire_cst_sending_parameters {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::SendingParameters {
            shared::SendingParameters {
                max_total_routing_fee_msat: self.max_total_routing_fee_msat.cst_decode(),
                max_total_cltv_expiry_delta: self.max_total_cltv_expiry_delta.cst_decode(),
                max_path_count: self.max_path_count.cst_decode(),
                max_channel_saturation_power_of_half: self
                    .max_channel_saturation_power_of_half
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<shared::TxIn> for wire_cst_tx_in {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::TxIn {
            shared::TxIn {
                previous_output: self.previous_output.cst_decode(),
                script_sig: self.script_sig.cst_decode(),
                sequence: self.sequence.cst_decode(),
                witness: self.witness.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::TxOut> for wire_cst_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::TxOut {
            shared::TxOut {
                value: self.value.cst_decode(),
                script_pubkey: self.script_pubkey.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Txid> for wire_cst_txid {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Txid {
            shared::Txid {
                hash: self.hash.cst_decode(),
            }
        }
    }
    impl CstDecode<[u8; 12]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 12] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<[u8; 16]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 16] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<[u8; 32]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 32] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<[u8; 4]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 4] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<[u8; 64]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 64] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<shared::WTxid> for wire_cst_w_txid {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::WTxid {
            shared::WTxid {
                hash: self.hash.cst_decode(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_address_hostname {
        fn new_with_null_ptr() -> Self {
            Self {
                addr: core::ptr::null_mut(),
                port: Default::default(),
            }
        }
    }
    impl Default for wire_cst_address_hostname {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_address_onion_v_2 {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_address_onion_v_2 {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_address_onion_v_3 {
        fn new_with_null_ptr() -> Self {
            Self {
                ed25519_pubkey: core::ptr::null_mut(),
                checksum: Default::default(),
                version: Default::default(),
                port: Default::default(),
            }
        }
    }
    impl Default for wire_cst_address_onion_v_3 {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_address_tcp_ip_v_4 {
        fn new_with_null_ptr() -> Self {
            Self {
                addr: core::ptr::null_mut(),
                port: Default::default(),
            }
        }
    }
    impl Default for wire_cst_address_tcp_ip_v_4 {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_address_tcp_ip_v_6 {
        fn new_with_null_ptr() -> Self {
            Self {
                addr: core::ptr::null_mut(),
                port: Default::default(),
            }
        }
    }
    impl Default for wire_cst_address_tcp_ip_v_6 {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_anchor_channels_config {
        fn new_with_null_ptr() -> Self {
            Self {
                trusted_peers_no_reserve: core::ptr::null_mut(),
                per_channel_reserve_sats: Default::default(),
            }
        }
    }
    impl Default for wire_cst_anchor_channels_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_background_sync_config {
        fn new_with_null_ptr() -> Self {
            Self {
                onchain_wallet_sync_interval_secs: Default::default(),
                lightning_wallet_sync_interval_secs: Default::default(),
                fee_rate_cache_update_interval_secs: Default::default(),
            }
        }
    }
    impl Default for wire_cst_background_sync_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_balance_details {
        fn new_with_null_ptr() -> Self {
            Self {
                total_onchain_balance_sats: Default::default(),
                spendable_onchain_balance_sats: Default::default(),
                total_lightning_balance_sats: Default::default(),
                lightning_balances: core::ptr::null_mut(),
                pending_balances_from_channel_closures: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_balance_details {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_best_block {
        fn new_with_null_ptr() -> Self {
            Self {
                block_hash: core::ptr::null_mut(),
                height: Default::default(),
            }
        }
    }
    impl Default for wire_cst_best_block {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bolt_12_invoice {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bolt_12_invoice {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_chain_data_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: ChainDataSourceConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_chain_data_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_info {
        fn new_with_null_ptr() -> Self {
            Self {
                node_one: Default::default(),
                one_to_two: core::ptr::null_mut(),
                node_two: Default::default(),
                two_to_one: core::ptr::null_mut(),
                capacity_sats: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_channel_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_update_info {
        fn new_with_null_ptr() -> Self {
            Self {
                last_update: Default::default(),
                enabled: Default::default(),
                cltv_expiry_delta: Default::default(),
                htlc_minimum_msat: Default::default(),
                htlc_maximum_msat: Default::default(),
                fees: Default::default(),
            }
        }
    }
    impl Default for wire_cst_channel_update_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_config {
        fn new_with_null_ptr() -> Self {
            Self {
                storage_dir_path: core::ptr::null_mut(),
                network: Default::default(),
                listening_addresses: core::ptr::null_mut(),
                announcement_addresses: core::ptr::null_mut(),
                node_alias: core::ptr::null_mut(),
                trusted_peers_0conf: core::ptr::null_mut(),
                probing_liquidity_limit_multiplier: Default::default(),
                anchor_channels_config: core::ptr::null_mut(),
                sending_parameters: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_custom_tlv_record {
        fn new_with_null_ptr() -> Self {
            Self {
                type_num: Default::default(),
                value: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_custom_tlv_record {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_electrum_sync_config {
        fn new_with_null_ptr() -> Self {
            Self {
                background_sync_config: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_electrum_sync_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_entropy_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: EntropySourceConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_entropy_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_esplora_sync_config {
        fn new_with_null_ptr() -> Self {
            Self {
                background_sync_config: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_esplora_sync_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_log_record {
        fn new_with_null_ptr() -> Self {
            Self {
                level: Default::default(),
                args: core::ptr::null_mut(),
                module_path: core::ptr::null_mut(),
                line: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_log_record {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_gossip_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: GossipSourceConfigKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_gossip_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_liquidity_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                lsps2_service: Default::default(),
            }
        }
    }
    impl Default for wire_cst_liquidity_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_lsp_fee_limits {
        fn new_with_null_ptr() -> Self {
            Self {
                max_total_opening_fee_msat: core::ptr::null_mut(),
                max_proportional_opening_fee_ppm_msat: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_lsp_fee_limits {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_mnemonic {
        fn new_with_null_ptr() -> Self {
            Self {
                words: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_mnemonic {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_alias {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_alias {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_announcement_info {
        fn new_with_null_ptr() -> Self {
            Self {
                last_update: Default::default(),
                alias: core::ptr::null_mut(),
                addresses: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_announcement_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_id {
        fn new_with_null_ptr() -> Self {
            Self {
                compressed: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_info {
        fn new_with_null_ptr() -> Self {
            Self {
                channels: core::ptr::null_mut(),
                announcement_info: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_status {
        fn new_with_null_ptr() -> Self {
            Self {
                is_running: Default::default(),
                is_listening: Default::default(),
                current_best_block: Default::default(),
                latest_lightning_wallet_sync_timestamp: core::ptr::null_mut(),
                latest_onchain_wallet_sync_timestamp: core::ptr::null_mut(),
                latest_fee_rate_cache_update_timestamp: core::ptr::null_mut(),
                latest_rgs_snapshot_timestamp: core::ptr::null_mut(),
                latest_node_announcement_broadcast_timestamp: core::ptr::null_mut(),
                latest_channel_monitor_archival_height: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_status {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_offer {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_offer {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_offer_id {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_offer_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_out_point {
        fn new_with_null_ptr() -> Self {
            Self {
                txid: Default::default(),
                vout: Default::default(),
            }
        }
    }
    impl Default for wire_cst_out_point {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_secret {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_secret {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_psbt {
        fn new_with_null_ptr() -> Self {
            Self {
                inner: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_psbt {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_public_key_opt_string {
            fn new_with_null_ptr() -> Self {
                Self { field0: Default::default(),
field1: Default::default(),
field2: core::ptr::null_mut(), }
            }
        }
    impl Default for wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_public_key_opt_string {
            fn default() -> Self {
                Self::new_with_null_ptr()
            }
        }
    impl NewWithNullPtr for wire_cst_record_string_string {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
                field1: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_string_string {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_refund {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_refund {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_routing_fees {
        fn new_with_null_ptr() -> Self {
            Self {
                base_msat: Default::default(),
                proportional_millionths: Default::default(),
            }
        }
    }
    impl Default for wire_cst_routing_fees {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_script_buf {
        fn new_with_null_ptr() -> Self {
            Self {
                inner: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_script_buf {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sending_parameters {
        fn new_with_null_ptr() -> Self {
            Self {
                max_total_routing_fee_msat: core::ptr::null_mut(),
                max_total_cltv_expiry_delta: core::ptr::null_mut(),
                max_path_count: core::ptr::null_mut(),
                max_channel_saturation_power_of_half: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_sending_parameters {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_in {
        fn new_with_null_ptr() -> Self {
            Self {
                previous_output: Default::default(),
                script_sig: Default::default(),
                sequence: Default::default(),
                witness: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_tx_in {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_out {
        fn new_with_null_ptr() -> Self {
            Self {
                value: Default::default(),
                script_pubkey: Default::default(),
            }
        }
    }
    impl Default for wire_cst_tx_out {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_txid {
        fn new_with_null_ptr() -> Self {
            Self {
                hash: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_txid {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_w_txid {
        fn new_with_null_ptr() -> Self {
            Self {
                hash: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_w_txid {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_as_string(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_as_string_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_auto_accessor_get_inner(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__BitcoinAddress_auto_accessor_get_inner_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_auto_accessor_set_inner(
        that: usize,
        inner: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__BitcoinAddress_auto_accessor_set_inner_impl(that, inner)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_from_script(
        port_: i64,
        script: *mut wire_cst_script_buf,
        network: i32,
    ) {
        wire__shared__BitcoinAddress_from_script_impl(port_, script, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_from_string(
        port_: i64,
        address: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__shared__BitcoinAddress_from_string_impl(port_, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_is_valid_for_network(
        port_: i64,
        that: usize,
        network: i32,
    ) {
        wire__shared__BitcoinAddress_is_valid_for_network_impl(port_, that, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_new(
        port_: i64,
        address: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
    ) {
        wire__shared__BitcoinAddress_new_impl(port_, address, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_script_pubkey(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_script_pubkey_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_to_address_data(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_to_address_data_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_to_qr_uri(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_to_qr_uri_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Bolt11Invoice_new(
        signed_raw_invoice: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__Bolt11Invoice_new_impl(signed_raw_invoice)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Bolt11Invoice_to_string(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__Bolt11Invoice_to_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_claim_for_hash(
        port_: i64,
        that: usize,
        payment_hash: usize,
        claimable_amount_msat: u64,
        preimage: usize,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_claim_for_hash_impl(
            port_,
            that,
            payment_hash,
            claimable_amount_msat,
            preimage,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_fail_for_hash(
        port_: i64,
        that: usize,
        payment_hash: usize,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_fail_for_hash_impl(port_, that, payment_hash)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive(
        port_: i64,
        that: usize,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_for_hash(
        port_: i64,
        that: usize,
        payment_hash: usize,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_for_hash_impl(
            port_,
            that,
            payment_hash,
            amount_msat,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_impl(
            port_,
            that,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_for_hash(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        payment_hash: usize,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_for_hash_impl(
            port_,
            that,
            description,
            expiry_secs,
            payment_hash,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_via_jit_channel(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        max_proportional_lsp_fee_limit_ppm_msat: *mut u64,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_via_jit_channel_impl(
            port_,
            that,
            description,
            expiry_secs,
            max_proportional_lsp_fee_limit_ppm_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_via_jit_channel(
        port_: i64,
        that: usize,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        max_total_lsp_fee_limit_msat: *mut u64,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_via_jit_channel_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
            max_total_lsp_fee_limit_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send(
        port_: i64,
        that: usize,
        invoice: usize,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_impl(port_, that, invoice, sending_parameters)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send_probes(
        port_: i64,
        that: usize,
        invoice: usize,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_impl(port_, that, invoice)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_using_amount(
        port_: i64,
        that: usize,
        invoice: usize,
        amount_msat: u64,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_using_amount_impl(
            port_,
            that,
            invoice,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send_using_amount(
        port_: i64,
        that: usize,
        invoice: usize,
        amount_msat: u64,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_using_amount_impl(
            port_,
            that,
            invoice,
            amount_msat,
            sending_parameters,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_initiate_refund(
        port_: i64,
        that: usize,
        amount_msat: u64,
        expiry_secs: u32,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_initiate_refund_impl(
            port_,
            that,
            amount_msat,
            expiry_secs,
            quantity,
            payer_note,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_receive(
        port_: i64,
        that: usize,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: *mut u32,
        quantity: *mut u64,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_receive_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
            quantity,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_receive_variable_amount(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: *mut u32,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_receive_variable_amount_impl(
            port_,
            that,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_request_refund_payment(
        port_: i64,
        that: usize,
        refund: *mut wire_cst_refund,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_request_refund_payment_impl(port_, that, refund)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_send(
        port_: i64,
        that: usize,
        offer: *mut wire_cst_offer,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_send_impl(port_, that, offer, quantity, payer_note)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_send_using_amount(
        port_: i64,
        that: usize,
        offer: *mut wire_cst_offer,
        amount_msat: u64,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_send_using_amount_impl(
            port_,
            that,
            offer,
            amount_msat,
            quantity,
            payer_note,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_accept_underpaying_htlcs(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_accept_underpaying_htlcs_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_cltv_expiry_delta(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_cltv_expiry_delta_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_base_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_base_msat_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_max_dust_htlc_exposure(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_max_dust_htlc_exposure_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_accept_underpaying_htlcs(
        that: usize,
        accept_underpaying_htlcs: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_accept_underpaying_htlcs_impl(
            that,
            accept_underpaying_htlcs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_cltv_expiry_delta(
        that: usize,
        cltv_expiry_delta: u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_cltv_expiry_delta_impl(
            that,
            cltv_expiry_delta,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis(
        that: usize,
        force_close_avoidance_max_fee_satoshis: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis_impl(that, force_close_avoidance_max_fee_satoshis)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_base_msat(
        that: usize,
        forwarding_fee_base_msat: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_base_msat_impl(
            that,
            forwarding_fee_base_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths(
        that: usize,
        forwarding_fee_proportional_millionths: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths_impl(that, forwarding_fee_proportional_millionths)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_max_dust_htlc_exposure(
        that: usize,
        max_dust_htlc_exposure: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_max_dust_htlc_exposure_impl(
            that,
            max_dust_htlc_exposure,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_calculate_forwarding_fee(
        port_: i64,
        that: usize,
        amount_msat: u64,
    ) {
        wire__ldk_adapter__types__ChannelConfig_calculate_forwarding_fee_impl(
            port_,
            that,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_high_fee_routing(
        port_: i64,
    ) {
        wire__ldk_adapter__types__ChannelConfig_high_fee_routing_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_low_fee_routing(
        port_: i64,
    ) {
        wire__ldk_adapter__types__ChannelConfig_low_fee_routing_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_new(
        port_: i64,
        forwarding_fee_proportional_millionths: u32,
        forwarding_fee_base_msat: u32,
        cltv_expiry_delta: u16,
        max_dust_htlc_exposure: usize,
        force_close_avoidance_max_fee_satoshis: u64,
        accept_underpaying_htlcs: bool,
    ) {
        wire__ldk_adapter__types__ChannelConfig_new_impl(
            port_,
            forwarding_fee_proportional_millionths,
            forwarding_fee_base_msat,
            cltv_expiry_delta,
            max_dust_htlc_exposure,
            force_close_avoidance_max_fee_satoshis,
            accept_underpaying_htlcs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_value_sats(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_value_sats_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_cltv_expiry_delta(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_cltv_expiry_delta_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_config(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_config_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_required(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_required_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_node_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_node_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_force_close_spend_delay(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_force_close_spend_delay_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_funding_txo(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_funding_txo_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_capacity_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_capacity_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_channel_ready(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_channel_ready_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_outbound(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_outbound_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_usable(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_usable_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_outbound_capacity_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_outbound_capacity_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_unspendable_punishment_reserve(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_unspendable_punishment_reserve_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_user_channel_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_user_channel_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_id(
        that: usize,
        channel_id: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_id_impl(that, channel_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_value_sats(
        that: usize,
        channel_value_sats: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_value_sats_impl(
            that,
            channel_value_sats,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_cltv_expiry_delta(
        that: usize,
        cltv_expiry_delta: *mut u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_cltv_expiry_delta_impl(
            that,
            cltv_expiry_delta,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_config(
        that: usize,
        config: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_config_impl(that, config)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations(
        that: usize,
        confirmations: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_impl(
            that,
            confirmations,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_required(
        that: usize,
        confirmations_required: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_required_impl(
            that,
            confirmations_required,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta(
        that: usize,
        counterparty_forwarding_info_cltv_expiry_delta: *mut u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta_impl(that, counterparty_forwarding_info_cltv_expiry_delta)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat(
        that: usize,
        counterparty_forwarding_info_fee_base_msat: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat_impl(that, counterparty_forwarding_info_fee_base_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths(
        that: usize,
        counterparty_forwarding_info_fee_proportional_millionths: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths_impl(that, counterparty_forwarding_info_fee_proportional_millionths)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_node_id(
        that: usize,
        counterparty_node_id: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_node_id_impl(
            that,
            counterparty_node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat(
        that: usize,
        counterparty_outbound_htlc_maximum_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat_impl(that, counterparty_outbound_htlc_maximum_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat(
        that: usize,
        counterparty_outbound_htlc_minimum_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat_impl(that, counterparty_outbound_htlc_minimum_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve(
        that: usize,
        counterparty_unspendable_punishment_reserve: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve_impl(that, counterparty_unspendable_punishment_reserve)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight(
        that: usize,
        feerate_sat_per_1000_weight: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight_impl(
            that,
            feerate_sat_per_1000_weight,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_force_close_spend_delay(
        that: usize,
        force_close_spend_delay: *mut u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_force_close_spend_delay_impl(
            that,
            force_close_spend_delay,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_funding_txo(
        that: usize,
        funding_txo: *mut wire_cst_out_point,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_funding_txo_impl(
            that,
            funding_txo,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_capacity_msat(
        that: usize,
        inbound_capacity_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_capacity_msat_impl(
            that,
            inbound_capacity_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat(
        that: usize,
        inbound_htlc_maximum_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat_impl(
            that,
            inbound_htlc_maximum_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat(
        that: usize,
        inbound_htlc_minimum_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat_impl(
            that,
            inbound_htlc_minimum_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_channel_ready(
        that: usize,
        is_channel_ready: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_channel_ready_impl(
            that,
            is_channel_ready,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_outbound(
        that: usize,
        is_outbound: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_outbound_impl(
            that,
            is_outbound,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_usable(
        that: usize,
        is_usable: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_usable_impl(that, is_usable)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat(
        that: usize,
        next_outbound_htlc_limit_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat_impl(that, next_outbound_htlc_limit_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat(
        that: usize,
        next_outbound_htlc_minimum_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat_impl(that, next_outbound_htlc_minimum_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_outbound_capacity_msat(
        that: usize,
        outbound_capacity_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_outbound_capacity_msat_impl(
            that,
            outbound_capacity_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_unspendable_punishment_reserve(
        that: usize,
        unspendable_punishment_reserve: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_unspendable_punishment_reserve_impl(that, unspendable_punishment_reserve)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_user_channel_id(
        that: usize,
        user_channel_id: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_user_channel_id_impl(
            that,
            user_channel_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_balance_ratio_percent(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__ChannelDetails_balance_ratio_percent_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_can_receive(
        port_: i64,
        that: usize,
        amount_msat: u64,
    ) {
        wire__ldk_adapter__types__ChannelDetails_can_receive_impl(port_, that, amount_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_can_send(
        port_: i64,
        that: usize,
        amount_msat: u64,
    ) {
        wire__ldk_adapter__types__ChannelDetails_can_send_impl(port_, that, amount_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_capacity_sats(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__ChannelDetails_capacity_sats_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_new(
        port_: i64,
        channel_id: usize,
        counterparty_node_id: usize,
        funding_txo: *mut wire_cst_out_point,
        channel_value_sats: u64,
        unspendable_punishment_reserve: *mut u64,
        user_channel_id: usize,
        feerate_sat_per_1000_weight: u32,
        outbound_capacity_msat: u64,
        inbound_capacity_msat: u64,
        is_outbound: bool,
        is_channel_ready: bool,
        is_usable: bool,
        config: usize,
    ) {
        wire__ldk_adapter__types__ChannelDetails_new_impl(
            port_,
            channel_id,
            counterparty_node_id,
            funding_txo,
            channel_value_sats,
            unspendable_punishment_reserve,
            user_channel_id,
            feerate_sat_per_1000_weight,
            outbound_capacity_msat,
            inbound_capacity_msat,
            is_outbound,
            is_channel_ready,
            is_usable,
            config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_total_liquidity_msat(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__ChannelDetails_total_liquidity_msat_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelId_as_bytes(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__ChannelId_as_bytes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelId_from_bytes(
        port_: i64,
        bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__types__ChannelId_from_bytes_impl(port_, bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelId_new(
        data: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelId_new_impl(data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_build(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_build_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_build_with_fs_store(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_build_with_fs_store_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store(
        port_: i64,
        that: usize,
        vss_url: *mut wire_cst_list_prim_u_8_strict,
        store_id: *mut wire_cst_list_prim_u_8_strict,
        lnurl_auth_server_url: *mut wire_cst_list_prim_u_8_strict,
        fixed_headers: *mut wire_cst_list_record_string_string,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store_impl(
            port_,
            that,
            vss_url,
            store_id,
            lnurl_auth_server_url,
            fixed_headers,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store_and_fixed_headers(
        port_: i64,
        that: usize,
        vss_url: *mut wire_cst_list_prim_u_8_strict,
        store_id: *mut wire_cst_list_prim_u_8_strict,
        fixed_headers: *mut wire_cst_list_record_string_string,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_build_with_vss_store_and_fixed_headers_impl(
            port_,
            that,
            vss_url,
            store_id,
            fixed_headers,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_create_builder(
        port_: i64,
        config: *mut wire_cst_config,
        chain_data_source_config: *mut wire_cst_chain_data_source_config,
        entropy_source_config: *mut wire_cst_entropy_source_config,
        gossip_source_config: *mut wire_cst_gossip_source_config,
        liquidity_source_config: *mut wire_cst_liquidity_source_config,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_create_builder_impl(
            port_,
            config,
            chain_data_source_config,
            entropy_source_config,
            gossip_source_config,
            liquidity_source_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_set_entropy_seed_bytes(
        port_: i64,
        that: usize,
        seed_bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_set_entropy_seed_bytes_impl(port_, that, seed_bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_set_filesystem_logger(
        port_: i64,
        that: usize,
        log_file_path: *mut wire_cst_list_prim_u_8_strict,
        max_log_level: *mut i32,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_set_filesystem_logger_impl(
            port_,
            that,
            log_file_path,
            max_log_level,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__LdkBuilder_set_log_facade_logger(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__builder__LdkBuilder_set_log_facade_logger_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__MaxDustHtlcExposure_conservative(
        port_: i64,
    ) {
        wire__ldk_adapter__types__MaxDustHtlcExposure_conservative_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__MaxDustHtlcExposure_default_fee_rate(
        port_: i64,
    ) {
        wire__ldk_adapter__types__MaxDustHtlcExposure_default_fee_rate_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__MaxDustHtlcExposure_new_fee_rate_multiplier(
        port_: i64,
        multiplier: u64,
    ) {
        wire__ldk_adapter__types__MaxDustHtlcExposure_new_fee_rate_multiplier_impl(
            port_, multiplier,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__MaxDustHtlcExposure_new_fixed_limit(
        port_: i64,
        limit_msat: u64,
    ) {
        wire__ldk_adapter__types__MaxDustHtlcExposure_new_fixed_limit_impl(port_, limit_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_channel(
        port_: i64,
        that: usize,
        short_channel_id: u64,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_channel_impl(port_, that, short_channel_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_list_channels(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_list_channels_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_list_nodes(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_list_nodes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_node(
        port_: i64,
        that: usize,
        node_id: *mut wire_cst_node_id,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_node_impl(port_, that, node_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_bolt11_payment(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_bolt11_payment_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_bolt12_payment(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_bolt12_payment_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_close_channel(
        port_: i64,
        that: usize,
        user_channel_id: usize,
        counterparty_node_id: usize,
    ) {
        wire__ldk_adapter__node__Node_close_channel_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_config(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_config_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_connect(
        port_: i64,
        that: usize,
        node_id: usize,
        address: usize,
        persist: bool,
    ) {
        wire__ldk_adapter__node__Node_connect_impl(port_, that, node_id, address, persist)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_disconnect(
        port_: i64,
        that: usize,
        counterparty_node_id: usize,
    ) {
        wire__ldk_adapter__node__Node_disconnect_impl(port_, that, counterparty_node_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_event_handled(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_event_handled_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_export_pathfinding_scores(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_export_pathfinding_scores_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_force_close_channel(
        port_: i64,
        that: usize,
        user_channel_id: usize,
        counterparty_node_id: usize,
    ) {
        wire__ldk_adapter__node__Node_force_close_channel_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_balances(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_balances_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_channels(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_channels_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_payments(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_payments_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_payments_with_filter(
        port_: i64,
        that: usize,
        payment_direction: i32,
    ) {
        wire__ldk_adapter__node__Node_list_payments_with_filter_impl(port_, that, payment_direction)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_peers(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_peers_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_listening_addresses(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_listening_addresses_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_network_graph(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_network_graph_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_next_event(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_next_event_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_next_event_async(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_next_event_async_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_node_id(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_node_id_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_on_chain_payment(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_on_chain_payment_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_open_announced_channel(
        port_: i64,
        that: usize,
        socket_address: usize,
        node_id: usize,
        channel_amount_sats: u64,
        push_to_counterparty_msat: *mut u64,
        channel_config: *mut usize,
    ) {
        wire__ldk_adapter__node__Node_open_announced_channel_impl(
            port_,
            that,
            socket_address,
            node_id,
            channel_amount_sats,
            push_to_counterparty_msat,
            channel_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_open_channel(
        port_: i64,
        that: usize,
        socket_address: usize,
        node_id: usize,
        channel_amount_sats: u64,
        push_to_counterparty_msat: *mut u64,
        channel_config: *mut usize,
    ) {
        wire__ldk_adapter__node__Node_open_channel_impl(
            port_,
            that,
            socket_address,
            node_id,
            channel_amount_sats,
            push_to_counterparty_msat,
            channel_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_payment(
        port_: i64,
        that: usize,
        payment_id: usize,
    ) {
        wire__ldk_adapter__node__Node_payment_impl(port_, that, payment_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_remove_payment(
        port_: i64,
        that: usize,
        payment_id: usize,
    ) {
        wire__ldk_adapter__node__Node_remove_payment_impl(port_, that, payment_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_sign_message(
        port_: i64,
        that: usize,
        msg: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__node__Node_sign_message_impl(port_, that, msg)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_spontaneous_payment(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_spontaneous_payment_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_start(port_: i64, that: usize) {
        wire__ldk_adapter__node__Node_start_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_status(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_status_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_stop(port_: i64, that: usize) {
        wire__ldk_adapter__node__Node_stop_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_sync_wallets(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_sync_wallets_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_unified_qr_payment(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_unified_qr_payment_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_update_channel_config(
        port_: i64,
        that: usize,
        user_channel_id: usize,
        counterparty_node_id: usize,
        channel_config: usize,
    ) {
        wire__ldk_adapter__node__Node_update_channel_config_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
            channel_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_verify_signature(
        port_: i64,
        that: usize,
        msg: *mut wire_cst_list_prim_u_8_loose,
        sig: *mut wire_cst_list_prim_u_8_strict,
        public_key: usize,
    ) {
        wire__ldk_adapter__node__Node_verify_signature_impl(port_, that, msg, sig, public_key)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_wait_next_event(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_wait_next_event_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__on_chain__OnChainPayment_new_address(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__on_chain__OnChainPayment_new_address_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__on_chain__OnChainPayment_send_all_to_address(
        port_: i64,
        that: usize,
        address: usize,
        retain_reserves: bool,
        fee_rate_sat_per_kwu: *mut u64,
    ) {
        wire__ldk_adapter__on_chain__OnChainPayment_send_all_to_address_impl(
            port_,
            that,
            address,
            retain_reserves,
            fee_rate_sat_per_kwu,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__on_chain__OnChainPayment_send_to_address(
        port_: i64,
        that: usize,
        address: usize,
        amount_sats: u64,
        fee_rate_sat_per_kwu: *mut u64,
    ) {
        wire__ldk_adapter__on_chain__OnChainPayment_send_to_address_impl(
            port_,
            that,
            address,
            amount_sats,
            fee_rate_sat_per_kwu,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_amount_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_amount_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_direction(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_direction_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_kind(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_kind_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_latest_update_timestamp(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_latest_update_timestamp_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_status(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_status_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_amount_msat(
        that: usize,
        amount_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_amount_msat_impl(
            that,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_direction(
        that: usize,
        direction: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_direction_impl(that, direction)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_id(
        that: usize,
        id: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_id_impl(that, id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_kind(
        that: usize,
        kind: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_kind_impl(that, kind)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_latest_update_timestamp(
        that: usize,
        latest_update_timestamp: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_latest_update_timestamp_impl(
            that,
            latest_update_timestamp,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_status(
        that: usize,
        status: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_status_impl(that, status)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_is_failed(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__PaymentDetails_is_failed_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_is_pending(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__PaymentDetails_is_pending_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_is_succeeded(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__PaymentDetails_is_succeeded_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_new(
        port_: i64,
        id: usize,
        kind: usize,
        amount_msat: *mut u64,
        direction: i32,
        status: i32,
        latest_update_timestamp: u64,
    ) {
        wire__ldk_adapter__types__PaymentDetails_new_impl(
            port_,
            id,
            kind,
            amount_msat,
            direction,
            status,
            latest_update_timestamp,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_new_inbound_pending(
        port_: i64,
        id: usize,
        kind: usize,
        amount_msat: *mut u64,
    ) {
        wire__ldk_adapter__types__PaymentDetails_new_inbound_pending_impl(
            port_,
            id,
            kind,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_new_outbound_pending(
        port_: i64,
        id: usize,
        kind: usize,
        amount_msat: *mut u64,
    ) {
        wire__ldk_adapter__types__PaymentDetails_new_outbound_pending_impl(
            port_,
            id,
            kind,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PaymentHash_new(
        data: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PaymentHash_new_impl(data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PaymentHash_to_vec(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PaymentHash_to_vec_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PaymentId_new(
        data: *mut wire_cst_list_prim_u_8_loose,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PaymentId_new_impl(data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PaymentId_to_vec(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PaymentId_to_vec_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PaymentPreimage_new(
        data: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PaymentPreimage_new_impl(data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PaymentPreimage_to_vec(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PaymentPreimage_to_vec_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_get_address(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_get_address_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_get_is_connected(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_get_is_connected_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_get_node_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_get_node_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_set_address(
        that: usize,
        address: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_set_address_impl(that, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_set_is_connected(
        that: usize,
        is_connected: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_set_is_connected_impl(
            that,
            is_connected,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_set_node_id(
        that: usize,
        node_id: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_set_node_id_impl(that, node_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_is_offline(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__PeerDetails_is_offline_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_is_online(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__PeerDetails_is_online_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_new(
        port_: i64,
        node_id: usize,
        address: usize,
        is_connected: bool,
    ) {
        wire__ldk_adapter__types__PeerDetails_new_impl(port_, node_id, address, is_connected)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_new_connected(
        port_: i64,
        node_id: usize,
        address: usize,
    ) {
        wire__ldk_adapter__types__PeerDetails_new_connected_impl(port_, node_id, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_new_disconnected(
        port_: i64,
        node_id: usize,
        address: usize,
    ) {
        wire__ldk_adapter__types__PeerDetails_new_disconnected_impl(port_, node_id, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PublicKey_new(
        hex: *mut wire_cst_list_prim_u_8_strict,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PublicKey_new_impl(hex)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__PublicKey_to_string(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__PublicKey_to_string_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__SocketAddress_address_type(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__SocketAddress_address_type_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__SocketAddress_to_hostname(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__SocketAddress_to_hostname_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__SocketAddress_to_onion_v2(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__SocketAddress_to_onion_v2_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__SocketAddress_to_onion_v3(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__SocketAddress_to_onion_v3_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__SocketAddress_to_tcp_ip_v4(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__SocketAddress_to_tcp_ip_v4_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__SocketAddress_to_tcp_ip_v6(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__SocketAddress_to_tcp_ip_v6_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__spontaneous__SpontaneousPayment_send_probes_unsafe(
        port_: i64,
        that: usize,
        amount_msat: u64,
        node_id: usize,
    ) {
        wire__ldk_adapter__spontaneous__SpontaneousPayment_send_probes_unsafe_impl(
            port_,
            that,
            amount_msat,
            node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__spontaneous__SpontaneousPayment_send_unsafe(
        port_: i64,
        that: usize,
        amount_msat: u64,
        node_id: usize,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__ldk_adapter__spontaneous__SpontaneousPayment_send_unsafe_impl(
            port_,
            that,
            amount_msat,
            node_id,
            sending_parameters,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__spontaneous__SpontaneousPayment_send_with_custom_tlvs_unsafe(
        port_: i64,
        that: usize,
        amount_msat: u64,
        node_id: usize,
        sending_parameters: *mut wire_cst_sending_parameters,
        custom_tlvs: *mut wire_cst_list_custom_tlv_record,
    ) {
        wire__ldk_adapter__spontaneous__SpontaneousPayment_send_with_custom_tlvs_unsafe_impl(
            port_,
            that,
            amount_msat,
            node_id,
            sending_parameters,
            custom_tlvs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__TaprootSpendInfo_auto_accessor_get_inner(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__TaprootSpendInfo_auto_accessor_get_inner_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__TaprootSpendInfo_auto_accessor_set_inner(
        that: usize,
        inner: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__TaprootSpendInfo_auto_accessor_set_inner_impl(that, inner)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_auto_accessor_get_inner(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__Transaction_auto_accessor_get_inner_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_auto_accessor_set_inner(
        that: usize,
        inner: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__Transaction_auto_accessor_set_inner_impl(that, inner)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_compute_txid(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_compute_txid_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_compute_wtxid(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_compute_wtxid_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_input(port_: i64, that: usize) {
        wire__shared__Transaction_input_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_is_coinbase(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_is_coinbase_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_is_explicitly_rbf(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_is_explicitly_rbf_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_is_lock_time_enabled(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_is_lock_time_enabled_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_lock_time(port_: i64, that: usize) {
        wire__shared__Transaction_lock_time_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_new(
        port_: i64,
        transaction_bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__shared__Transaction_new_impl(port_, transaction_bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_output(port_: i64, that: usize) {
        wire__shared__Transaction_output_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_total_size(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_total_size_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_version(port_: i64, that: usize) {
        wire__shared__Transaction_version_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_vsize(port_: i64, that: usize) {
        wire__shared__Transaction_vsize_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_weight(port_: i64, that: usize) {
        wire__shared__Transaction_weight_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__unified_qr__UnifiedQrPayment_receive(
        port_: i64,
        that: usize,
        amount_sats: u64,
        message: *mut wire_cst_list_prim_u_8_strict,
        expiry_sec: u32,
    ) {
        wire__ldk_adapter__unified_qr__UnifiedQrPayment_receive_impl(
            port_,
            that,
            amount_sats,
            message,
            expiry_sec,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__unified_qr__UnifiedQrPayment_send(
        port_: i64,
        that: usize,
        uri_str: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__unified_qr__UnifiedQrPayment_send_impl(port_, that, uri_str)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_as_bytes(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__UserChannelId_as_bytes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_as_vec(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__types__UserChannelId_as_vec_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_from_string(
        port_: i64,
        s: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__types__UserChannelId_from_string_impl(port_, s)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_from_u64(
        port_: i64,
        id: u64,
    ) {
        wire__ldk_adapter__types__UserChannelId_from_u64_impl(port_, id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__UserChannelId_new(
        data: *mut wire_cst_list_prim_u_8_loose,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__UserChannelId_new_impl(data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__address_hostname_as_socket(
        that: *mut wire_cst_address_hostname,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__address_hostname_as_socket_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__address_onion_v_2_as_socket(
        that: *mut wire_cst_address_onion_v_2,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__address_onion_v_2_as_socket_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__address_onion_v_3_as_socket(
        that: *mut wire_cst_address_onion_v_3,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__address_onion_v_3_as_socket_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__address_tcp_ip_v_4_as_socket(
        that: *mut wire_cst_address_tcp_ip_v_4,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__address_tcp_ip_v_4_as_socket_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__address_tcp_ip_v_6_as_socket(
        that: *mut wire_cst_address_tcp_ip_v_6,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__crate__api__extensions__address_tcp_ip_v_6_as_socket_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__anchor_channels_config_conservative(
        port_: i64,
    ) {
        wire__ldk_adapter__types__anchor_channels_config_conservative_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__anchor_channels_config_default(
        port_: i64,
    ) {
        wire__ldk_adapter__types__anchor_channels_config_default_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__anchor_channels_config_is_peer_trusted(
        port_: i64,
        that: *mut wire_cst_anchor_channels_config,
        peer: usize,
    ) {
        wire__ldk_adapter__types__anchor_channels_config_is_peer_trusted_impl(port_, that, peer)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__anchor_channels_config_low_reserve(
        port_: i64,
    ) {
        wire__ldk_adapter__types__anchor_channels_config_low_reserve_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__anchor_channels_config_trusted_peers_count(
        port_: i64,
        that: *mut wire_cst_anchor_channels_config,
    ) {
        wire__ldk_adapter__types__anchor_channels_config_trusted_peers_count_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__anchor_channels_config_with_trusted_peers(
        port_: i64,
        trusted_peers: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey,
    ) {
        wire__ldk_adapter__types__anchor_channels_config_with_trusted_peers_impl(
            port_,
            trusted_peers,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__crate__api__extensions__config_default(port_: i64) {
        wire__crate__api__extensions__config_default_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__custom_tlv_record_from_string(
        port_: i64,
        type_num: u64,
        value: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__types__custom_tlv_record_from_string_impl(port_, type_num, value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__custom_tlv_record_from_u64(
        port_: i64,
        type_num: u64,
        value: u64,
    ) {
        wire__ldk_adapter__types__custom_tlv_record_from_u64_impl(port_, type_num, value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__custom_tlv_record_new(
        port_: i64,
        type_num: u64,
        value: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__types__custom_tlv_record_new_impl(port_, type_num, value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__custom_tlv_record_value_as_string(
        port_: i64,
        that: *mut wire_cst_custom_tlv_record,
    ) {
        wire__ldk_adapter__types__custom_tlv_record_value_as_string_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_debug(
        port_: i64,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_debug_impl(port_, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_error(
        port_: i64,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_error_impl(port_, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_formatted(
        port_: i64,
        that: *mut wire_cst_ffi_log_record,
    ) {
        wire__ldk_adapter__types__ffi_log_record_formatted_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_info(
        port_: i64,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_info_impl(port_, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_is_error(
        port_: i64,
        that: *mut wire_cst_ffi_log_record,
    ) {
        wire__ldk_adapter__types__ffi_log_record_is_error_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_is_warn(
        port_: i64,
        that: *mut wire_cst_ffi_log_record,
    ) {
        wire__ldk_adapter__types__ffi_log_record_is_warn_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_new(
        port_: i64,
        level: i32,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_new_impl(port_, level, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_trace(
        port_: i64,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_trace_impl(port_, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ffi_log_record_warn(
        port_: i64,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    ) {
        wire__ldk_adapter__types__ffi_log_record_warn_impl(port_, args, module_path, line)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__lsp_fee_limits_conservative(
        port_: i64,
    ) {
        wire__ldk_adapter__types__lsp_fee_limits_conservative_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__lsp_fee_limits_new(
        port_: i64,
        max_total_opening_fee_msat: *mut u64,
        max_proportional_opening_fee_ppm_msat: *mut u64,
    ) {
        wire__ldk_adapter__types__lsp_fee_limits_new_impl(
            port_,
            max_total_opening_fee_msat,
            max_proportional_opening_fee_ppm_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__lsp_fee_limits_permissive(
        port_: i64,
    ) {
        wire__ldk_adapter__types__lsp_fee_limits_permissive_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__lsp_fee_limits_unlimited(
        port_: i64,
    ) {
        wire__ldk_adapter__types__lsp_fee_limits_unlimited_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_as_string(
        port_: i64,
        that: *mut wire_cst_mnemonic,
    ) {
        wire__shared__mnemonic_as_string_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_from_entropy(
        port_: i64,
        entropy: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__shared__mnemonic_from_entropy_impl(port_, entropy)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_from_seed_phrase(
        port_: i64,
        seed_phrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__shared__mnemonic_from_seed_phrase_impl(port_, seed_phrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_generate(port_: i64) {
        wire__shared__mnemonic_generate_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_to_seed(
        port_: i64,
        that: *mut wire_cst_mnemonic,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__shared__mnemonic_to_seed_impl(port_, that, passphrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__offer_id_as_bytes(
        port_: i64,
        that: *mut wire_cst_offer_id,
    ) {
        wire__ldk_adapter__types__offer_id_as_bytes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__offer_id_from_bytes(
        port_: i64,
        bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__types__offer_id_from_bytes_impl(port_, bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__offer_id_new(
        port_: i64,
        data: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__types__offer_id_new_impl(port_, data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_secret_as_bytes(
        port_: i64,
        that: *mut wire_cst_payment_secret,
    ) {
        wire__ldk_adapter__types__payment_secret_as_bytes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_secret_from_bytes(
        port_: i64,
        bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__types__payment_secret_from_bytes_impl(port_, bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__payment_secret_new(
        port_: i64,
        data: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__types__payment_secret_new_impl(port_, data)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__psbt_extract_tx(
        port_: i64,
        that: *mut wire_cst_psbt,
    ) {
        wire__shared__psbt_extract_tx_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__psbt_fee(port_: i64, that: *mut wire_cst_psbt) {
        wire__shared__psbt_fee_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__psbt_from_base64(
        port_: i64,
        base64: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__shared__psbt_from_base64_impl(port_, base64)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressData(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressData(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinTransactionInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
            >::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinTransactionInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
            >::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt11Invoice(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt11Invoice(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Invoice>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt11Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt11Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt12Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt12Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelId>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLdkBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLdkBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LdkBuilder>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaxDustHTLCExposure(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaxDustHTLCExposure(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNetworkGraph(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNetworkGraph(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNode(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNode(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnChainPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnChainPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentHash(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentHash>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentHash(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentHash>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentId>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentId>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentKind(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentKind(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentPreimage(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentPreimage>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentPreimage(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentPreimage>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PublicKey>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPaymentResult(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPaymentResult(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSpontaneousPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSpontaneousPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfo(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfo(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfoInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfoInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnifiedQrPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnifiedQrPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserChannelId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUserChannelId(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UserChannelId>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelConfig(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelId(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_address_hostname(
    ) -> *mut wire_cst_address_hostname {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_address_hostname::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_address_onion_v_2(
    ) -> *mut wire_cst_address_onion_v_2 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_address_onion_v_2::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_address_onion_v_3(
    ) -> *mut wire_cst_address_onion_v_3 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_address_onion_v_3::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_address_tcp_ip_v_4(
    ) -> *mut wire_cst_address_tcp_ip_v_4 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_address_tcp_ip_v_4::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_address_tcp_ip_v_6(
    ) -> *mut wire_cst_address_tcp_ip_v_6 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_address_tcp_ip_v_6::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_anchor_channels_config(
    ) -> *mut wire_cst_anchor_channels_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_anchor_channels_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_background_sync_config(
    ) -> *mut wire_cst_background_sync_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_background_sync_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_chain_data_source_config(
    ) -> *mut wire_cst_chain_data_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_chain_data_source_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_channel_info(
    ) -> *mut wire_cst_channel_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_channel_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_channel_update_info(
    ) -> *mut wire_cst_channel_update_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_channel_update_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_config() -> *mut wire_cst_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_config::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_custom_tlv_record(
    ) -> *mut wire_cst_custom_tlv_record {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_custom_tlv_record::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_electrum_sync_config(
    ) -> *mut wire_cst_electrum_sync_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_electrum_sync_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_entropy_source_config(
    ) -> *mut wire_cst_entropy_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_entropy_source_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_esplora_sync_config(
    ) -> *mut wire_cst_esplora_sync_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_esplora_sync_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_log_record(
    ) -> *mut wire_cst_ffi_log_record {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_log_record::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_gossip_source_config(
    ) -> *mut wire_cst_gossip_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_gossip_source_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_liquidity_source_config(
    ) -> *mut wire_cst_liquidity_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_liquidity_source_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_log_level(value: i32) -> *mut i32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_mnemonic() -> *mut wire_cst_mnemonic {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_mnemonic::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_alias() -> *mut wire_cst_node_alias {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_node_alias::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_announcement_info(
    ) -> *mut wire_cst_node_announcement_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_node_announcement_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_id() -> *mut wire_cst_node_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_node_id::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_info() -> *mut wire_cst_node_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_node_info::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_offer() -> *mut wire_cst_offer {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_offer::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_offer_id() -> *mut wire_cst_offer_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_offer_id::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_out_point() -> *mut wire_cst_out_point {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_out_point::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_secret(
    ) -> *mut wire_cst_payment_secret {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_secret::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_psbt() -> *mut wire_cst_psbt {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_psbt::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_refund() -> *mut wire_cst_refund {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_refund::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_script_buf() -> *mut wire_cst_script_buf {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_script_buf::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_sending_parameters(
    ) -> *mut wire_cst_sending_parameters {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_sending_parameters::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_16(value: u16) -> *mut u16 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_8(value: u8) -> *mut u8 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_String(len: i32) -> *mut wire_cst_list_String {
        let wrap = wire_cst_list_String {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_custom_tlv_record(
        len: i32,
    ) -> *mut wire_cst_list_custom_tlv_record {
        let wrap = wire_cst_list_custom_tlv_record {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_custom_tlv_record>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_list_prim_u_8_strict {
        let wrap = wire_cst_list_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_node_id(len: i32) -> *mut wire_cst_list_node_id {
        let wrap = wire_cst_list_node_id {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_node_id>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_64_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_64_strict {
        let ans = wire_cst_list_prim_u_64_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_8_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_loose {
        let ans = wire_cst_list_prim_u_8_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_record_string_string(
        len: i32,
    ) -> *mut wire_cst_list_record_string_string {
        let wrap = wire_cst_list_record_string_string {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_string_string>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_tx_in(len: i32) -> *mut wire_cst_list_tx_in {
        let wrap = wire_cst_list_tx_in {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx_in>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_tx_out(len: i32) -> *mut wire_cst_list_tx_out {
        let wrap = wire_cst_list_tx_out {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx_out>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_hostname {
        addr: *mut wire_cst_list_prim_u_8_strict,
        port: u16,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_onion_v_2 {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_onion_v_3 {
        ed25519_pubkey: *mut wire_cst_list_prim_u_8_strict,
        checksum: u16,
        version: u8,
        port: u16,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_tcp_ip_v_4 {
        addr: *mut wire_cst_list_prim_u_8_strict,
        port: u16,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_address_tcp_ip_v_6 {
        addr: *mut wire_cst_list_prim_u_8_strict,
        port: u16,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_anchor_channels_config { trusted_peers_no_reserve: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey,
per_channel_reserve_sats: u64 }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_background_sync_config {
        onchain_wallet_sync_interval_secs: u64,
        lightning_wallet_sync_interval_secs: u64,
        fee_rate_cache_update_interval_secs: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_balance_details { total_onchain_balance_sats: u64,
spendable_onchain_balance_sats: u64,
total_lightning_balance_sats: u64,
lightning_balances: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance,
pending_balances_from_channel_closures: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_best_block {
        block_hash: *mut wire_cst_list_prim_u_8_strict,
        height: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bolt_12_invoice {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_chain_data_source_config {
        tag: i32,
        kind: ChainDataSourceConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union ChainDataSourceConfigKind {
        Esplora: wire_cst_ChainDataSourceConfig_Esplora,
        Electrum: wire_cst_ChainDataSourceConfig_Electrum,
        BitcoindRpc: wire_cst_ChainDataSourceConfig_BitcoindRpc,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ChainDataSourceConfig_Esplora {
        server_url: *mut wire_cst_list_prim_u_8_strict,
        sync_config: *mut wire_cst_esplora_sync_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ChainDataSourceConfig_Electrum {
        server_url: *mut wire_cst_list_prim_u_8_strict,
        sync_config: *mut wire_cst_electrum_sync_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ChainDataSourceConfig_BitcoindRpc {
        rpc_host: *mut wire_cst_list_prim_u_8_strict,
        rpc_port: u16,
        rpc_user: *mut wire_cst_list_prim_u_8_strict,
        rpc_password: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_info {
        node_one: wire_cst_node_id,
        one_to_two: *mut wire_cst_channel_update_info,
        node_two: wire_cst_node_id,
        two_to_one: *mut wire_cst_channel_update_info,
        capacity_sats: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_update_info {
        last_update: u32,
        enabled: bool,
        cltv_expiry_delta: u16,
        htlc_minimum_msat: u64,
        htlc_maximum_msat: u64,
        fees: wire_cst_routing_fees,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_config { storage_dir_path: *mut wire_cst_list_prim_u_8_strict,
network: i32,
listening_addresses: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress,
announcement_addresses: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress,
node_alias: *mut wire_cst_node_alias,
trusted_peers_0conf: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey,
probing_liquidity_limit_multiplier: u64,
anchor_channels_config: *mut wire_cst_anchor_channels_config,
sending_parameters: *mut wire_cst_sending_parameters }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_custom_tlv_record {
        type_num: u64,
        value: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_electrum_sync_config {
        background_sync_config: *mut wire_cst_background_sync_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_entropy_source_config {
        tag: i32,
        kind: EntropySourceConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union EntropySourceConfigKind {
        SeedFile: wire_cst_EntropySourceConfig_SeedFile,
        SeedBytes: wire_cst_EntropySourceConfig_SeedBytes,
        Bip39Mnemonic: wire_cst_EntropySourceConfig_Bip39Mnemonic,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EntropySourceConfig_SeedFile {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EntropySourceConfig_SeedBytes {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_EntropySourceConfig_Bip39Mnemonic {
        field0: *mut wire_cst_mnemonic,
        field1: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_esplora_sync_config {
        background_sync_config: *mut wire_cst_background_sync_config,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_log_record {
        level: i32,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_gossip_source_config {
        tag: i32,
        kind: GossipSourceConfigKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union GossipSourceConfigKind {
        RapidGossipSync: wire_cst_GossipSourceConfig_RapidGossipSync,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_GossipSourceConfig_RapidGossipSync {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_liquidity_source_config { lsps2_service: wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_public_key_opt_string }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPublicKey
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_String {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_custom_tlv_record {
        ptr: *mut wire_cst_custom_tlv_record,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_list_prim_u_8_strict {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_node_id {
        ptr: *mut wire_cst_node_id,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_64_strict {
        ptr: *mut u64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_loose {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_string_string {
        ptr: *mut wire_cst_record_string_string,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx_in {
        ptr: *mut wire_cst_tx_in,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx_out {
        ptr: *mut wire_cst_tx_out,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_lsp_fee_limits {
        max_total_opening_fee_msat: *mut u64,
        max_proportional_opening_fee_ppm_msat: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_mnemonic {
        words: *mut wire_cst_list_String,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_alias {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_announcement_info { last_update: u32,
alias: *mut wire_cst_list_prim_u_8_strict,
addresses: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_id {
        compressed: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_info {
        channels: *mut wire_cst_list_prim_u_64_strict,
        announcement_info: *mut wire_cst_node_announcement_info,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_status {
        is_running: bool,
        is_listening: bool,
        current_best_block: wire_cst_best_block,
        latest_lightning_wallet_sync_timestamp: *mut u64,
        latest_onchain_wallet_sync_timestamp: *mut u64,
        latest_fee_rate_cache_update_timestamp: *mut u64,
        latest_rgs_snapshot_timestamp: *mut u64,
        latest_node_announcement_broadcast_timestamp: *mut u64,
        latest_channel_monitor_archival_height: *mut u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_offer {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_offer_id {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_out_point {
        txid: wire_cst_txid,
        vout: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_secret {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_psbt {
        inner: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_public_key_opt_string
    {
        field0: usize,
        field1: usize,
        field2: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_string_string {
        field0: *mut wire_cst_list_prim_u_8_strict,
        field1: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_refund {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_routing_fees {
        base_msat: u32,
        proportional_millionths: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_script_buf {
        inner: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sending_parameters {
        max_total_routing_fee_msat: *mut u64,
        max_total_cltv_expiry_delta: *mut u32,
        max_path_count: *mut u8,
        max_channel_saturation_power_of_half: *mut u8,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_in {
        previous_output: wire_cst_out_point,
        script_sig: wire_cst_script_buf,
        sequence: u32,
        witness: *mut wire_cst_list_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_out {
        value: u64,
        script_pubkey: wire_cst_script_buf,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_txid {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_w_txid {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
