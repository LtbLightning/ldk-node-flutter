// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};
use ldk_adapter::bolt11::*;
use ldk_adapter::bolt12::*;
use ldk_adapter::builder::*;
use ldk_adapter::graph::*;
use ldk_adapter::node::*;
use ldk_adapter::on_chain::*;
use ldk_adapter::spontaneous::*;
use ldk_adapter::types::*;
use ldk_adapter::unified_qr::*;
use shared::*;

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -1280831240;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__shared__BitcoinAddress_auto_accessor_get_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_auto_accessor_get_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inner.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__BitcoinAddress_auto_accessor_set_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
    inner: impl CstDecode<BitcoinAddressInner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_auto_accessor_set_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inner = inner.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inner = api_inner;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__BitcoinAddress_from_script_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    script: impl CstDecode<shared::ScriptBuf>,
    network: impl CstDecode<shared::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_from_script",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_script = script.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            shared::BitcoinAddress::from_script(api_script, api_network)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__BitcoinAddress_is_valid_for_network_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
    network: impl CstDecode<shared::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_is_valid_for_network",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        shared::BitcoinAddress::is_valid_for_network(&*api_that_guard, api_network),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    address: impl CstDecode<String>,
    network: impl CstDecode<shared::Network>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_address = address.cst_decode();
            let api_network = network.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::BitcoinAddress::new(api_address, api_network)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__BitcoinAddress_script_pubkey_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_script_pubkey",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(shared::BitcoinAddress::script_pubkey(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_to_address_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_to_address_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(shared::BitcoinAddress::to_address_data(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__BitcoinAddress_to_qr_uri_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "BitcoinAddress_to_qr_uri",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::BitcoinAddress::to_qr_uri(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_claim_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    payment_hash: impl CstDecode<shared::PaymentHash>,
    claimable_amount_msat: impl CstDecode<u64>,
    preimage: impl CstDecode<shared::PaymentPreimage>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_claim_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            let api_claimable_amount_msat = claimable_amount_msat.cst_decode();
            let api_preimage = preimage.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::claim_for_hash(
                            &*api_that_guard,
                            api_payment_hash,
                            api_claimable_amount_msat,
                            api_preimage,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_fail_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    payment_hash: impl CstDecode<shared::PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_fail_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::fail_for_hash(
                            &*api_that_guard,
                            api_payment_hash,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::receive(
                            &*api_that_guard,
                            api_amount_msat,
                            api_description,
                            api_expiry_secs,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    payment_hash: impl CstDecode<shared::PaymentHash>,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::receive_for_hash(
                            &*api_that_guard,
                            api_payment_hash,
                            api_amount_msat,
                            api_description,
                            api_expiry_secs,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::receive_variable_amount(
                                &*api_that_guard,
                                api_description,
                                api_expiry_secs,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_for_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    payment_hash: impl CstDecode<shared::PaymentHash>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_variable_amount_for_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_payment_hash = payment_hash.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::receive_variable_amount_for_hash(
                                &*api_that_guard,
                                api_description,
                                api_expiry_secs,
                                api_payment_hash,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_proportional_lsp_fee_limit_ppm_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "Bolt11Payment_receive_variable_amount_via_jit_channel", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_description = description.cst_decode();let api_expiry_secs = expiry_secs.cst_decode();let api_max_proportional_lsp_fee_limit_ppm_msat = max_proportional_lsp_fee_limit_ppm_msat.cst_decode(); move |context|  {
                    transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = ldk_adapter::bolt11::Bolt11Payment::receive_variable_amount_via_jit_channel(&*api_that_guard, api_description, api_expiry_secs, api_max_proportional_lsp_fee_limit_ppm_msat)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_receive_via_jit_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<u32>,
    max_total_lsp_fee_limit_msat: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_receive_via_jit_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_max_total_lsp_fee_limit_msat = max_total_lsp_fee_limit_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::receive_via_jit_channel(
                                &*api_that_guard,
                                api_amount_msat,
                                api_description,
                                api_expiry_secs,
                                api_max_total_lsp_fee_limit_msat,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<shared::Bolt11Invoice>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::send(
                            &*api_that_guard,
                            api_invoice,
                            api_sending_parameters,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<shared::Bolt11Invoice>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send_probes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::send_probes(
                            &*api_that_guard,
                            api_invoice,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<shared::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send_probes_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt11::Bolt11Payment::send_probes_using_amount(
                                &*api_that_guard,
                                api_invoice,
                                api_amount_msat,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt11__Bolt11Payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
    >,
    invoice: impl CstDecode<shared::Bolt11Invoice>,
    amount_msat: impl CstDecode<u64>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt11Payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt11::Bolt11Payment::send_using_amount(
                            &*api_that_guard,
                            api_invoice,
                            api_amount_msat,
                            api_sending_parameters,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_initiate_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    expiry_secs: impl CstDecode<u32>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_initiate_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::initiate_refund(
                            &*api_that_guard,
                            api_amount_msat,
                            api_expiry_secs,
                            api_quantity,
                            api_payer_note,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<Option<u32>>,
    quantity: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            let api_quantity = quantity.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::receive(
                            &*api_that_guard,
                            api_amount_msat,
                            api_description,
                            api_expiry_secs,
                            api_quantity,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_receive_variable_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    description: impl CstDecode<String>,
    expiry_secs: impl CstDecode<Option<u32>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_receive_variable_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_description = description.cst_decode();
            let api_expiry_secs = expiry_secs.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::bolt12::Bolt12Payment::receive_variable_amount(
                                &*api_that_guard,
                                api_description,
                                api_expiry_secs,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_request_refund_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    refund: impl CstDecode<shared::Refund>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_request_refund_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_refund = refund.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::request_refund_payment(
                            &*api_that_guard,
                            api_refund,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    offer: impl CstDecode<shared::Offer>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offer = offer.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::send(
                            &*api_that_guard,
                            api_offer,
                            api_quantity,
                            api_payer_note,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__bolt12__Bolt12Payment_send_using_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
    >,
    offer: impl CstDecode<shared::Offer>,
    amount_msat: impl CstDecode<u64>,
    quantity: impl CstDecode<Option<u64>>,
    payer_note: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Bolt12Payment_send_using_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offer = offer.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_quantity = quantity.cst_decode();
            let api_payer_note = payer_note.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::bolt12::Bolt12Payment::send_using_amount(
                            &*api_that_guard,
                            api_offer,
                            api_amount_msat,
                            api_quantity,
                            api_payer_note,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__Builder_build_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<Builder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Builder_build",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::Builder::build(api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__Builder_build_with_fs_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<Builder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Builder_build_with_fs_store",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            ldk_adapter::builder::Builder::build_with_fs_store(api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__Builder_build_with_vss_store_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>>,
    >,
    vss_url: impl CstDecode<String>,
    store_id: impl CstDecode<String>,
    lnurl_auth_server_url: impl CstDecode<String>,
    fixed_headers: impl CstDecode<std::collections::HashMap<String, String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Builder_build_with_vss_store",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_vss_url = vss_url.cst_decode();
            let api_store_id = store_id.cst_decode();
            let api_lnurl_auth_server_url = lnurl_auth_server_url.cst_decode();
            let api_fixed_headers = fixed_headers.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::builder::Builder::build_with_vss_store(
                            &*api_that_guard,
                            api_vss_url,
                            api_store_id,
                            api_lnurl_auth_server_url,
                            api_fixed_headers,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__Builder_build_with_vss_store_and_fixed_headers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>>,
    >,
    vss_url: impl CstDecode<String>,
    store_id: impl CstDecode<String>,
    fixed_headers: impl CstDecode<std::collections::HashMap<String, String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Builder_build_with_vss_store_and_fixed_headers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_vss_url = vss_url.cst_decode();
            let api_store_id = store_id.cst_decode();
            let api_fixed_headers = fixed_headers.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::builder::Builder::build_with_vss_store_and_fixed_headers(
                                &*api_that_guard,
                                api_vss_url,
                                api_store_id,
                                api_fixed_headers,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__Builder_create_builder_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    config: impl CstDecode<ldk_adapter::types::Config>,
    chain_data_source_config: impl CstDecode<Option<ChainDataSourceConfig>>,
    entropy_source_config: impl CstDecode<Option<EntropySourceConfig>>,
    gossip_source_config: impl CstDecode<Option<GossipSourceConfig>>,
    liquidity_source_config: impl CstDecode<Option<ldk_adapter::types::LiquiditySourceConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Builder_create_builder",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_config = config.cst_decode();
            let api_chain_data_source_config = chain_data_source_config.cst_decode();
            let api_entropy_source_config = entropy_source_config.cst_decode();
            let api_gossip_source_config = gossip_source_config.cst_decode();
            let api_liquidity_source_config = liquidity_source_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::Builder::create_builder(
                            api_config,
                            api_chain_data_source_config,
                            api_entropy_source_config,
                            api_gossip_source_config,
                            api_liquidity_source_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__Builder_set_entropy_seed_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<Builder>,
    seed_bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Builder_set_entropy_seed_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_seed_bytes = seed_bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::Builder::set_entropy_seed_bytes(
                            api_that,
                            api_seed_bytes,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__Builder_set_filesystem_logger_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<Builder>,
    log_file_path: impl CstDecode<Option<String>>,
    max_log_level: impl CstDecode<Option<ldk_adapter::types::LogLevel>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Builder_set_filesystem_logger",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_log_file_path = log_file_path.cst_decode();
            let api_max_log_level = max_log_level.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = ldk_adapter::builder::Builder::set_filesystem_logger(
                            api_that,
                            api_log_file_path,
                            api_max_log_level,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__builder__Builder_set_log_facade_logger_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<Builder>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Builder_set_log_facade_logger",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            ldk_adapter::builder::Builder::set_log_facade_logger(api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_accept_underpaying_htlcs_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_accept_underpaying_htlcs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.accept_underpaying_htlcs.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.cltv_expiry_delta.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .force_close_avoidance_max_fee_satoshis
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_forwarding_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.forwarding_fee_base_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .forwarding_fee_proportional_millionths
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_max_dust_htlc_exposure_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_get_max_dust_htlc_exposure",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.max_dust_htlc_exposure.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_accept_underpaying_htlcs_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    accept_underpaying_htlcs: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_accept_underpaying_htlcs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_accept_underpaying_htlcs = accept_underpaying_htlcs.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.accept_underpaying_htlcs = api_accept_underpaying_htlcs;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    cltv_expiry_delta: impl CstDecode<u16>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_cltv_expiry_delta = cltv_expiry_delta.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.cltv_expiry_delta = api_cltv_expiry_delta;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    force_close_avoidance_max_fee_satoshis: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_force_close_avoidance_max_fee_satoshis =
                force_close_avoidance_max_fee_satoshis.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.force_close_avoidance_max_fee_satoshis =
                            api_force_close_avoidance_max_fee_satoshis;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    forwarding_fee_base_msat: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_forwarding_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_forwarding_fee_base_msat = forwarding_fee_base_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.forwarding_fee_base_msat = api_forwarding_fee_base_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    forwarding_fee_proportional_millionths: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_forwarding_fee_proportional_millionths =
                forwarding_fee_proportional_millionths.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.forwarding_fee_proportional_millionths =
                            api_forwarding_fee_proportional_millionths;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_max_dust_htlc_exposure_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
    >,
    max_dust_htlc_exposure: impl CstDecode<MaxDustHTLCExposure>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelConfig_auto_accessor_set_max_dust_htlc_exposure",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_max_dust_htlc_exposure = max_dust_htlc_exposure.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.max_dust_htlc_exposure = api_max_dust_htlc_exposure;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.channel_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_value_sats_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_channel_value_sats",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.channel_value_sats.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.cltv_expiry_delta.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_config_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_config",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.config.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_confirmations",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.confirmations.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_required_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_confirmations_required",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.confirmations_required.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_forwarding_info_cltv_expiry_delta
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_forwarding_info_fee_base_msat
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { let api_that = that.cst_decode();
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok(api_that_guard.counterparty_forwarding_info_fee_proportional_millionths.clone())?;   Ok(output_ok)
                })()) })
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_counterparty_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.counterparty_node_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_outbound_htlc_maximum_msat
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_outbound_htlc_minimum_msat
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    api_that_guard
                        .counterparty_unspendable_punishment_reserve
                        .clone(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.feerate_sat_per_1000_weight.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_force_close_spend_delay_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_force_close_spend_delay",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.force_close_spend_delay.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_funding_txo_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_funding_txo",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.funding_txo.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_inbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inbound_capacity_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.inbound_htlc_maximum_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.inbound_htlc_minimum_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_channel_ready_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_is_channel_ready",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_channel_ready.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_outbound_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_is_outbound",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_outbound.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_usable_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_is_usable",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_usable.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.next_outbound_htlc_limit_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.next_outbound_htlc_minimum_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_outbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_outbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.outbound_capacity_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.unspendable_punishment_reserve.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_user_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_get_user_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.user_channel_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    channel_id: impl CstDecode<ldk_adapter::types::ChannelId>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_channel_id = channel_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.channel_id = api_channel_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_value_sats_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    channel_value_sats: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_channel_value_sats",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_channel_value_sats = channel_value_sats.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.channel_value_sats = api_channel_value_sats;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    cltv_expiry_delta: impl CstDecode<Option<u16>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_cltv_expiry_delta = cltv_expiry_delta.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.cltv_expiry_delta = api_cltv_expiry_delta;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_config_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    config: impl CstDecode<ChannelConfig>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_config",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_config = config.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.config = api_config;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    confirmations: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_confirmations",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_confirmations = confirmations.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.confirmations = api_confirmations;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_required_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    confirmations_required: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_confirmations_required",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_confirmations_required = confirmations_required.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.confirmations_required = api_confirmations_required;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_forwarding_info_cltv_expiry_delta: impl CstDecode<Option<u16>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_forwarding_info_cltv_expiry_delta =
                counterparty_forwarding_info_cltv_expiry_delta.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_forwarding_info_cltv_expiry_delta =
                            api_counterparty_forwarding_info_cltv_expiry_delta;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_forwarding_info_fee_base_msat: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_forwarding_info_fee_base_msat =
                counterparty_forwarding_info_fee_base_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_forwarding_info_fee_base_msat =
                            api_counterparty_forwarding_info_fee_base_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_forwarding_info_fee_proportional_millionths: impl CstDecode<Option<u32>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { let api_that = that.cst_decode();let api_counterparty_forwarding_info_fee_proportional_millionths = counterparty_forwarding_info_fee_proportional_millionths.cst_decode();
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, true)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                _ => unreachable!(),
            }
        }
        let mut api_that_guard = api_that_guard.unwrap();
 let output_ok = Result::<_,()>::Ok({ { api_that_guard.counterparty_forwarding_info_fee_proportional_millionths = api_counterparty_forwarding_info_fee_proportional_millionths; }; })?;   Ok(output_ok)
                })()) })
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_node_id: impl CstDecode<shared::PublicKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_counterparty_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_node_id = api_counterparty_node_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_outbound_htlc_maximum_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_outbound_htlc_maximum_msat =
                counterparty_outbound_htlc_maximum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_outbound_htlc_maximum_msat =
                            api_counterparty_outbound_htlc_maximum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_outbound_htlc_minimum_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_outbound_htlc_minimum_msat =
                counterparty_outbound_htlc_minimum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_outbound_htlc_minimum_msat =
                            api_counterparty_outbound_htlc_minimum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    counterparty_unspendable_punishment_reserve: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name:
                "ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_unspendable_punishment_reserve =
                counterparty_unspendable_punishment_reserve.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.counterparty_unspendable_punishment_reserve =
                            api_counterparty_unspendable_punishment_reserve;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    feerate_sat_per_1000_weight: impl CstDecode<u32>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_feerate_sat_per_1000_weight = feerate_sat_per_1000_weight.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.feerate_sat_per_1000_weight =
                            api_feerate_sat_per_1000_weight;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_force_close_spend_delay_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    force_close_spend_delay: impl CstDecode<Option<u16>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_force_close_spend_delay",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_force_close_spend_delay = force_close_spend_delay.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.force_close_spend_delay = api_force_close_spend_delay;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_funding_txo_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    funding_txo: impl CstDecode<Option<shared::OutPoint>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_funding_txo",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_funding_txo = funding_txo.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.funding_txo = api_funding_txo;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    inbound_capacity_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_inbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inbound_capacity_msat = inbound_capacity_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inbound_capacity_msat = api_inbound_capacity_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    inbound_htlc_maximum_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inbound_htlc_maximum_msat = inbound_htlc_maximum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inbound_htlc_maximum_msat = api_inbound_htlc_maximum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    inbound_htlc_minimum_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inbound_htlc_minimum_msat = inbound_htlc_minimum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inbound_htlc_minimum_msat = api_inbound_htlc_minimum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_channel_ready_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    is_channel_ready: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_is_channel_ready",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_channel_ready = is_channel_ready.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_channel_ready = api_is_channel_ready;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_outbound_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    is_outbound: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_is_outbound",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_outbound = is_outbound.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_outbound = api_is_outbound;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_usable_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    is_usable: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_is_usable",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_usable = is_usable.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_usable = api_is_usable;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    next_outbound_htlc_limit_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_next_outbound_htlc_limit_msat = next_outbound_htlc_limit_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.next_outbound_htlc_limit_msat =
                            api_next_outbound_htlc_limit_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    next_outbound_htlc_minimum_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_next_outbound_htlc_minimum_msat = next_outbound_htlc_minimum_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.next_outbound_htlc_minimum_msat =
                            api_next_outbound_htlc_minimum_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_outbound_capacity_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    outbound_capacity_msat: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_outbound_capacity_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_outbound_capacity_msat = outbound_capacity_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.outbound_capacity_msat = api_outbound_capacity_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_unspendable_punishment_reserve_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    unspendable_punishment_reserve: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_unspendable_punishment_reserve",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_unspendable_punishment_reserve = unspendable_punishment_reserve.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.unspendable_punishment_reserve =
                            api_unspendable_punishment_reserve;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_user_channel_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
    >,
    user_channel_id: impl CstDecode<ldk_adapter::types::UserChannelId>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ChannelDetails_auto_accessor_set_user_channel_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.user_channel_id = api_user_channel_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
    short_channel_id: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_short_channel_id = short_channel_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::graph::NetworkGraph::channel(
                            &*api_that_guard,
                            api_short_channel_id,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::graph::NetworkGraph::list_channels(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_list_nodes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_list_nodes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::graph::NetworkGraph::list_nodes(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__graph__NetworkGraph_node_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
    >,
    node_id: impl CstDecode<ldk_adapter::graph::NodeId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "NetworkGraph_node",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::graph::NetworkGraph::node(&*api_that_guard, api_node_id)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_bolt11_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<Node>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_bolt11_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::bolt11_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_bolt12_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<Node>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_bolt12_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::bolt12_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    user_channel_id: impl CstDecode<ldk_adapter::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<shared::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::close_channel(
                            &*api_that_guard,
                            api_user_channel_id,
                            api_counterparty_node_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::config(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_connect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    node_id: impl CstDecode<shared::PublicKey>,
    address: impl CstDecode<SocketAddress>,
    persist: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_connect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_address = address.cst_decode();
            let api_persist = persist.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::connect(
                            &*api_that_guard,
                            api_node_id,
                            api_address,
                            api_persist,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_disconnect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    counterparty_node_id: impl CstDecode<shared::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_disconnect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::disconnect(
                            &*api_that_guard,
                            api_counterparty_node_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_event_handled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_event_handled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::event_handled(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_export_pathfinding_scores_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_export_pathfinding_scores",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::node::Node::export_pathfinding_scores(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_force_close_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    user_channel_id: impl CstDecode<ldk_adapter::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<shared::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_force_close_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::force_close_channel(
                            &*api_that_guard,
                            api_user_channel_id,
                            api_counterparty_node_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_balances_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_balances",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::list_balances(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_channels_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_channels",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::list_channels(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_payments_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_payments",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::list_payments(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_payments_with_filter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    payment_direction: impl CstDecode<ldk_adapter::types::PaymentDirection>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_payments_with_filter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_direction = payment_direction.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::list_payments_with_filter(
                            &*api_that_guard,
                            api_payment_direction,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_list_peers_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_list_peers",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::list_peers(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_listening_addresses_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_listening_addresses",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        ldk_adapter::node::Node::listening_addresses(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_network_graph_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<Node>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_network_graph",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::network_graph(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::next_event(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_next_event_async_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_next_event_async",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, ()>(
                    (move || async move {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_that_guard =
                                        Some(api_that.lockable_decode_async_ref().await)
                                }
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = Result::<_, ()>::Ok(
                            ldk_adapter::node::Node::next_event_async(&*api_that_guard).await,
                        )?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_node_id_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_node_id",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::node_id(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_on_chain_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<Node>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_on_chain_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::on_chain_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_open_announced_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    socket_address: impl CstDecode<SocketAddress>,
    node_id: impl CstDecode<shared::PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    channel_config: impl CstDecode<Option<ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_open_announced_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_socket_address = socket_address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::open_announced_channel(
                            &*api_that_guard,
                            api_socket_address,
                            api_node_id,
                            api_channel_amount_sats,
                            api_push_to_counterparty_msat,
                            api_channel_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_open_channel_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    socket_address: impl CstDecode<SocketAddress>,
    node_id: impl CstDecode<shared::PublicKey>,
    channel_amount_sats: impl CstDecode<u64>,
    push_to_counterparty_msat: impl CstDecode<Option<u64>>,
    channel_config: impl CstDecode<Option<ChannelConfig>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_open_channel",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_socket_address = socket_address.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_channel_amount_sats = channel_amount_sats.cst_decode();
            let api_push_to_counterparty_msat = push_to_counterparty_msat.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::open_channel(
                            &*api_that_guard,
                            api_socket_address,
                            api_node_id,
                            api_channel_amount_sats,
                            api_push_to_counterparty_msat,
                            api_channel_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    payment_id: impl CstDecode<shared::PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::payment(
                        &*api_that_guard,
                        api_payment_id,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_remove_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    payment_id: impl CstDecode<shared::PaymentId>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_remove_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_payment_id = payment_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::remove_payment(
                            &*api_that_guard,
                            api_payment_id,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_sign_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    msg: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_sign_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::sign_message(
                        &*api_that_guard,
                        api_msg,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_spontaneous_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<Node>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_spontaneous_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::spontaneous_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::start(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::status(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_stop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_stop",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::stop(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_sync_wallets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_sync_wallets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::sync_wallets(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_unified_qr_payment_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr: impl CstDecode<Node>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_unified_qr_payment",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_ptr = ptr.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::node::Node::unified_qr_payment(api_ptr))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_update_channel_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    user_channel_id: impl CstDecode<ldk_adapter::types::UserChannelId>,
    counterparty_node_id: impl CstDecode<shared::PublicKey>,
    channel_config: impl CstDecode<ChannelConfig>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_update_channel_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_user_channel_id = user_channel_id.cst_decode();
            let api_counterparty_node_id = counterparty_node_id.cst_decode();
            let api_channel_config = channel_config.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::update_channel_config(
                            &*api_that_guard,
                            api_user_channel_id,
                            api_counterparty_node_id,
                            api_channel_config,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_verify_signature_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
    msg: impl CstDecode<Vec<u8>>,
    sig: impl CstDecode<String>,
    public_key: impl CstDecode<shared::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_verify_signature",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_msg = msg.cst_decode();
            let api_sig = sig.cst_decode();
            let api_public_key = public_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::node::Node::verify_signature(
                            &*api_that_guard,
                            api_msg,
                            api_sig,
                            api_public_key,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__node__Node_wait_next_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Node_wait_next_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::node::Node::wait_next_event(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__on_chain__OnChainPayment_new_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnChainPayment_new_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::on_chain::OnChainPayment::new_address(&*api_that_guard)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__on_chain__OnChainPayment_send_all_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
    >,
    address: impl CstDecode<BitcoinAddress>,
    retain_reserves: impl CstDecode<bool>,
    fee_rate_sat_per_kwu: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnChainPayment_send_all_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_retain_reserves = retain_reserves.cst_decode();
            let api_fee_rate_sat_per_kwu = fee_rate_sat_per_kwu.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::on_chain::OnChainPayment::send_all_to_address(
                            &*api_that_guard,
                            api_address,
                            api_retain_reserves,
                            api_fee_rate_sat_per_kwu,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__on_chain__OnChainPayment_send_to_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
    >,
    address: impl CstDecode<BitcoinAddress>,
    amount_sats: impl CstDecode<u64>,
    fee_rate_sat_per_kwu: impl CstDecode<Option<u64>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "OnChainPayment_send_to_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            let api_fee_rate_sat_per_kwu = fee_rate_sat_per_kwu.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::on_chain::OnChainPayment::send_to_address(
                            &*api_that_guard,
                            api_address,
                            api_amount_sats,
                            api_fee_rate_sat_per_kwu,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_amount_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_amount_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.amount_msat.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_direction_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_direction",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.direction.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_kind_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_kind",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.kind.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_latest_update_timestamp_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_latest_update_timestamp",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(api_that_guard.latest_update_timestamp.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_status_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_get_status",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.status.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_amount_msat_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    amount_msat: impl CstDecode<Option<u64>>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_amount_msat",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.amount_msat = api_amount_msat;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_direction_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    direction: impl CstDecode<ldk_adapter::types::PaymentDirection>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_direction",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_direction = direction.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.direction = api_direction;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    id: impl CstDecode<shared::PaymentId>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_id = id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.id = api_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_kind_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    kind: impl CstDecode<PaymentKind>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_kind",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_kind = kind.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.kind = api_kind;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_latest_update_timestamp_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    latest_update_timestamp: impl CstDecode<u64>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_latest_update_timestamp",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_latest_update_timestamp = latest_update_timestamp.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.latest_update_timestamp = api_latest_update_timestamp;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_status_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
    >,
    status: impl CstDecode<ldk_adapter::types::PaymentStatus>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PaymentDetails_auto_accessor_set_status",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_status = status.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.status = api_status;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_get_address_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_get_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.address.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_get_is_connected_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_get_is_connected",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.is_connected.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_get_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_get_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.node_id.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_set_address_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
    address: impl CstDecode<SocketAddress>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_set_address",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_address = address.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.address = api_address;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_set_is_connected_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
    is_connected: impl CstDecode<bool>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_set_is_connected",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_connected = is_connected.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.is_connected = api_is_connected;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__types__PeerDetails_auto_accessor_set_node_id_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
    >,
    node_id: impl CstDecode<shared::PublicKey>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "PeerDetails_auto_accessor_set_node_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_node_id = node_id.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.node_id = api_node_id;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__ldk_adapter__spontaneous__SpontaneousPayment_send_probes_unsafe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<shared::PublicKey>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SpontaneousPayment_send_probes_unsafe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok =
                            ldk_adapter::spontaneous::SpontaneousPayment::send_probes_unsafe(
                                &*api_that_guard,
                                api_amount_msat,
                                api_node_id,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__spontaneous__SpontaneousPayment_send_unsafe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<shared::PublicKey>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SpontaneousPayment_send_unsafe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_msat = amount_msat.cst_decode();
            let api_node_id = node_id.cst_decode();
            let api_sending_parameters = sending_parameters.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::spontaneous::SpontaneousPayment::send_unsafe(
                            &*api_that_guard,
                            api_amount_msat,
                            api_node_id,
                            api_sending_parameters,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__spontaneous__SpontaneousPayment_send_with_custom_tlvs_unsafe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>,
    >,
    amount_msat: impl CstDecode<u64>,
    node_id: impl CstDecode<shared::PublicKey>,
    sending_parameters: impl CstDecode<Option<shared::SendingParameters>>,
    custom_tlvs: impl CstDecode<Vec<ldk_adapter::types::CustomTlvRecord>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "SpontaneousPayment_send_with_custom_tlvs_unsafe", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { let api_that = that.cst_decode();let api_amount_msat = amount_msat.cst_decode();let api_node_id = node_id.cst_decode();let api_sending_parameters = sending_parameters.cst_decode();let api_custom_tlvs = custom_tlvs.cst_decode(); move |context|  {
                    transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>((move ||  {
                        let mut api_that_guard = None;
let decode_indices_ = flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(&api_that, 0, false)]);
        for i in decode_indices_ {
            match i {
                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                _ => unreachable!(),
            }
        }
        let api_that_guard = api_that_guard.unwrap();
 let output_ok = ldk_adapter::spontaneous::SpontaneousPayment::send_with_custom_tlvs_unsafe(&*api_that_guard, api_amount_msat, api_node_id, api_sending_parameters, api_custom_tlvs)?;   Ok(output_ok)
                    })())
                } })
}
fn wire__shared__TaprootSpendInfo_auto_accessor_get_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TaprootSpendInfo_auto_accessor_get_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inner.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__TaprootSpendInfo_auto_accessor_set_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>,
    >,
    inner: impl CstDecode<TaprootSpendInfoInner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TaprootSpendInfo_auto_accessor_set_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inner = inner.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inner = api_inner;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__Transaction_auto_accessor_get_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_auto_accessor_get_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(api_that_guard.inner.clone())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__Transaction_auto_accessor_set_inner_impl(
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
    inner: impl CstDecode<BitcoinTransactionInner>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_auto_accessor_set_inner",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_inner = inner.cst_decode();
            transform_result_dco::<_, _, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, true,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                        _ => unreachable!(),
                    }
                }
                let mut api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok({
                    {
                        api_that_guard.inner = api_inner;
                    };
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__shared__Transaction_compute_txid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_compute_txid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::compute_txid(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_compute_wtxid_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_compute_wtxid",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::compute_wtxid(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_input_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_input",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::input(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_is_coinbase_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_is_coinbase",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::is_coinbase(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_is_explicitly_rbf_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_is_explicitly_rbf",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(shared::Transaction::is_explicitly_rbf(
                        &*api_that_guard,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_is_lock_time_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_is_lock_time_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok = Result::<_, ()>::Ok(
                        shared::Transaction::is_lock_time_enabled(&*api_that_guard),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_lock_time_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_lock_time",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::lock_time(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    transaction_bytes: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_transaction_bytes = transaction_bytes.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Transaction::new(api_transaction_bytes)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__Transaction_output_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_output",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::output(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_total_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_total_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::total_size(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_version_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_version",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::version(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_vsize_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_vsize",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::vsize(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__Transaction_weight_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
    >,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Transaction_weight",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, false,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                            _ => unreachable!(),
                        }
                    }
                    let api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Transaction::weight(&*api_that_guard))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__unified_qr__UnifiedQrPayment_receive_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>,
    >,
    amount_sats: impl CstDecode<u64>,
    message: impl CstDecode<String>,
    expiry_sec: impl CstDecode<u32>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UnifiedQrPayment_receive",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_amount_sats = amount_sats.cst_decode();
            let api_message = message.cst_decode();
            let api_expiry_sec = expiry_sec.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::unified_qr::UnifiedQrPayment::receive(
                            &*api_that_guard,
                            api_amount_sats,
                            api_message,
                            api_expiry_sec,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__unified_qr__UnifiedQrPayment_send_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<
        RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>,
    >,
    uri_str: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "UnifiedQrPayment_send",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_uri_str = uri_str.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                                _ => unreachable!(),
                            }
                        }
                        let api_that_guard = api_that_guard.unwrap();
                        let output_ok = ldk_adapter::unified_qr::UnifiedQrPayment::send(
                            &*api_that_guard,
                            api_uri_str,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__ldk_adapter__types__anchor_channels_config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "anchor_channels_config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(ldk_adapter::types::AnchorChannelsConfig::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__ldk_adapter__types__config_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "config_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(ldk_adapter::types::Config::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__mnemonic_as_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Mnemonic>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_as_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(shared::Mnemonic::as_string(&api_that))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__mnemonic_from_entropy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    entropy: impl CstDecode<Vec<u8>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_from_entropy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_entropy = entropy.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Mnemonic::from_entropy(&api_entropy)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__mnemonic_generate_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(shared::Mnemonic::generate())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__mnemonic_to_seed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Mnemonic>,
    passphrase: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "mnemonic_to_seed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(shared::Mnemonic::to_seed(&api_that, &api_passphrase))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__shared__psbt_extract_tx_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Psbt>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "psbt_extract_tx",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Psbt::extract_tx(&api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__psbt_fee_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<shared::Psbt>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "psbt_fee",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Psbt::fee(&api_that)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__shared__psbt_from_base64_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    base64: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "psbt_from_base64",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_base64 = base64.cst_decode();
            move |context| {
                transform_result_dco::<_, _, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok = shared::Psbt::from_base64(api_base64)?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    {
        let AnchorChannelsConfig = None::<ldk_adapter::types::AnchorChannelsConfig>.unwrap();
        let _: Vec<shared::PublicKey> = AnchorChannelsConfig.trusted_peers_no_reserve;
        let _: u64 = AnchorChannelsConfig.per_channel_reserve_sats;
    }
    {
        let BalanceDetails = None::<ldk_adapter::types::BalanceDetails>.unwrap();
        let _: u64 = BalanceDetails.total_onchain_balance_sats;
        let _: u64 = BalanceDetails.spendable_onchain_balance_sats;
        let _: u64 = BalanceDetails.total_lightning_balance_sats;
        let _: Vec<LightningBalance> = BalanceDetails.lightning_balances;
        let _: Vec<PendingSweepBalance> = BalanceDetails.pending_balances_from_channel_closures;
    }
    {
        let BestBlock = None::<ldk_adapter::types::BestBlock>.unwrap();
        let _: String = BestBlock.block_hash;
        let _: u32 = BestBlock.height;
    }
    {
        let Bolt11Invoice = None::<shared::Bolt11Invoice>.unwrap();
        let _: String = Bolt11Invoice.signed_raw_invoice;
    }
    {
        let Bolt12Invoice = None::<shared::Bolt12Invoice>.unwrap();
        let _: Vec<u8> = Bolt12Invoice.data;
    }
    {
        let ChannelId = None::<ldk_adapter::types::ChannelId>.unwrap();
        let _: [u8; 32] = ChannelId.data;
    }
    {
        let ChannelInfo = None::<ldk_adapter::graph::ChannelInfo>.unwrap();
        let _: ldk_adapter::graph::NodeId = ChannelInfo.node_one;
        let _: Option<ldk_adapter::graph::ChannelUpdateInfo> = ChannelInfo.one_to_two;
        let _: ldk_adapter::graph::NodeId = ChannelInfo.node_two;
        let _: Option<ldk_adapter::graph::ChannelUpdateInfo> = ChannelInfo.two_to_one;
        let _: Option<u64> = ChannelInfo.capacity_sats;
    }
    {
        let ChannelUpdateInfo = None::<ldk_adapter::graph::ChannelUpdateInfo>.unwrap();
        let _: u32 = ChannelUpdateInfo.last_update;
        let _: bool = ChannelUpdateInfo.enabled;
        let _: u16 = ChannelUpdateInfo.cltv_expiry_delta;
        let _: u64 = ChannelUpdateInfo.htlc_minimum_msat;
        let _: u64 = ChannelUpdateInfo.htlc_maximum_msat;
        let _: ldk_adapter::graph::RoutingFees = ChannelUpdateInfo.fees;
    }
    {
        let Config = None::<ldk_adapter::types::Config>.unwrap();
        let _: String = Config.storage_dir_path;
        let _: shared::Network = Config.network;
        let _: Option<Vec<SocketAddress>> = Config.listening_addresses;
        let _: Option<Vec<SocketAddress>> = Config.announcement_addresses;
        let _: Option<ldk_adapter::types::NodeAlias> = Config.node_alias;
        let _: Vec<shared::PublicKey> = Config.trusted_peers_0conf;
        let _: u64 = Config.probing_liquidity_limit_multiplier;
        let _: Option<ldk_adapter::types::AnchorChannelsConfig> = Config.anchor_channels_config;
        let _: Option<shared::SendingParameters> = Config.sending_parameters;
    }
    {
        let CustomTlvRecord = None::<ldk_adapter::types::CustomTlvRecord>.unwrap();
        let _: u64 = CustomTlvRecord.type_num;
        let _: Vec<u8> = CustomTlvRecord.value;
    }
    {
        let FfiLogRecord = None::<ldk_adapter::types::FfiLogRecord>.unwrap();
        let _: ldk_adapter::types::LogLevel = FfiLogRecord.level;
        let _: String = FfiLogRecord.args;
        let _: String = FfiLogRecord.module_path;
        let _: u32 = FfiLogRecord.line;
    }
    {
        let LiquiditySourceConfig = None::<ldk_adapter::types::LiquiditySourceConfig>.unwrap();
        let _: (SocketAddress, shared::PublicKey, Option<String>) =
            LiquiditySourceConfig.lsps2_service;
    }
    {
        let Mnemonic = None::<shared::Mnemonic>.unwrap();
        let _: Vec<String> = Mnemonic.words;
    }
    {
        let NodeAlias_ = None::<ldk_adapter::types::NodeAlias>.unwrap();
        let _: [u8; 32] = NodeAlias_.0;
    }
    {
        let NodeAnnouncementInfo = None::<ldk_adapter::graph::NodeAnnouncementInfo>.unwrap();
        let _: u32 = NodeAnnouncementInfo.last_update;
        let _: String = NodeAnnouncementInfo.alias;
        let _: Vec<SocketAddress> = NodeAnnouncementInfo.addresses;
    }
    {
        let NodeId = None::<ldk_adapter::graph::NodeId>.unwrap();
        let _: Vec<u8> = NodeId.compressed;
    }
    {
        let NodeInfo = None::<ldk_adapter::graph::NodeInfo>.unwrap();
        let _: Vec<u64> = NodeInfo.channels;
        let _: Option<ldk_adapter::graph::NodeAnnouncementInfo> = NodeInfo.announcement_info;
    }
    {
        let NodeStatus = None::<ldk_adapter::types::NodeStatus>.unwrap();
        let _: bool = NodeStatus.is_running;
        let _: bool = NodeStatus.is_listening;
        let _: ldk_adapter::types::BestBlock = NodeStatus.current_best_block;
        let _: Option<u64> = NodeStatus.latest_lightning_wallet_sync_timestamp;
        let _: Option<u64> = NodeStatus.latest_onchain_wallet_sync_timestamp;
        let _: Option<u64> = NodeStatus.latest_fee_rate_cache_update_timestamp;
        let _: Option<u64> = NodeStatus.latest_rgs_snapshot_timestamp;
        let _: Option<u64> = NodeStatus.latest_node_announcement_broadcast_timestamp;
        let _: Option<u32> = NodeStatus.latest_channel_monitor_archival_height;
    }
    {
        let Offer = None::<shared::Offer>.unwrap();
        let _: String = Offer.s;
    }
    {
        let OutPoint = None::<shared::OutPoint>.unwrap();
        let _: shared::Txid = OutPoint.txid;
        let _: u32 = OutPoint.vout;
    }
    {
        let PaymentHash = None::<shared::PaymentHash>.unwrap();
        let _: [u8; 32] = PaymentHash.data;
    }
    {
        let PaymentId = None::<shared::PaymentId>.unwrap();
        let _: Vec<u8> = PaymentId.data;
    }
    {
        let PaymentPreimage = None::<shared::PaymentPreimage>.unwrap();
        let _: [u8; 32] = PaymentPreimage.data;
    }
    {
        let Psbt = None::<shared::Psbt>.unwrap();
        let _: String = Psbt.inner;
    }
    {
        let PublicKey = None::<shared::PublicKey>.unwrap();
        let _: String = PublicKey.hex;
    }
    {
        let Refund = None::<shared::Refund>.unwrap();
        let _: String = Refund.s;
    }
    {
        let RoutingFees = None::<ldk_adapter::graph::RoutingFees>.unwrap();
        let _: u32 = RoutingFees.base_msat;
        let _: u32 = RoutingFees.proportional_millionths;
    }
    {
        let ScriptBuf = None::<shared::ScriptBuf>.unwrap();
        let _: Vec<u8> = ScriptBuf.inner;
    }
    {
        let SendingParameters = None::<shared::SendingParameters>.unwrap();
        let _: Option<u64> = SendingParameters.max_total_routing_fee_msat;
        let _: Option<u32> = SendingParameters.max_total_cltv_expiry_delta;
        let _: Option<u8> = SendingParameters.max_path_count;
        let _: Option<u8> = SendingParameters.max_channel_saturation_power_of_half;
    }
    {
        let TxIn = None::<shared::TxIn>.unwrap();
        let _: shared::OutPoint = TxIn.previous_output;
        let _: shared::ScriptBuf = TxIn.script_sig;
        let _: u32 = TxIn.sequence;
        let _: Vec<Vec<u8>> = TxIn.witness;
    }
    {
        let TxOut = None::<shared::TxOut>.unwrap();
        let _: u64 = TxOut.value;
        let _: shared::ScriptBuf = TxOut.script_pubkey;
    }
    {
        let Txid = None::<shared::Txid>.unwrap();
        let _: String = Txid.hash;
    }
    {
        let UserChannelId = None::<ldk_adapter::types::UserChannelId>.unwrap();
        let _: Vec<u8> = UserChannelId.data;
    }
    {
        let WTxid = None::<shared::WTxid>.unwrap();
        let _: String = WTxid.hash;
    }
};

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<ldk_adapter::types::LogLevel> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::LogLevel {
        match self {
            0 => ldk_adapter::types::LogLevel::Gossip,
            1 => ldk_adapter::types::LogLevel::Trace,
            2 => ldk_adapter::types::LogLevel::Debug,
            3 => ldk_adapter::types::LogLevel::Info,
            4 => ldk_adapter::types::LogLevel::Warn,
            5 => ldk_adapter::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", self),
        }
    }
}
impl CstDecode<shared::Network> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> shared::Network {
        match self {
            0 => shared::Network::Bitcoin,
            1 => shared::Network::Testnet,
            2 => shared::Network::Testnet4,
            3 => shared::Network::Signet,
            4 => shared::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", self),
        }
    }
}
impl CstDecode<ldk_adapter::types::PaymentDirection> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::PaymentDirection {
        match self {
            0 => ldk_adapter::types::PaymentDirection::Inbound,
            1 => ldk_adapter::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", self),
        }
    }
}
impl CstDecode<ldk_adapter::types::PaymentStatus> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> ldk_adapter::types::PaymentStatus {
        match self {
            0 => ldk_adapter::types::PaymentStatus::Pending,
            1 => ldk_adapter::types::PaymentStatus::Succeeded,
            2 => ldk_adapter::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for AddressData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BitcoinAddressInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for BitcoinTransactionInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Bolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Bolt12Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Builder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for NetworkGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Node {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for OnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for QrPaymentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TaprootSpendInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TaprootSpendInfoInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for Transaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for UnifiedQrPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, String)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { decode_rust_opaque_nom(inner) };
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for ldk_adapter::types::AnchorChannelsConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_trustedPeersNoReserve = <Vec<shared::PublicKey>>::sse_decode(deserializer);
        let mut var_perChannelReserveSats = <u64>::sse_decode(deserializer);
        return ldk_adapter::types::AnchorChannelsConfig {
            trusted_peers_no_reserve: var_trustedPeersNoReserve,
            per_channel_reserve_sats: var_perChannelReserveSats,
        };
    }
}

impl SseDecode for ldk_adapter::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_totalOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_spendableOnchainBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_totalLightningBalanceSats = <u64>::sse_decode(deserializer);
        let mut var_lightningBalances = <Vec<LightningBalance>>::sse_decode(deserializer);
        let mut var_pendingBalancesFromChannelClosures =
            <Vec<PendingSweepBalance>>::sse_decode(deserializer);
        return ldk_adapter::types::BalanceDetails {
            total_onchain_balance_sats: var_totalOnchainBalanceSats,
            spendable_onchain_balance_sats: var_spendableOnchainBalanceSats,
            total_lightning_balance_sats: var_totalLightningBalanceSats,
            lightning_balances: var_lightningBalances,
            pending_balances_from_channel_closures: var_pendingBalancesFromChannelClosures,
        };
    }
}

impl SseDecode for ldk_adapter::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_blockHash = <String>::sse_decode(deserializer);
        let mut var_height = <u32>::sse_decode(deserializer);
        return ldk_adapter::types::BestBlock {
            block_hash: var_blockHash,
            height: var_height,
        };
    }
}

impl SseDecode for shared::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_signedRawInvoice = <String>::sse_decode(deserializer);
        return shared::Bolt11Invoice {
            signed_raw_invoice: var_signedRawInvoice,
        };
    }
}

impl SseDecode for shared::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return shared::Bolt12Invoice { data: var_data };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for ldk_adapter::types::ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return ldk_adapter::types::ChannelId { data: var_data };
    }
}

impl SseDecode for ldk_adapter::graph::ChannelInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_nodeOne = <ldk_adapter::graph::NodeId>::sse_decode(deserializer);
        let mut var_oneToTwo =
            <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_decode(deserializer);
        let mut var_nodeTwo = <ldk_adapter::graph::NodeId>::sse_decode(deserializer);
        let mut var_twoToOne =
            <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_decode(deserializer);
        let mut var_capacitySats = <Option<u64>>::sse_decode(deserializer);
        return ldk_adapter::graph::ChannelInfo {
            node_one: var_nodeOne,
            one_to_two: var_oneToTwo,
            node_two: var_nodeTwo,
            two_to_one: var_twoToOne,
            capacity_sats: var_capacitySats,
        };
    }
}

impl SseDecode for ldk_adapter::graph::ChannelUpdateInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdate = <u32>::sse_decode(deserializer);
        let mut var_enabled = <bool>::sse_decode(deserializer);
        let mut var_cltvExpiryDelta = <u16>::sse_decode(deserializer);
        let mut var_htlcMinimumMsat = <u64>::sse_decode(deserializer);
        let mut var_htlcMaximumMsat = <u64>::sse_decode(deserializer);
        let mut var_fees = <ldk_adapter::graph::RoutingFees>::sse_decode(deserializer);
        return ldk_adapter::graph::ChannelUpdateInfo {
            last_update: var_lastUpdate,
            enabled: var_enabled,
            cltv_expiry_delta: var_cltvExpiryDelta,
            htlc_minimum_msat: var_htlcMinimumMsat,
            htlc_maximum_msat: var_htlcMaximumMsat,
            fees: var_fees,
        };
    }
}

impl SseDecode for ldk_adapter::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_storageDirPath = <String>::sse_decode(deserializer);
        let mut var_network = <shared::Network>::sse_decode(deserializer);
        let mut var_listeningAddresses = <Option<Vec<SocketAddress>>>::sse_decode(deserializer);
        let mut var_announcementAddresses = <Option<Vec<SocketAddress>>>::sse_decode(deserializer);
        let mut var_nodeAlias = <Option<ldk_adapter::types::NodeAlias>>::sse_decode(deserializer);
        let mut var_trustedPeers0Conf = <Vec<shared::PublicKey>>::sse_decode(deserializer);
        let mut var_probingLiquidityLimitMultiplier = <u64>::sse_decode(deserializer);
        let mut var_anchorChannelsConfig =
            <Option<ldk_adapter::types::AnchorChannelsConfig>>::sse_decode(deserializer);
        let mut var_sendingParameters =
            <Option<shared::SendingParameters>>::sse_decode(deserializer);
        return ldk_adapter::types::Config {
            storage_dir_path: var_storageDirPath,
            network: var_network,
            listening_addresses: var_listeningAddresses,
            announcement_addresses: var_announcementAddresses,
            node_alias: var_nodeAlias,
            trusted_peers_0conf: var_trustedPeers0Conf,
            probing_liquidity_limit_multiplier: var_probingLiquidityLimitMultiplier,
            anchor_channels_config: var_anchorChannelsConfig,
            sending_parameters: var_sendingParameters,
        };
    }
}

impl SseDecode for ldk_adapter::types::CustomTlvRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_typeNum = <u64>::sse_decode(deserializer);
        let mut var_value = <Vec<u8>>::sse_decode(deserializer);
        return ldk_adapter::types::CustomTlvRecord {
            type_num: var_typeNum,
            value: var_value,
        };
    }
}

impl SseDecode for ldk_adapter::types::FfiLogRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_level = <ldk_adapter::types::LogLevel>::sse_decode(deserializer);
        let mut var_args = <String>::sse_decode(deserializer);
        let mut var_modulePath = <String>::sse_decode(deserializer);
        let mut var_line = <u32>::sse_decode(deserializer);
        return ldk_adapter::types::FfiLogRecord {
            level: var_level,
            args: var_args,
            module_path: var_modulePath,
            line: var_line,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for ldk_adapter::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lsps2Service =
            <(SocketAddress, shared::PublicKey, Option<String>)>::sse_decode(deserializer);
        return ldk_adapter::types::LiquiditySourceConfig {
            lsps2_service: var_lsps2Service,
        };
    }
}

impl SseDecode for Vec<ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ChannelDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<LightningBalance>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<PaymentDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<PeerDetails>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<PendingSweepBalance>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<SocketAddress>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ldk_adapter::types::CustomTlvRecord> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ldk_adapter::types::CustomTlvRecord>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Vec<u8>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<ldk_adapter::graph::NodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<ldk_adapter::graph::NodeId>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<shared::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<shared::PublicKey>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<shared::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<shared::TxIn>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<shared::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<shared::TxOut>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for ldk_adapter::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::LogLevel::Gossip,
            1 => ldk_adapter::types::LogLevel::Trace,
            2 => ldk_adapter::types::LogLevel::Debug,
            3 => ldk_adapter::types::LogLevel::Info,
            4 => ldk_adapter::types::LogLevel::Warn,
            5 => ldk_adapter::types::LogLevel::Error,
            _ => unreachable!("Invalid variant for LogLevel: {}", inner),
        };
    }
}

impl SseDecode for shared::Mnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_words = <Vec<String>>::sse_decode(deserializer);
        return shared::Mnemonic { words: var_words };
    }
}

impl SseDecode for shared::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => shared::Network::Bitcoin,
            1 => shared::Network::Testnet,
            2 => shared::Network::Testnet4,
            3 => shared::Network::Signet,
            4 => shared::Network::Regtest,
            _ => unreachable!("Invalid variant for Network: {}", inner),
        };
    }
}

impl SseDecode for ldk_adapter::types::NodeAlias {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <[u8; 32]>::sse_decode(deserializer);
        return ldk_adapter::types::NodeAlias(var_field0);
    }
}

impl SseDecode for ldk_adapter::graph::NodeAnnouncementInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lastUpdate = <u32>::sse_decode(deserializer);
        let mut var_alias = <String>::sse_decode(deserializer);
        let mut var_addresses = <Vec<SocketAddress>>::sse_decode(deserializer);
        return ldk_adapter::graph::NodeAnnouncementInfo {
            last_update: var_lastUpdate,
            alias: var_alias,
            addresses: var_addresses,
        };
    }
}

impl SseDecode for ldk_adapter::graph::NodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_compressed = <Vec<u8>>::sse_decode(deserializer);
        return ldk_adapter::graph::NodeId {
            compressed: var_compressed,
        };
    }
}

impl SseDecode for ldk_adapter::graph::NodeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_channels = <Vec<u64>>::sse_decode(deserializer);
        let mut var_announcementInfo =
            <Option<ldk_adapter::graph::NodeAnnouncementInfo>>::sse_decode(deserializer);
        return ldk_adapter::graph::NodeInfo {
            channels: var_channels,
            announcement_info: var_announcementInfo,
        };
    }
}

impl SseDecode for ldk_adapter::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_isRunning = <bool>::sse_decode(deserializer);
        let mut var_isListening = <bool>::sse_decode(deserializer);
        let mut var_currentBestBlock = <ldk_adapter::types::BestBlock>::sse_decode(deserializer);
        let mut var_latestLightningWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestOnchainWalletSyncTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestFeeRateCacheUpdateTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestRgsSnapshotTimestamp = <Option<u64>>::sse_decode(deserializer);
        let mut var_latestNodeAnnouncementBroadcastTimestamp =
            <Option<u64>>::sse_decode(deserializer);
        let mut var_latestChannelMonitorArchivalHeight = <Option<u32>>::sse_decode(deserializer);
        return ldk_adapter::types::NodeStatus {
            is_running: var_isRunning,
            is_listening: var_isListening,
            current_best_block: var_currentBestBlock,
            latest_lightning_wallet_sync_timestamp: var_latestLightningWalletSyncTimestamp,
            latest_onchain_wallet_sync_timestamp: var_latestOnchainWalletSyncTimestamp,
            latest_fee_rate_cache_update_timestamp: var_latestFeeRateCacheUpdateTimestamp,
            latest_rgs_snapshot_timestamp: var_latestRgsSnapshotTimestamp,
            latest_node_announcement_broadcast_timestamp:
                var_latestNodeAnnouncementBroadcastTimestamp,
            latest_channel_monitor_archival_height: var_latestChannelMonitorArchivalHeight,
        };
    }
}

impl SseDecode for shared::Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return shared::Offer { s: var_s };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ChainDataSourceConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ChannelConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<EntropySourceConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Event>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<GossipSourceConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<PaymentDetails>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::AnchorChannelsConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::AnchorChannelsConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::ChannelInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::ChannelInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::ChannelUpdateInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::ChannelUpdateInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::LiquiditySourceConfig>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::LogLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::LogLevel>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::types::NodeAlias> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::types::NodeAlias>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::NodeAnnouncementInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::NodeAnnouncementInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<ldk_adapter::graph::NodeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<ldk_adapter::graph::NodeInfo>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<shared::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<shared::OutPoint>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<shared::SendingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<shared::SendingParameters>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u16>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<SocketAddress>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for shared::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_txid = <shared::Txid>::sse_decode(deserializer);
        let mut var_vout = <u32>::sse_decode(deserializer);
        return shared::OutPoint {
            txid: var_txid,
            vout: var_vout,
        };
    }
}

impl SseDecode for ldk_adapter::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::PaymentDirection::Inbound,
            1 => ldk_adapter::types::PaymentDirection::Outbound,
            _ => unreachable!("Invalid variant for PaymentDirection: {}", inner),
        };
    }
}

impl SseDecode for shared::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return shared::PaymentHash { data: var_data };
    }
}

impl SseDecode for shared::PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return shared::PaymentId { data: var_data };
    }
}

impl SseDecode for shared::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <[u8; 32]>::sse_decode(deserializer);
        return shared::PaymentPreimage { data: var_data };
    }
}

impl SseDecode for ldk_adapter::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => ldk_adapter::types::PaymentStatus::Pending,
            1 => ldk_adapter::types::PaymentStatus::Succeeded,
            2 => ldk_adapter::types::PaymentStatus::Failed,
            _ => unreachable!("Invalid variant for PaymentStatus: {}", inner),
        };
    }
}

impl SseDecode for shared::Psbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inner = <String>::sse_decode(deserializer);
        return shared::Psbt { inner: var_inner };
    }
}

impl SseDecode for shared::PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hex = <String>::sse_decode(deserializer);
        return shared::PublicKey { hex: var_hex };
    }
}

impl SseDecode for (SocketAddress, shared::PublicKey, Option<String>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <SocketAddress>::sse_decode(deserializer);
        let mut var_field1 = <shared::PublicKey>::sse_decode(deserializer);
        let mut var_field2 = <Option<String>>::sse_decode(deserializer);
        return (var_field0, var_field1, var_field2);
    }
}

impl SseDecode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for shared::Refund {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_s = <String>::sse_decode(deserializer);
        return shared::Refund { s: var_s };
    }
}

impl SseDecode for ldk_adapter::graph::RoutingFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_baseMsat = <u32>::sse_decode(deserializer);
        let mut var_proportionalMillionths = <u32>::sse_decode(deserializer);
        return ldk_adapter::graph::RoutingFees {
            base_msat: var_baseMsat,
            proportional_millionths: var_proportionalMillionths,
        };
    }
}

impl SseDecode for shared::ScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_inner = <Vec<u8>>::sse_decode(deserializer);
        return shared::ScriptBuf { inner: var_inner };
    }
}

impl SseDecode for shared::SendingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_maxTotalRoutingFeeMsat = <Option<u64>>::sse_decode(deserializer);
        let mut var_maxTotalCltvExpiryDelta = <Option<u32>>::sse_decode(deserializer);
        let mut var_maxPathCount = <Option<u8>>::sse_decode(deserializer);
        let mut var_maxChannelSaturationPowerOfHalf = <Option<u8>>::sse_decode(deserializer);
        return shared::SendingParameters {
            max_total_routing_fee_msat: var_maxTotalRoutingFeeMsat,
            max_total_cltv_expiry_delta: var_maxTotalCltvExpiryDelta,
            max_path_count: var_maxPathCount,
            max_channel_saturation_power_of_half: var_maxChannelSaturationPowerOfHalf,
        };
    }
}

impl SseDecode for shared::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_previousOutput = <shared::OutPoint>::sse_decode(deserializer);
        let mut var_scriptSig = <shared::ScriptBuf>::sse_decode(deserializer);
        let mut var_sequence = <u32>::sse_decode(deserializer);
        let mut var_witness = <Vec<Vec<u8>>>::sse_decode(deserializer);
        return shared::TxIn {
            previous_output: var_previousOutput,
            script_sig: var_scriptSig,
            sequence: var_sequence,
            witness: var_witness,
        };
    }
}

impl SseDecode for shared::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <u64>::sse_decode(deserializer);
        let mut var_scriptPubkey = <shared::ScriptBuf>::sse_decode(deserializer);
        return shared::TxOut {
            value: var_value,
            script_pubkey: var_scriptPubkey,
        };
    }
}

impl SseDecode for shared::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        return shared::Txid { hash: var_hash };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::from_vec_to_array(inner);
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for ldk_adapter::types::UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_data = <Vec<u8>>::sse_decode(deserializer);
        return ldk_adapter::types::UserChannelId { data: var_data };
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for shared::WTxid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hash = <String>::sse_decode(deserializer);
        return shared::WTxid { hash: var_hash };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<AddressData> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<AddressData> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<AddressData>> for AddressData {
    fn into_into_dart(self) -> FrbWrapper<AddressData> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinAddress> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<BitcoinAddress> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinAddress>> for BitcoinAddress {
    fn into_into_dart(self) -> FrbWrapper<BitcoinAddress> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinAddressInner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<BitcoinAddressInner>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinAddressInner>> for BitcoinAddressInner {
    fn into_into_dart(self) -> FrbWrapper<BitcoinAddressInner> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<BitcoinTransactionInner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<BitcoinTransactionInner>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<BitcoinTransactionInner>>
    for BitcoinTransactionInner
{
    fn into_into_dart(self) -> FrbWrapper<BitcoinTransactionInner> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Bolt11Payment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Bolt11Payment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Bolt11Payment>> for Bolt11Payment {
    fn into_into_dart(self) -> FrbWrapper<Bolt11Payment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Bolt12Payment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Bolt12Payment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Bolt12Payment>> for Bolt12Payment {
    fn into_into_dart(self) -> FrbWrapper<Bolt12Payment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Builder> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Builder> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Builder>> for Builder {
    fn into_into_dart(self) -> FrbWrapper<Builder> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChainDataSourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ChainDataSourceConfig>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChainDataSourceConfig>>
    for ChainDataSourceConfig
{
    fn into_into_dart(self) -> FrbWrapper<ChainDataSourceConfig> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelConfig> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelConfig>> for ChannelConfig {
    fn into_into_dart(self) -> FrbWrapper<ChannelConfig> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ChannelDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<ChannelDetails> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ChannelDetails>> for ChannelDetails {
    fn into_into_dart(self) -> FrbWrapper<ChannelDetails> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<EntropySourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<EntropySourceConfig>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<EntropySourceConfig>> for EntropySourceConfig {
    fn into_into_dart(self) -> FrbWrapper<EntropySourceConfig> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Event> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Event> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Event>> for Event {
    fn into_into_dart(self) -> FrbWrapper<Event> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<GossipSourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<GossipSourceConfig>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<GossipSourceConfig>> for GossipSourceConfig {
    fn into_into_dart(self) -> FrbWrapper<GossipSourceConfig> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<LightningBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<LightningBalance> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<LightningBalance>> for LightningBalance {
    fn into_into_dart(self) -> FrbWrapper<LightningBalance> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MaxDustHTLCExposure> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<MaxDustHTLCExposure>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MaxDustHTLCExposure>> for MaxDustHTLCExposure {
    fn into_into_dart(self) -> FrbWrapper<MaxDustHTLCExposure> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<NetworkGraph> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<NetworkGraph> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<NetworkGraph>> for NetworkGraph {
    fn into_into_dart(self) -> FrbWrapper<NetworkGraph> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Node> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Node> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Node>> for Node {
    fn into_into_dart(self) -> FrbWrapper<Node> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<OnChainPayment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<OnChainPayment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<OnChainPayment>> for OnChainPayment {
    fn into_into_dart(self) -> FrbWrapper<OnChainPayment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PaymentDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PaymentDetails> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PaymentDetails>> for PaymentDetails {
    fn into_into_dart(self) -> FrbWrapper<PaymentDetails> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PaymentKind> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PaymentKind> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PaymentKind>> for PaymentKind {
    fn into_into_dart(self) -> FrbWrapper<PaymentKind> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PeerDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<PeerDetails> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PeerDetails>> for PeerDetails {
    fn into_into_dart(self) -> FrbWrapper<PeerDetails> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<PendingSweepBalance> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<PendingSweepBalance>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<PendingSweepBalance>> for PendingSweepBalance {
    fn into_into_dart(self) -> FrbWrapper<PendingSweepBalance> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<QrPaymentResult> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<QrPaymentResult> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<QrPaymentResult>> for QrPaymentResult {
    fn into_into_dart(self) -> FrbWrapper<QrPaymentResult> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SocketAddress> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<SocketAddress> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SocketAddress>> for SocketAddress {
    fn into_into_dart(self) -> FrbWrapper<SocketAddress> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SpontaneousPayment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<SpontaneousPayment>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SpontaneousPayment>> for SpontaneousPayment {
    fn into_into_dart(self) -> FrbWrapper<SpontaneousPayment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TaprootSpendInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<TaprootSpendInfo> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TaprootSpendInfo>> for TaprootSpendInfo {
    fn into_into_dart(self) -> FrbWrapper<TaprootSpendInfo> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TaprootSpendInfoInner> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<TaprootSpendInfoInner>
{
}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TaprootSpendInfoInner>>
    for TaprootSpendInfoInner
{
    fn into_into_dart(self) -> FrbWrapper<TaprootSpendInfoInner> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<Transaction> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<Transaction> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<Transaction>> for Transaction {
    fn into_into_dart(self) -> FrbWrapper<Transaction> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<UnifiedQrPayment> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<UnifiedQrPayment> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<UnifiedQrPayment>> for UnifiedQrPayment {
    fn into_into_dart(self) -> FrbWrapper<UnifiedQrPayment> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::AnchorChannelsConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.trusted_peers_no_reserve.into_into_dart().into_dart(),
            self.0.per_channel_reserve_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::AnchorChannelsConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::AnchorChannelsConfig>>
    for ldk_adapter::types::AnchorChannelsConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::AnchorChannelsConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::BalanceDetails> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .total_onchain_balance_sats
                .into_into_dart()
                .into_dart(),
            self.0
                .spendable_onchain_balance_sats
                .into_into_dart()
                .into_dart(),
            self.0
                .total_lightning_balance_sats
                .into_into_dart()
                .into_dart(),
            self.0.lightning_balances.into_into_dart().into_dart(),
            self.0
                .pending_balances_from_channel_closures
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::BalanceDetails>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::BalanceDetails>>
    for ldk_adapter::types::BalanceDetails
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::BalanceDetails> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::BestBlock> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.block_hash.into_into_dart().into_dart(),
            self.0.height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::BestBlock>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::BestBlock>>
    for ldk_adapter::types::BestBlock
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::BestBlock> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Bolt11Invoice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.signed_raw_invoice.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::Bolt11Invoice>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Bolt11Invoice>>
    for shared::Bolt11Invoice
{
    fn into_into_dart(self) -> FrbWrapper<shared::Bolt11Invoice> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Bolt12Invoice> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::Bolt12Invoice>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Bolt12Invoice>>
    for shared::Bolt12Invoice
{
    fn into_into_dart(self) -> FrbWrapper<shared::Bolt12Invoice> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::ChannelId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::ChannelId>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::ChannelId>>
    for ldk_adapter::types::ChannelId
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::ChannelId> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::ChannelInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.node_one.into_into_dart().into_dart(),
            self.0.one_to_two.into_into_dart().into_dart(),
            self.0.node_two.into_into_dart().into_dart(),
            self.0.two_to_one.into_into_dart().into_dart(),
            self.0.capacity_sats.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::ChannelInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::ChannelInfo>>
    for ldk_adapter::graph::ChannelInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::ChannelInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.last_update.into_into_dart().into_dart(),
            self.0.enabled.into_into_dart().into_dart(),
            self.0.cltv_expiry_delta.into_into_dart().into_dart(),
            self.0.htlc_minimum_msat.into_into_dart().into_dart(),
            self.0.htlc_maximum_msat.into_into_dart().into_dart(),
            self.0.fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo>>
    for ldk_adapter::graph::ChannelUpdateInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::ChannelUpdateInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::Config> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.storage_dir_path.into_into_dart().into_dart(),
            self.0.network.into_into_dart().into_dart(),
            self.0.listening_addresses.into_into_dart().into_dart(),
            self.0.announcement_addresses.into_into_dart().into_dart(),
            self.0.node_alias.into_into_dart().into_dart(),
            self.0.trusted_peers_0conf.into_into_dart().into_dart(),
            self.0
                .probing_liquidity_limit_multiplier
                .into_into_dart()
                .into_dart(),
            self.0.anchor_channels_config.into_into_dart().into_dart(),
            self.0.sending_parameters.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::Config>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::Config>>
    for ldk_adapter::types::Config
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::Config> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::CustomTlvRecord> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.type_num.into_into_dart().into_dart(),
            self.0.value.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::CustomTlvRecord>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::CustomTlvRecord>>
    for ldk_adapter::types::CustomTlvRecord
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::CustomTlvRecord> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::FfiLogRecord> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.level.into_into_dart().into_dart(),
            self.0.args.into_into_dart().into_dart(),
            self.0.module_path.into_into_dart().into_dart(),
            self.0.line.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::FfiLogRecord>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::FfiLogRecord>>
    for ldk_adapter::types::FfiLogRecord
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::FfiLogRecord> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::LiquiditySourceConfig> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.lsps2_service.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::LiquiditySourceConfig>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::LiquiditySourceConfig>>
    for ldk_adapter::types::LiquiditySourceConfig
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::LiquiditySourceConfig> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::LogLevel> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::LogLevel::Gossip => 0.into_dart(),
            ldk_adapter::types::LogLevel::Trace => 1.into_dart(),
            ldk_adapter::types::LogLevel::Debug => 2.into_dart(),
            ldk_adapter::types::LogLevel::Info => 3.into_dart(),
            ldk_adapter::types::LogLevel::Warn => 4.into_dart(),
            ldk_adapter::types::LogLevel::Error => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::LogLevel>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::LogLevel>>
    for ldk_adapter::types::LogLevel
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::LogLevel> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Mnemonic> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.words.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Mnemonic> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Mnemonic>> for shared::Mnemonic {
    fn into_into_dart(self) -> FrbWrapper<shared::Mnemonic> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Network> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            shared::Network::Bitcoin => 0.into_dart(),
            shared::Network::Testnet => 1.into_dart(),
            shared::Network::Testnet4 => 2.into_dart(),
            shared::Network::Signet => 3.into_dart(),
            shared::Network::Regtest => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Network> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Network>> for shared::Network {
    fn into_into_dart(self) -> FrbWrapper<shared::Network> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::NodeAlias> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0 .0.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::NodeAlias>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::NodeAlias>>
    for ldk_adapter::types::NodeAlias
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::NodeAlias> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.last_update.into_into_dart().into_dart(),
            self.0.alias.into_into_dart().into_dart(),
            self.0.addresses.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo>>
    for ldk_adapter::graph::NodeAnnouncementInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::NodeAnnouncementInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::NodeId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.compressed.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::NodeId>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::NodeId>>
    for ldk_adapter::graph::NodeId
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::NodeId> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::NodeInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.channels.into_into_dart().into_dart(),
            self.0.announcement_info.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::NodeInfo>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::NodeInfo>>
    for ldk_adapter::graph::NodeInfo
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::NodeInfo> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::NodeStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.is_running.into_into_dart().into_dart(),
            self.0.is_listening.into_into_dart().into_dart(),
            self.0.current_best_block.into_into_dart().into_dart(),
            self.0
                .latest_lightning_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_onchain_wallet_sync_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_fee_rate_cache_update_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_rgs_snapshot_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_node_announcement_broadcast_timestamp
                .into_into_dart()
                .into_dart(),
            self.0
                .latest_channel_monitor_archival_height
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::NodeStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::NodeStatus>>
    for ldk_adapter::types::NodeStatus
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::NodeStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Offer> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Offer> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Offer>> for shared::Offer {
    fn into_into_dart(self) -> FrbWrapper<shared::Offer> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::OutPoint> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.txid.into_into_dart().into_dart(),
            self.0.vout.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::OutPoint> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::OutPoint>> for shared::OutPoint {
    fn into_into_dart(self) -> FrbWrapper<shared::OutPoint> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentDirection> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::PaymentDirection::Inbound => 0.into_dart(),
            ldk_adapter::types::PaymentDirection::Outbound => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentDirection>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentDirection>>
    for ldk_adapter::types::PaymentDirection
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentDirection> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::PaymentHash> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::PaymentHash>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::PaymentHash>> for shared::PaymentHash {
    fn into_into_dart(self) -> FrbWrapper<shared::PaymentHash> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::PaymentId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::PaymentId> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::PaymentId>> for shared::PaymentId {
    fn into_into_dart(self) -> FrbWrapper<shared::PaymentId> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::PaymentPreimage> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::PaymentPreimage>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::PaymentPreimage>>
    for shared::PaymentPreimage
{
    fn into_into_dart(self) -> FrbWrapper<shared::PaymentPreimage> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::PaymentStatus> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            ldk_adapter::types::PaymentStatus::Pending => 0.into_dart(),
            ldk_adapter::types::PaymentStatus::Succeeded => 1.into_dart(),
            ldk_adapter::types::PaymentStatus::Failed => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::PaymentStatus>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::PaymentStatus>>
    for ldk_adapter::types::PaymentStatus
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::PaymentStatus> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Psbt> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.inner.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Psbt> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Psbt>> for shared::Psbt {
    fn into_into_dart(self) -> FrbWrapper<shared::Psbt> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::PublicKey> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.hex.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::PublicKey> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::PublicKey>> for shared::PublicKey {
    fn into_into_dart(self) -> FrbWrapper<shared::PublicKey> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Refund> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.s.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Refund> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Refund>> for shared::Refund {
    fn into_into_dart(self) -> FrbWrapper<shared::Refund> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::graph::RoutingFees> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.base_msat.into_into_dart().into_dart(),
            self.0.proportional_millionths.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::graph::RoutingFees>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::graph::RoutingFees>>
    for ldk_adapter::graph::RoutingFees
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::graph::RoutingFees> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::ScriptBuf> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.inner.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::ScriptBuf> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::ScriptBuf>> for shared::ScriptBuf {
    fn into_into_dart(self) -> FrbWrapper<shared::ScriptBuf> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::SendingParameters> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0
                .max_total_routing_fee_msat
                .into_into_dart()
                .into_dart(),
            self.0
                .max_total_cltv_expiry_delta
                .into_into_dart()
                .into_dart(),
            self.0.max_path_count.into_into_dart().into_dart(),
            self.0
                .max_channel_saturation_power_of_half
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<shared::SendingParameters>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::SendingParameters>>
    for shared::SendingParameters
{
    fn into_into_dart(self) -> FrbWrapper<shared::SendingParameters> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::TxIn> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.previous_output.into_into_dart().into_dart(),
            self.0.script_sig.into_into_dart().into_dart(),
            self.0.sequence.into_into_dart().into_dart(),
            self.0.witness.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::TxIn> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::TxIn>> for shared::TxIn {
    fn into_into_dart(self) -> FrbWrapper<shared::TxIn> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::TxOut> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.0.value.into_into_dart().into_dart(),
            self.0.script_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::TxOut> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::TxOut>> for shared::TxOut {
    fn into_into_dart(self) -> FrbWrapper<shared::TxOut> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::Txid> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.hash.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::Txid> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::Txid>> for shared::Txid {
    fn into_into_dart(self) -> FrbWrapper<shared::Txid> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<ldk_adapter::types::UserChannelId> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.data.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<ldk_adapter::types::UserChannelId>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<ldk_adapter::types::UserChannelId>>
    for ldk_adapter::types::UserChannelId
{
    fn into_into_dart(self) -> FrbWrapper<ldk_adapter::types::UserChannelId> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<shared::WTxid> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.0.hash.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<shared::WTxid> {}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<shared::WTxid>> for shared::WTxid {
    fn into_into_dart(self) -> FrbWrapper<shared::WTxid> {
        self.into()
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for AddressData {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for BitcoinAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for BitcoinAddressInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for BitcoinTransactionInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Bolt11Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Bolt12Payment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Builder {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ChainDataSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for ChannelConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for ChannelDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for EntropySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Event {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for GossipSourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for LightningBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for MaxDustHTLCExposure {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for NetworkGraph {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for Node {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for OnChainPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PaymentDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PaymentKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PeerDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for PendingSweepBalance {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for QrPaymentResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for SocketAddress {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for SpontaneousPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for TaprootSpendInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for TaprootSpendInfoInner {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
        >>::sse_encode(
            flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self),
            serializer,
        );
    }
}

impl SseEncode for Transaction {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for UnifiedQrPayment {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, StdArc<_>>(self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, String)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<
        flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for ldk_adapter::types::AnchorChannelsConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<shared::PublicKey>>::sse_encode(self.trusted_peers_no_reserve, serializer);
        <u64>::sse_encode(self.per_channel_reserve_sats, serializer);
    }
}

impl SseEncode for ldk_adapter::types::BalanceDetails {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.total_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.spendable_onchain_balance_sats, serializer);
        <u64>::sse_encode(self.total_lightning_balance_sats, serializer);
        <Vec<LightningBalance>>::sse_encode(self.lightning_balances, serializer);
        <Vec<PendingSweepBalance>>::sse_encode(
            self.pending_balances_from_channel_closures,
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::BestBlock {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.block_hash, serializer);
        <u32>::sse_encode(self.height, serializer);
    }
}

impl SseEncode for shared::Bolt11Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.signed_raw_invoice, serializer);
    }
}

impl SseEncode for shared::Bolt12Invoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for ldk_adapter::types::ChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::ChannelInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <ldk_adapter::graph::NodeId>::sse_encode(self.node_one, serializer);
        <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_encode(self.one_to_two, serializer);
        <ldk_adapter::graph::NodeId>::sse_encode(self.node_two, serializer);
        <Option<ldk_adapter::graph::ChannelUpdateInfo>>::sse_encode(self.two_to_one, serializer);
        <Option<u64>>::sse_encode(self.capacity_sats, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::ChannelUpdateInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.last_update, serializer);
        <bool>::sse_encode(self.enabled, serializer);
        <u16>::sse_encode(self.cltv_expiry_delta, serializer);
        <u64>::sse_encode(self.htlc_minimum_msat, serializer);
        <u64>::sse_encode(self.htlc_maximum_msat, serializer);
        <ldk_adapter::graph::RoutingFees>::sse_encode(self.fees, serializer);
    }
}

impl SseEncode for ldk_adapter::types::Config {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.storage_dir_path, serializer);
        <shared::Network>::sse_encode(self.network, serializer);
        <Option<Vec<SocketAddress>>>::sse_encode(self.listening_addresses, serializer);
        <Option<Vec<SocketAddress>>>::sse_encode(self.announcement_addresses, serializer);
        <Option<ldk_adapter::types::NodeAlias>>::sse_encode(self.node_alias, serializer);
        <Vec<shared::PublicKey>>::sse_encode(self.trusted_peers_0conf, serializer);
        <u64>::sse_encode(self.probing_liquidity_limit_multiplier, serializer);
        <Option<ldk_adapter::types::AnchorChannelsConfig>>::sse_encode(
            self.anchor_channels_config,
            serializer,
        );
        <Option<shared::SendingParameters>>::sse_encode(self.sending_parameters, serializer);
    }
}

impl SseEncode for ldk_adapter::types::CustomTlvRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.type_num, serializer);
        <Vec<u8>>::sse_encode(self.value, serializer);
    }
}

impl SseEncode for ldk_adapter::types::FfiLogRecord {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <ldk_adapter::types::LogLevel>::sse_encode(self.level, serializer);
        <String>::sse_encode(self.args, serializer);
        <String>::sse_encode(self.module_path, serializer);
        <u32>::sse_encode(self.line, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for ldk_adapter::types::LiquiditySourceConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <(SocketAddress, shared::PublicKey, Option<String>)>::sse_encode(
            self.lsps2_service,
            serializer,
        );
    }
}

impl SseEncode for Vec<ChannelDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ChannelDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<LightningBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <LightningBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <PaymentDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<PeerDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <PeerDetails>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<PendingSweepBalance> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <PendingSweepBalance>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<SocketAddress> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <SocketAddress>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ldk_adapter::types::CustomTlvRecord> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ldk_adapter::types::CustomTlvRecord>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Vec<u8>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<ldk_adapter::graph::NodeId> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <ldk_adapter::graph::NodeId>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<shared::PublicKey> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <shared::PublicKey>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<shared::TxIn> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <shared::TxIn>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<shared::TxOut> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <shared::TxOut>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for ldk_adapter::types::LogLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::LogLevel::Gossip => 0,
                ldk_adapter::types::LogLevel::Trace => 1,
                ldk_adapter::types::LogLevel::Debug => 2,
                ldk_adapter::types::LogLevel::Info => 3,
                ldk_adapter::types::LogLevel::Warn => 4,
                ldk_adapter::types::LogLevel::Error => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for shared::Mnemonic {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<String>>::sse_encode(self.words, serializer);
    }
}

impl SseEncode for shared::Network {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                shared::Network::Bitcoin => 0,
                shared::Network::Testnet => 1,
                shared::Network::Testnet4 => 2,
                shared::Network::Signet => 3,
                shared::Network::Regtest => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::NodeAlias {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.0, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::NodeAnnouncementInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.last_update, serializer);
        <String>::sse_encode(self.alias, serializer);
        <Vec<SocketAddress>>::sse_encode(self.addresses, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::NodeId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.compressed, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::NodeInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u64>>::sse_encode(self.channels, serializer);
        <Option<ldk_adapter::graph::NodeAnnouncementInfo>>::sse_encode(
            self.announcement_info,
            serializer,
        );
    }
}

impl SseEncode for ldk_adapter::types::NodeStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_running, serializer);
        <bool>::sse_encode(self.is_listening, serializer);
        <ldk_adapter::types::BestBlock>::sse_encode(self.current_best_block, serializer);
        <Option<u64>>::sse_encode(self.latest_lightning_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_onchain_wallet_sync_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_fee_rate_cache_update_timestamp, serializer);
        <Option<u64>>::sse_encode(self.latest_rgs_snapshot_timestamp, serializer);
        <Option<u64>>::sse_encode(
            self.latest_node_announcement_broadcast_timestamp,
            serializer,
        );
        <Option<u32>>::sse_encode(self.latest_channel_monitor_archival_height, serializer);
    }
}

impl SseEncode for shared::Offer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ChainDataSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ChainDataSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ChannelConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ChannelConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<EntropySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <EntropySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Event> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Event>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<GossipSourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <GossipSourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<PaymentDetails> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <PaymentDetails>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::AnchorChannelsConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::AnchorChannelsConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::ChannelInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::ChannelInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::ChannelUpdateInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::ChannelUpdateInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::LiquiditySourceConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::LiquiditySourceConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::LogLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::LogLevel>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::types::NodeAlias> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::types::NodeAlias>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::NodeAnnouncementInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::NodeAnnouncementInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<ldk_adapter::graph::NodeInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <ldk_adapter::graph::NodeInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<shared::OutPoint> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <shared::OutPoint>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<shared::SendingParameters> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <shared::SendingParameters>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u16>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<SocketAddress>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<SocketAddress>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for shared::OutPoint {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <shared::Txid>::sse_encode(self.txid, serializer);
        <u32>::sse_encode(self.vout, serializer);
    }
}

impl SseEncode for ldk_adapter::types::PaymentDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::PaymentDirection::Inbound => 0,
                ldk_adapter::types::PaymentDirection::Outbound => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for shared::PaymentHash {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for shared::PaymentId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for shared::PaymentPreimage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <[u8; 32]>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for ldk_adapter::types::PaymentStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                ldk_adapter::types::PaymentStatus::Pending => 0,
                ldk_adapter::types::PaymentStatus::Succeeded => 1,
                ldk_adapter::types::PaymentStatus::Failed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for shared::Psbt {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for shared::PublicKey {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hex, serializer);
    }
}

impl SseEncode for (SocketAddress, shared::PublicKey, Option<String>) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <SocketAddress>::sse_encode(self.0, serializer);
        <shared::PublicKey>::sse_encode(self.1, serializer);
        <Option<String>>::sse_encode(self.2, serializer);
    }
}

impl SseEncode for (String, String) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for shared::Refund {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.s, serializer);
    }
}

impl SseEncode for ldk_adapter::graph::RoutingFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.base_msat, serializer);
        <u32>::sse_encode(self.proportional_millionths, serializer);
    }
}

impl SseEncode for shared::ScriptBuf {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.inner, serializer);
    }
}

impl SseEncode for shared::SendingParameters {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<u64>>::sse_encode(self.max_total_routing_fee_msat, serializer);
        <Option<u32>>::sse_encode(self.max_total_cltv_expiry_delta, serializer);
        <Option<u8>>::sse_encode(self.max_path_count, serializer);
        <Option<u8>>::sse_encode(self.max_channel_saturation_power_of_half, serializer);
    }
}

impl SseEncode for shared::TxIn {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <shared::OutPoint>::sse_encode(self.previous_output, serializer);
        <shared::ScriptBuf>::sse_encode(self.script_sig, serializer);
        <u32>::sse_encode(self.sequence, serializer);
        <Vec<Vec<u8>>>::sse_encode(self.witness, serializer);
    }
}

impl SseEncode for shared::TxOut {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.value, serializer);
        <shared::ScriptBuf>::sse_encode(self.script_pubkey, serializer);
    }
}

impl SseEncode for shared::Txid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for [u8; 32] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for [u8; 64] {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(
            {
                let boxed: Box<[_]> = Box::new(self);
                boxed.into_vec()
            },
            serializer,
        );
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for ldk_adapter::types::UserChannelId {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.data, serializer);
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for shared::WTxid {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.hash, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};
    use ldk_adapter::bolt11::*;
    use ldk_adapter::bolt12::*;
    use ldk_adapter::builder::*;
    use ldk_adapter::graph::*;
    use ldk_adapter::node::*;
    use ldk_adapter::on_chain::*;
    use ldk_adapter::spontaneous::*;
    use ldk_adapter::types::*;
    use ldk_adapter::unified_qr::*;
    use shared::*;

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<flutter_rust_bridge::for_generated::anyhow::Error>
        for *mut wire_cst_list_prim_u_8_strict
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> flutter_rust_bridge::for_generated::anyhow::Error {
            unimplemented!()
        }
    }
    impl CstDecode<AddressData> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> AddressData {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<BitcoinAddress> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> BitcoinAddress {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<BitcoinAddressInner> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> BitcoinAddressInner {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<BitcoinTransactionInner> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> BitcoinTransactionInner {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<
                        BitcoinTransactionInner,
                    >,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Bolt11Payment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Bolt11Payment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Bolt12Payment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Bolt12Payment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Builder> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Builder {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ChainDataSourceConfig> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChainDataSourceConfig {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ChannelConfig> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelConfig {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<ChannelDetails> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelDetails {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<EntropySourceConfig> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> EntropySourceConfig {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Event> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Event {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<GossipSourceConfig> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> GossipSourceConfig {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<LightningBalance> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> LightningBalance {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<MaxDustHTLCExposure> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> MaxDustHTLCExposure {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<NetworkGraph> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> NetworkGraph {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Node> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Node {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<OnChainPayment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> OnChainPayment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PaymentDetails> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PaymentDetails {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PaymentKind> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PaymentKind {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PeerDetails> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PeerDetails {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<PendingSweepBalance> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PendingSweepBalance {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<QrPaymentResult> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> QrPaymentResult {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<SocketAddress> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> SocketAddress {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<SpontaneousPayment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> SpontaneousPayment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<TaprootSpendInfo> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> TaprootSpendInfo {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<TaprootSpendInfoInner> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> TaprootSpendInfoInner {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<Transaction> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Transaction {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<UnifiedQrPayment> for usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> UnifiedQrPayment {
            flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(CstDecode::<
                RustOpaqueNom<
                    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>,
                >,
            >::cst_decode(
                self
            ))
        }
    }
    impl CstDecode<std::collections::HashMap<String, String>>
        for *mut wire_cst_list_record_string_string
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> std::collections::HashMap<String, String> {
            let vec: Vec<(String, String)> = self.cst_decode();
            vec.into_iter().collect()
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>>
        for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>> {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>,
        > {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl
        CstDecode<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>,
            >,
        > for usize
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(
            self,
        ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>
        {
            unsafe { decode_rust_opaque_nom(self as _) }
        }
    }
    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<ldk_adapter::types::AnchorChannelsConfig> for wire_cst_anchor_channels_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::AnchorChannelsConfig {
            ldk_adapter::types::AnchorChannelsConfig {
                trusted_peers_no_reserve: self.trusted_peers_no_reserve.cst_decode(),
                per_channel_reserve_sats: self.per_channel_reserve_sats.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::BalanceDetails> for wire_cst_balance_details {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::BalanceDetails {
            ldk_adapter::types::BalanceDetails {
                total_onchain_balance_sats: self.total_onchain_balance_sats.cst_decode(),
                spendable_onchain_balance_sats: self.spendable_onchain_balance_sats.cst_decode(),
                total_lightning_balance_sats: self.total_lightning_balance_sats.cst_decode(),
                lightning_balances: self.lightning_balances.cst_decode(),
                pending_balances_from_channel_closures: self
                    .pending_balances_from_channel_closures
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::BestBlock> for wire_cst_best_block {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::BestBlock {
            ldk_adapter::types::BestBlock {
                block_hash: self.block_hash.cst_decode(),
                height: self.height.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Bolt11Invoice> for wire_cst_bolt_11_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Bolt11Invoice {
            shared::Bolt11Invoice {
                signed_raw_invoice: self.signed_raw_invoice.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Bolt12Invoice> for wire_cst_bolt_12_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Bolt12Invoice {
            shared::Bolt12Invoice {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<ChainDataSourceConfig> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChainDataSourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ChainDataSourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ChannelConfig> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ChannelConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ChannelConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<EntropySourceConfig> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> EntropySourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<EntropySourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<Event> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Event {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<Event>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<GossipSourceConfig> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> GossipSourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<GossipSourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<PaymentDetails> for *mut usize {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> PaymentDetails {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<PaymentDetails>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::AnchorChannelsConfig> for *mut wire_cst_anchor_channels_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::AnchorChannelsConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::AnchorChannelsConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Bolt11Invoice> for *mut wire_cst_bolt_11_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Bolt11Invoice {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Bolt11Invoice>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelInfo> for *mut wire_cst_channel_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::ChannelInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelUpdateInfo> for *mut wire_cst_channel_update_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelUpdateInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::ChannelUpdateInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::Config> for *mut wire_cst_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::Config {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::Config>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::FfiLogRecord> for *mut wire_cst_ffi_log_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::FfiLogRecord {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::FfiLogRecord>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::LiquiditySourceConfig>
        for *mut wire_cst_liquidity_source_config
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LiquiditySourceConfig {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::LiquiditySourceConfig>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::LogLevel> for *mut i32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LogLevel {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::LogLevel>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Mnemonic> for *mut wire_cst_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Mnemonic {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Mnemonic>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::NodeAlias> for *mut wire_cst_node_alias {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::NodeAlias {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::NodeAlias>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeAnnouncementInfo> for *mut wire_cst_node_announcement_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeAnnouncementInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::NodeAnnouncementInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeId> for *mut wire_cst_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::NodeId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeInfo> for *mut wire_cst_node_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeInfo {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::graph::NodeInfo>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Offer> for *mut wire_cst_offer {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Offer {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Offer>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::OutPoint> for *mut wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::OutPoint {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::OutPoint>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::PaymentHash> for *mut wire_cst_payment_hash {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentHash {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::PaymentHash>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::PaymentId> for *mut wire_cst_payment_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::PaymentId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::PaymentPreimage> for *mut wire_cst_payment_preimage {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentPreimage {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::PaymentPreimage>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Psbt> for *mut wire_cst_psbt {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Psbt {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Psbt>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::PublicKey> for *mut wire_cst_public_key {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PublicKey {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::PublicKey>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::Refund> for *mut wire_cst_refund {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Refund {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::Refund>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::ScriptBuf> for *mut wire_cst_script_buf {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::ScriptBuf {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::ScriptBuf>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<shared::SendingParameters> for *mut wire_cst_sending_parameters {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::SendingParameters {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<shared::SendingParameters>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<u16> for *mut u16 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u16 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u32> for *mut u32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u64> for *mut u64 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<u8> for *mut u8 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            unsafe { *flutter_rust_bridge::for_generated::box_from_leak_ptr(self) }
        }
    }
    impl CstDecode<ldk_adapter::types::UserChannelId> for *mut wire_cst_user_channel_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::UserChannelId {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<ldk_adapter::types::UserChannelId>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<ldk_adapter::types::ChannelId> for wire_cst_channel_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::ChannelId {
            ldk_adapter::types::ChannelId {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelInfo> for wire_cst_channel_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelInfo {
            ldk_adapter::graph::ChannelInfo {
                node_one: self.node_one.cst_decode(),
                one_to_two: self.one_to_two.cst_decode(),
                node_two: self.node_two.cst_decode(),
                two_to_one: self.two_to_one.cst_decode(),
                capacity_sats: self.capacity_sats.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::ChannelUpdateInfo> for wire_cst_channel_update_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::ChannelUpdateInfo {
            ldk_adapter::graph::ChannelUpdateInfo {
                last_update: self.last_update.cst_decode(),
                enabled: self.enabled.cst_decode(),
                cltv_expiry_delta: self.cltv_expiry_delta.cst_decode(),
                htlc_minimum_msat: self.htlc_minimum_msat.cst_decode(),
                htlc_maximum_msat: self.htlc_maximum_msat.cst_decode(),
                fees: self.fees.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::Config> for wire_cst_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::Config {
            ldk_adapter::types::Config {
                storage_dir_path: self.storage_dir_path.cst_decode(),
                network: self.network.cst_decode(),
                listening_addresses: self.listening_addresses.cst_decode(),
                announcement_addresses: self.announcement_addresses.cst_decode(),
                node_alias: self.node_alias.cst_decode(),
                trusted_peers_0conf: self.trusted_peers_0conf.cst_decode(),
                probing_liquidity_limit_multiplier: self
                    .probing_liquidity_limit_multiplier
                    .cst_decode(),
                anchor_channels_config: self.anchor_channels_config.cst_decode(),
                sending_parameters: self.sending_parameters.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::CustomTlvRecord> for wire_cst_custom_tlv_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::CustomTlvRecord {
            ldk_adapter::types::CustomTlvRecord {
                type_num: self.type_num.cst_decode(),
                value: self.value.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::FfiLogRecord> for wire_cst_ffi_log_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::FfiLogRecord {
            ldk_adapter::types::FfiLogRecord {
                level: self.level.cst_decode(),
                args: self.args.cst_decode(),
                module_path: self.module_path.cst_decode(),
                line: self.line.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::LiquiditySourceConfig> for wire_cst_liquidity_source_config {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::LiquiditySourceConfig {
            ldk_adapter::types::LiquiditySourceConfig {
                lsps2_service: self.lsps2_service.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<ChannelDetails>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<ChannelDetails> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<LightningBalance>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<LightningBalance> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<PaymentDetails>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<PaymentDetails> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<PeerDetails>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<PeerDetails> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<PendingSweepBalance>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<PendingSweepBalance> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<SocketAddress>> for *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> Vec<SocketAddress> {
                let vec = unsafe {
        let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
        flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
    };
    vec.into_iter().map(CstDecode::cst_decode).collect()
            }
        }
    impl CstDecode<Vec<String>> for *mut wire_cst_list_String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<String> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<ldk_adapter::types::CustomTlvRecord>> for *mut wire_cst_list_custom_tlv_record {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<ldk_adapter::types::CustomTlvRecord> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<Vec<u8>>> for *mut wire_cst_list_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<Vec<u8>> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<ldk_adapter::graph::NodeId>> for *mut wire_cst_list_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<ldk_adapter::graph::NodeId> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<u64>> for *mut wire_cst_list_prim_u_64_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u64> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<Vec<shared::PublicKey>> for *mut wire_cst_list_public_key {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<shared::PublicKey> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<(String, String)>> for *mut wire_cst_list_record_string_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<(String, String)> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<shared::TxIn>> for *mut wire_cst_list_tx_in {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<shared::TxIn> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<Vec<shared::TxOut>> for *mut wire_cst_list_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<shared::TxOut> {
            let vec = unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            };
            vec.into_iter().map(CstDecode::cst_decode).collect()
        }
    }
    impl CstDecode<shared::Mnemonic> for wire_cst_mnemonic {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Mnemonic {
            shared::Mnemonic {
                words: self.words.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::NodeAlias> for wire_cst_node_alias {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::NodeAlias {
            ldk_adapter::types::NodeAlias(self.field0.cst_decode())
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeAnnouncementInfo> for wire_cst_node_announcement_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeAnnouncementInfo {
            ldk_adapter::graph::NodeAnnouncementInfo {
                last_update: self.last_update.cst_decode(),
                alias: self.alias.cst_decode(),
                addresses: self.addresses.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeId> for wire_cst_node_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeId {
            ldk_adapter::graph::NodeId {
                compressed: self.compressed.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::NodeInfo> for wire_cst_node_info {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::NodeInfo {
            ldk_adapter::graph::NodeInfo {
                channels: self.channels.cst_decode(),
                announcement_info: self.announcement_info.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::types::NodeStatus> for wire_cst_node_status {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::NodeStatus {
            ldk_adapter::types::NodeStatus {
                is_running: self.is_running.cst_decode(),
                is_listening: self.is_listening.cst_decode(),
                current_best_block: self.current_best_block.cst_decode(),
                latest_lightning_wallet_sync_timestamp: self
                    .latest_lightning_wallet_sync_timestamp
                    .cst_decode(),
                latest_onchain_wallet_sync_timestamp: self
                    .latest_onchain_wallet_sync_timestamp
                    .cst_decode(),
                latest_fee_rate_cache_update_timestamp: self
                    .latest_fee_rate_cache_update_timestamp
                    .cst_decode(),
                latest_rgs_snapshot_timestamp: self.latest_rgs_snapshot_timestamp.cst_decode(),
                latest_node_announcement_broadcast_timestamp: self
                    .latest_node_announcement_broadcast_timestamp
                    .cst_decode(),
                latest_channel_monitor_archival_height: self
                    .latest_channel_monitor_archival_height
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Offer> for wire_cst_offer {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Offer {
            shared::Offer {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::OutPoint> for wire_cst_out_point {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::OutPoint {
            shared::OutPoint {
                txid: self.txid.cst_decode(),
                vout: self.vout.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::PaymentHash> for wire_cst_payment_hash {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentHash {
            shared::PaymentHash {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::PaymentId> for wire_cst_payment_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentId {
            shared::PaymentId {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::PaymentPreimage> for wire_cst_payment_preimage {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PaymentPreimage {
            shared::PaymentPreimage {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Psbt> for wire_cst_psbt {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Psbt {
            shared::Psbt {
                inner: self.inner.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::PublicKey> for wire_cst_public_key {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::PublicKey {
            shared::PublicKey {
                hex: self.hex.cst_decode(),
            }
        }
    }
    impl CstDecode<(SocketAddress,shared::PublicKey,Option<String>,)> for wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_public_key_opt_string {
            // Codec=Cst (C-struct based), see doc to use other codecs
            fn cst_decode(self) -> (SocketAddress,shared::PublicKey,Option<String>,) {
                (self.field0.cst_decode(),self.field1.cst_decode(),self.field2.cst_decode(),)
            }
        }
    impl CstDecode<(String, String)> for wire_cst_record_string_string {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> (String, String) {
            (self.field0.cst_decode(), self.field1.cst_decode())
        }
    }
    impl CstDecode<shared::Refund> for wire_cst_refund {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Refund {
            shared::Refund {
                s: self.s.cst_decode(),
            }
        }
    }
    impl CstDecode<ldk_adapter::graph::RoutingFees> for wire_cst_routing_fees {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::graph::RoutingFees {
            ldk_adapter::graph::RoutingFees {
                base_msat: self.base_msat.cst_decode(),
                proportional_millionths: self.proportional_millionths.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::ScriptBuf> for wire_cst_script_buf {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::ScriptBuf {
            shared::ScriptBuf {
                inner: self.inner.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::SendingParameters> for wire_cst_sending_parameters {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::SendingParameters {
            shared::SendingParameters {
                max_total_routing_fee_msat: self.max_total_routing_fee_msat.cst_decode(),
                max_total_cltv_expiry_delta: self.max_total_cltv_expiry_delta.cst_decode(),
                max_path_count: self.max_path_count.cst_decode(),
                max_channel_saturation_power_of_half: self
                    .max_channel_saturation_power_of_half
                    .cst_decode(),
            }
        }
    }
    impl CstDecode<shared::TxIn> for wire_cst_tx_in {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::TxIn {
            shared::TxIn {
                previous_output: self.previous_output.cst_decode(),
                script_sig: self.script_sig.cst_decode(),
                sequence: self.sequence.cst_decode(),
                witness: self.witness.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::TxOut> for wire_cst_tx_out {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::TxOut {
            shared::TxOut {
                value: self.value.cst_decode(),
                script_pubkey: self.script_pubkey.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::Txid> for wire_cst_txid {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::Txid {
            shared::Txid {
                hash: self.hash.cst_decode(),
            }
        }
    }
    impl CstDecode<[u8; 32]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 32] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<[u8; 64]> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> [u8; 64] {
            let vec: Vec<u8> = self.cst_decode();
            flutter_rust_bridge::for_generated::from_vec_to_array(vec)
        }
    }
    impl CstDecode<ldk_adapter::types::UserChannelId> for wire_cst_user_channel_id {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> ldk_adapter::types::UserChannelId {
            ldk_adapter::types::UserChannelId {
                data: self.data.cst_decode(),
            }
        }
    }
    impl CstDecode<shared::WTxid> for wire_cst_w_txid {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> shared::WTxid {
            shared::WTxid {
                hash: self.hash.cst_decode(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_anchor_channels_config {
        fn new_with_null_ptr() -> Self {
            Self {
                trusted_peers_no_reserve: core::ptr::null_mut(),
                per_channel_reserve_sats: Default::default(),
            }
        }
    }
    impl Default for wire_cst_anchor_channels_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_balance_details {
        fn new_with_null_ptr() -> Self {
            Self {
                total_onchain_balance_sats: Default::default(),
                spendable_onchain_balance_sats: Default::default(),
                total_lightning_balance_sats: Default::default(),
                lightning_balances: core::ptr::null_mut(),
                pending_balances_from_channel_closures: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_balance_details {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_best_block {
        fn new_with_null_ptr() -> Self {
            Self {
                block_hash: core::ptr::null_mut(),
                height: Default::default(),
            }
        }
    }
    impl Default for wire_cst_best_block {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bolt_11_invoice {
        fn new_with_null_ptr() -> Self {
            Self {
                signed_raw_invoice: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bolt_11_invoice {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_bolt_12_invoice {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_bolt_12_invoice {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_id {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_channel_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_info {
        fn new_with_null_ptr() -> Self {
            Self {
                node_one: Default::default(),
                one_to_two: core::ptr::null_mut(),
                node_two: Default::default(),
                two_to_one: core::ptr::null_mut(),
                capacity_sats: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_channel_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_channel_update_info {
        fn new_with_null_ptr() -> Self {
            Self {
                last_update: Default::default(),
                enabled: Default::default(),
                cltv_expiry_delta: Default::default(),
                htlc_minimum_msat: Default::default(),
                htlc_maximum_msat: Default::default(),
                fees: Default::default(),
            }
        }
    }
    impl Default for wire_cst_channel_update_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_config {
        fn new_with_null_ptr() -> Self {
            Self {
                storage_dir_path: core::ptr::null_mut(),
                network: Default::default(),
                listening_addresses: core::ptr::null_mut(),
                announcement_addresses: core::ptr::null_mut(),
                node_alias: core::ptr::null_mut(),
                trusted_peers_0conf: core::ptr::null_mut(),
                probing_liquidity_limit_multiplier: Default::default(),
                anchor_channels_config: core::ptr::null_mut(),
                sending_parameters: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_custom_tlv_record {
        fn new_with_null_ptr() -> Self {
            Self {
                type_num: Default::default(),
                value: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_custom_tlv_record {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_ffi_log_record {
        fn new_with_null_ptr() -> Self {
            Self {
                level: Default::default(),
                args: core::ptr::null_mut(),
                module_path: core::ptr::null_mut(),
                line: Default::default(),
            }
        }
    }
    impl Default for wire_cst_ffi_log_record {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_liquidity_source_config {
        fn new_with_null_ptr() -> Self {
            Self {
                lsps2_service: Default::default(),
            }
        }
    }
    impl Default for wire_cst_liquidity_source_config {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_mnemonic {
        fn new_with_null_ptr() -> Self {
            Self {
                words: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_mnemonic {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_alias {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_alias {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_announcement_info {
        fn new_with_null_ptr() -> Self {
            Self {
                last_update: Default::default(),
                alias: core::ptr::null_mut(),
                addresses: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_announcement_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_id {
        fn new_with_null_ptr() -> Self {
            Self {
                compressed: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_info {
        fn new_with_null_ptr() -> Self {
            Self {
                channels: core::ptr::null_mut(),
                announcement_info: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_info {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_node_status {
        fn new_with_null_ptr() -> Self {
            Self {
                is_running: Default::default(),
                is_listening: Default::default(),
                current_best_block: Default::default(),
                latest_lightning_wallet_sync_timestamp: core::ptr::null_mut(),
                latest_onchain_wallet_sync_timestamp: core::ptr::null_mut(),
                latest_fee_rate_cache_update_timestamp: core::ptr::null_mut(),
                latest_rgs_snapshot_timestamp: core::ptr::null_mut(),
                latest_node_announcement_broadcast_timestamp: core::ptr::null_mut(),
                latest_channel_monitor_archival_height: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_node_status {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_offer {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_offer {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_out_point {
        fn new_with_null_ptr() -> Self {
            Self {
                txid: Default::default(),
                vout: Default::default(),
            }
        }
    }
    impl Default for wire_cst_out_point {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_hash {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_hash {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_id {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_payment_preimage {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_payment_preimage {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_psbt {
        fn new_with_null_ptr() -> Self {
            Self {
                inner: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_psbt {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_public_key {
        fn new_with_null_ptr() -> Self {
            Self {
                hex: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_public_key {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_public_key_opt_string {
            fn new_with_null_ptr() -> Self {
                Self { field0: Default::default(),
field1: Default::default(),
field2: core::ptr::null_mut(), }
            }
        }
    impl Default for wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_public_key_opt_string {
            fn default() -> Self {
                Self::new_with_null_ptr()
            }
        }
    impl NewWithNullPtr for wire_cst_record_string_string {
        fn new_with_null_ptr() -> Self {
            Self {
                field0: core::ptr::null_mut(),
                field1: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_record_string_string {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_refund {
        fn new_with_null_ptr() -> Self {
            Self {
                s: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_refund {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_routing_fees {
        fn new_with_null_ptr() -> Self {
            Self {
                base_msat: Default::default(),
                proportional_millionths: Default::default(),
            }
        }
    }
    impl Default for wire_cst_routing_fees {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_script_buf {
        fn new_with_null_ptr() -> Self {
            Self {
                inner: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_script_buf {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sending_parameters {
        fn new_with_null_ptr() -> Self {
            Self {
                max_total_routing_fee_msat: core::ptr::null_mut(),
                max_total_cltv_expiry_delta: core::ptr::null_mut(),
                max_path_count: core::ptr::null_mut(),
                max_channel_saturation_power_of_half: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_sending_parameters {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_in {
        fn new_with_null_ptr() -> Self {
            Self {
                previous_output: Default::default(),
                script_sig: Default::default(),
                sequence: Default::default(),
                witness: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_tx_in {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_out {
        fn new_with_null_ptr() -> Self {
            Self {
                value: Default::default(),
                script_pubkey: Default::default(),
            }
        }
    }
    impl Default for wire_cst_tx_out {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_txid {
        fn new_with_null_ptr() -> Self {
            Self {
                hash: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_txid {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_user_channel_id {
        fn new_with_null_ptr() -> Self {
            Self {
                data: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_user_channel_id {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_w_txid {
        fn new_with_null_ptr() -> Self {
            Self {
                hash: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_w_txid {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_auto_accessor_get_inner(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__BitcoinAddress_auto_accessor_get_inner_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_auto_accessor_set_inner(
        that: usize,
        inner: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__BitcoinAddress_auto_accessor_set_inner_impl(that, inner)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_from_script(
        port_: i64,
        script: *mut wire_cst_script_buf,
        network: i32,
    ) {
        wire__shared__BitcoinAddress_from_script_impl(port_, script, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_is_valid_for_network(
        port_: i64,
        that: usize,
        network: i32,
    ) {
        wire__shared__BitcoinAddress_is_valid_for_network_impl(port_, that, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_new(
        port_: i64,
        address: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
    ) {
        wire__shared__BitcoinAddress_new_impl(port_, address, network)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_script_pubkey(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_script_pubkey_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_to_address_data(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_to_address_data_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__BitcoinAddress_to_qr_uri(
        port_: i64,
        that: usize,
    ) {
        wire__shared__BitcoinAddress_to_qr_uri_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_claim_for_hash(
        port_: i64,
        that: usize,
        payment_hash: *mut wire_cst_payment_hash,
        claimable_amount_msat: u64,
        preimage: *mut wire_cst_payment_preimage,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_claim_for_hash_impl(
            port_,
            that,
            payment_hash,
            claimable_amount_msat,
            preimage,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_fail_for_hash(
        port_: i64,
        that: usize,
        payment_hash: *mut wire_cst_payment_hash,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_fail_for_hash_impl(port_, that, payment_hash)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive(
        port_: i64,
        that: usize,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_for_hash(
        port_: i64,
        that: usize,
        payment_hash: *mut wire_cst_payment_hash,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_for_hash_impl(
            port_,
            that,
            payment_hash,
            amount_msat,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_impl(
            port_,
            that,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_for_hash(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        payment_hash: *mut wire_cst_payment_hash,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_for_hash_impl(
            port_,
            that,
            description,
            expiry_secs,
            payment_hash,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_via_jit_channel(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        max_proportional_lsp_fee_limit_ppm_msat: *mut u64,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_variable_amount_via_jit_channel_impl(
            port_,
            that,
            description,
            expiry_secs,
            max_proportional_lsp_fee_limit_ppm_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_receive_via_jit_channel(
        port_: i64,
        that: usize,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: u32,
        max_total_lsp_fee_limit_msat: *mut u64,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_receive_via_jit_channel_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
            max_total_lsp_fee_limit_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send(
        port_: i64,
        that: usize,
        invoice: *mut wire_cst_bolt_11_invoice,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_impl(port_, that, invoice, sending_parameters)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send_probes(
        port_: i64,
        that: usize,
        invoice: *mut wire_cst_bolt_11_invoice,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_impl(port_, that, invoice)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_using_amount(
        port_: i64,
        that: usize,
        invoice: *mut wire_cst_bolt_11_invoice,
        amount_msat: u64,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_probes_using_amount_impl(
            port_,
            that,
            invoice,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt11__Bolt11Payment_send_using_amount(
        port_: i64,
        that: usize,
        invoice: *mut wire_cst_bolt_11_invoice,
        amount_msat: u64,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__ldk_adapter__bolt11__Bolt11Payment_send_using_amount_impl(
            port_,
            that,
            invoice,
            amount_msat,
            sending_parameters,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_initiate_refund(
        port_: i64,
        that: usize,
        amount_msat: u64,
        expiry_secs: u32,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_initiate_refund_impl(
            port_,
            that,
            amount_msat,
            expiry_secs,
            quantity,
            payer_note,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_receive(
        port_: i64,
        that: usize,
        amount_msat: u64,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: *mut u32,
        quantity: *mut u64,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_receive_impl(
            port_,
            that,
            amount_msat,
            description,
            expiry_secs,
            quantity,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_receive_variable_amount(
        port_: i64,
        that: usize,
        description: *mut wire_cst_list_prim_u_8_strict,
        expiry_secs: *mut u32,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_receive_variable_amount_impl(
            port_,
            that,
            description,
            expiry_secs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_request_refund_payment(
        port_: i64,
        that: usize,
        refund: *mut wire_cst_refund,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_request_refund_payment_impl(port_, that, refund)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_send(
        port_: i64,
        that: usize,
        offer: *mut wire_cst_offer,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_send_impl(port_, that, offer, quantity, payer_note)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__bolt12__Bolt12Payment_send_using_amount(
        port_: i64,
        that: usize,
        offer: *mut wire_cst_offer,
        amount_msat: u64,
        quantity: *mut u64,
        payer_note: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__bolt12__Bolt12Payment_send_using_amount_impl(
            port_,
            that,
            offer,
            amount_msat,
            quantity,
            payer_note,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__Builder_build(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__builder__Builder_build_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__Builder_build_with_fs_store(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__builder__Builder_build_with_fs_store_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__Builder_build_with_vss_store(
        port_: i64,
        that: usize,
        vss_url: *mut wire_cst_list_prim_u_8_strict,
        store_id: *mut wire_cst_list_prim_u_8_strict,
        lnurl_auth_server_url: *mut wire_cst_list_prim_u_8_strict,
        fixed_headers: *mut wire_cst_list_record_string_string,
    ) {
        wire__ldk_adapter__builder__Builder_build_with_vss_store_impl(
            port_,
            that,
            vss_url,
            store_id,
            lnurl_auth_server_url,
            fixed_headers,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__Builder_build_with_vss_store_and_fixed_headers(
        port_: i64,
        that: usize,
        vss_url: *mut wire_cst_list_prim_u_8_strict,
        store_id: *mut wire_cst_list_prim_u_8_strict,
        fixed_headers: *mut wire_cst_list_record_string_string,
    ) {
        wire__ldk_adapter__builder__Builder_build_with_vss_store_and_fixed_headers_impl(
            port_,
            that,
            vss_url,
            store_id,
            fixed_headers,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__Builder_create_builder(
        port_: i64,
        config: *mut wire_cst_config,
        chain_data_source_config: *mut usize,
        entropy_source_config: *mut usize,
        gossip_source_config: *mut usize,
        liquidity_source_config: *mut wire_cst_liquidity_source_config,
    ) {
        wire__ldk_adapter__builder__Builder_create_builder_impl(
            port_,
            config,
            chain_data_source_config,
            entropy_source_config,
            gossip_source_config,
            liquidity_source_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__Builder_set_entropy_seed_bytes(
        port_: i64,
        that: usize,
        seed_bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__builder__Builder_set_entropy_seed_bytes_impl(port_, that, seed_bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__Builder_set_filesystem_logger(
        port_: i64,
        that: usize,
        log_file_path: *mut wire_cst_list_prim_u_8_strict,
        max_log_level: *mut i32,
    ) {
        wire__ldk_adapter__builder__Builder_set_filesystem_logger_impl(
            port_,
            that,
            log_file_path,
            max_log_level,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__builder__Builder_set_log_facade_logger(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__builder__Builder_set_log_facade_logger_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_accept_underpaying_htlcs(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_accept_underpaying_htlcs_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_cltv_expiry_delta(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_cltv_expiry_delta_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_force_close_avoidance_max_fee_satoshis_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_base_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_base_msat_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_forwarding_fee_proportional_millionths_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_max_dust_htlc_exposure(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_get_max_dust_htlc_exposure_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_accept_underpaying_htlcs(
        that: usize,
        accept_underpaying_htlcs: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_accept_underpaying_htlcs_impl(
            that,
            accept_underpaying_htlcs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_cltv_expiry_delta(
        that: usize,
        cltv_expiry_delta: u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_cltv_expiry_delta_impl(
            that,
            cltv_expiry_delta,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis(
        that: usize,
        force_close_avoidance_max_fee_satoshis: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_force_close_avoidance_max_fee_satoshis_impl(that, force_close_avoidance_max_fee_satoshis)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_base_msat(
        that: usize,
        forwarding_fee_base_msat: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_base_msat_impl(
            that,
            forwarding_fee_base_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths(
        that: usize,
        forwarding_fee_proportional_millionths: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_forwarding_fee_proportional_millionths_impl(that, forwarding_fee_proportional_millionths)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_max_dust_htlc_exposure(
        that: usize,
        max_dust_htlc_exposure: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelConfig_auto_accessor_set_max_dust_htlc_exposure_impl(
            that,
            max_dust_htlc_exposure,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_value_sats(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_channel_value_sats_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_cltv_expiry_delta(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_cltv_expiry_delta_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_config(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_config_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_required(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_confirmations_required_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_cltv_expiry_delta_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_base_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_forwarding_info_fee_proportional_millionths_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_node_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_node_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_maximum_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_outbound_htlc_minimum_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_counterparty_unspendable_punishment_reserve_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_feerate_sat_per_1000_weight_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_force_close_spend_delay(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_force_close_spend_delay_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_funding_txo(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_funding_txo_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_capacity_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_capacity_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_maximum_msat_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_inbound_htlc_minimum_msat_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_channel_ready(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_channel_ready_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_outbound(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_outbound_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_usable(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_is_usable_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_limit_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_next_outbound_htlc_minimum_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_outbound_capacity_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_outbound_capacity_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_unspendable_punishment_reserve(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_unspendable_punishment_reserve_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_user_channel_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_get_user_channel_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_id(
        that: usize,
        channel_id: wire_cst_channel_id,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_id_impl(that, channel_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_value_sats(
        that: usize,
        channel_value_sats: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_channel_value_sats_impl(
            that,
            channel_value_sats,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_cltv_expiry_delta(
        that: usize,
        cltv_expiry_delta: *mut u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_cltv_expiry_delta_impl(
            that,
            cltv_expiry_delta,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_config(
        that: usize,
        config: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_config_impl(that, config)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations(
        that: usize,
        confirmations: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_impl(
            that,
            confirmations,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_required(
        that: usize,
        confirmations_required: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_confirmations_required_impl(
            that,
            confirmations_required,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta(
        that: usize,
        counterparty_forwarding_info_cltv_expiry_delta: *mut u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_cltv_expiry_delta_impl(that, counterparty_forwarding_info_cltv_expiry_delta)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat(
        that: usize,
        counterparty_forwarding_info_fee_base_msat: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_base_msat_impl(that, counterparty_forwarding_info_fee_base_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths(
        that: usize,
        counterparty_forwarding_info_fee_proportional_millionths: *mut u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_forwarding_info_fee_proportional_millionths_impl(that, counterparty_forwarding_info_fee_proportional_millionths)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_node_id(
        that: usize,
        counterparty_node_id: wire_cst_public_key,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_node_id_impl(
            that,
            counterparty_node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat(
        that: usize,
        counterparty_outbound_htlc_maximum_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_maximum_msat_impl(that, counterparty_outbound_htlc_maximum_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat(
        that: usize,
        counterparty_outbound_htlc_minimum_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_outbound_htlc_minimum_msat_impl(that, counterparty_outbound_htlc_minimum_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve(
        that: usize,
        counterparty_unspendable_punishment_reserve: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_counterparty_unspendable_punishment_reserve_impl(that, counterparty_unspendable_punishment_reserve)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight(
        that: usize,
        feerate_sat_per_1000_weight: u32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_feerate_sat_per_1000_weight_impl(
            that,
            feerate_sat_per_1000_weight,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_force_close_spend_delay(
        that: usize,
        force_close_spend_delay: *mut u16,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_force_close_spend_delay_impl(
            that,
            force_close_spend_delay,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_funding_txo(
        that: usize,
        funding_txo: *mut wire_cst_out_point,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_funding_txo_impl(
            that,
            funding_txo,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_capacity_msat(
        that: usize,
        inbound_capacity_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_capacity_msat_impl(
            that,
            inbound_capacity_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat(
        that: usize,
        inbound_htlc_maximum_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_maximum_msat_impl(
            that,
            inbound_htlc_maximum_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat(
        that: usize,
        inbound_htlc_minimum_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_inbound_htlc_minimum_msat_impl(
            that,
            inbound_htlc_minimum_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_channel_ready(
        that: usize,
        is_channel_ready: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_channel_ready_impl(
            that,
            is_channel_ready,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_outbound(
        that: usize,
        is_outbound: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_outbound_impl(
            that,
            is_outbound,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_usable(
        that: usize,
        is_usable: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_is_usable_impl(that, is_usable)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat(
        that: usize,
        next_outbound_htlc_limit_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_limit_msat_impl(that, next_outbound_htlc_limit_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat(
        that: usize,
        next_outbound_htlc_minimum_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_next_outbound_htlc_minimum_msat_impl(that, next_outbound_htlc_minimum_msat)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_outbound_capacity_msat(
        that: usize,
        outbound_capacity_msat: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_outbound_capacity_msat_impl(
            that,
            outbound_capacity_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_unspendable_punishment_reserve(
        that: usize,
        unspendable_punishment_reserve: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_unspendable_punishment_reserve_impl(that, unspendable_punishment_reserve)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_user_channel_id(
        that: usize,
        user_channel_id: wire_cst_user_channel_id,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__ChannelDetails_auto_accessor_set_user_channel_id_impl(
            that,
            user_channel_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_channel(
        port_: i64,
        that: usize,
        short_channel_id: u64,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_channel_impl(port_, that, short_channel_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_list_channels(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_list_channels_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_list_nodes(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_list_nodes_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__graph__NetworkGraph_node(
        port_: i64,
        that: usize,
        node_id: *mut wire_cst_node_id,
    ) {
        wire__ldk_adapter__graph__NetworkGraph_node_impl(port_, that, node_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_bolt11_payment(
        port_: i64,
        ptr: usize,
    ) {
        wire__ldk_adapter__node__Node_bolt11_payment_impl(port_, ptr)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_bolt12_payment(
        port_: i64,
        ptr: usize,
    ) {
        wire__ldk_adapter__node__Node_bolt12_payment_impl(port_, ptr)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_close_channel(
        port_: i64,
        that: usize,
        user_channel_id: *mut wire_cst_user_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
    ) {
        wire__ldk_adapter__node__Node_close_channel_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_config(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_config_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_connect(
        port_: i64,
        that: usize,
        node_id: *mut wire_cst_public_key,
        address: usize,
        persist: bool,
    ) {
        wire__ldk_adapter__node__Node_connect_impl(port_, that, node_id, address, persist)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_disconnect(
        port_: i64,
        that: usize,
        counterparty_node_id: *mut wire_cst_public_key,
    ) {
        wire__ldk_adapter__node__Node_disconnect_impl(port_, that, counterparty_node_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_event_handled(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_event_handled_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_export_pathfinding_scores(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_export_pathfinding_scores_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_force_close_channel(
        port_: i64,
        that: usize,
        user_channel_id: *mut wire_cst_user_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
    ) {
        wire__ldk_adapter__node__Node_force_close_channel_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_balances(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_balances_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_channels(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_channels_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_payments(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_payments_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_payments_with_filter(
        port_: i64,
        that: usize,
        payment_direction: i32,
    ) {
        wire__ldk_adapter__node__Node_list_payments_with_filter_impl(port_, that, payment_direction)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_list_peers(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_list_peers_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_listening_addresses(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_listening_addresses_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_network_graph(
        port_: i64,
        ptr: usize,
    ) {
        wire__ldk_adapter__node__Node_network_graph_impl(port_, ptr)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_next_event(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_next_event_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_next_event_async(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_next_event_async_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_node_id(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_node_id_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_on_chain_payment(
        port_: i64,
        ptr: usize,
    ) {
        wire__ldk_adapter__node__Node_on_chain_payment_impl(port_, ptr)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_open_announced_channel(
        port_: i64,
        that: usize,
        socket_address: usize,
        node_id: *mut wire_cst_public_key,
        channel_amount_sats: u64,
        push_to_counterparty_msat: *mut u64,
        channel_config: *mut usize,
    ) {
        wire__ldk_adapter__node__Node_open_announced_channel_impl(
            port_,
            that,
            socket_address,
            node_id,
            channel_amount_sats,
            push_to_counterparty_msat,
            channel_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_open_channel(
        port_: i64,
        that: usize,
        socket_address: usize,
        node_id: *mut wire_cst_public_key,
        channel_amount_sats: u64,
        push_to_counterparty_msat: *mut u64,
        channel_config: *mut usize,
    ) {
        wire__ldk_adapter__node__Node_open_channel_impl(
            port_,
            that,
            socket_address,
            node_id,
            channel_amount_sats,
            push_to_counterparty_msat,
            channel_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_payment(
        port_: i64,
        that: usize,
        payment_id: *mut wire_cst_payment_id,
    ) {
        wire__ldk_adapter__node__Node_payment_impl(port_, that, payment_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_remove_payment(
        port_: i64,
        that: usize,
        payment_id: *mut wire_cst_payment_id,
    ) {
        wire__ldk_adapter__node__Node_remove_payment_impl(port_, that, payment_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_sign_message(
        port_: i64,
        that: usize,
        msg: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__ldk_adapter__node__Node_sign_message_impl(port_, that, msg)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_spontaneous_payment(
        port_: i64,
        ptr: usize,
    ) {
        wire__ldk_adapter__node__Node_spontaneous_payment_impl(port_, ptr)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_start(port_: i64, that: usize) {
        wire__ldk_adapter__node__Node_start_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_status(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_status_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_stop(port_: i64, that: usize) {
        wire__ldk_adapter__node__Node_stop_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_sync_wallets(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_sync_wallets_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_unified_qr_payment(
        port_: i64,
        ptr: usize,
    ) {
        wire__ldk_adapter__node__Node_unified_qr_payment_impl(port_, ptr)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_update_channel_config(
        port_: i64,
        that: usize,
        user_channel_id: *mut wire_cst_user_channel_id,
        counterparty_node_id: *mut wire_cst_public_key,
        channel_config: usize,
    ) {
        wire__ldk_adapter__node__Node_update_channel_config_impl(
            port_,
            that,
            user_channel_id,
            counterparty_node_id,
            channel_config,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_verify_signature(
        port_: i64,
        that: usize,
        msg: *mut wire_cst_list_prim_u_8_loose,
        sig: *mut wire_cst_list_prim_u_8_strict,
        public_key: *mut wire_cst_public_key,
    ) {
        wire__ldk_adapter__node__Node_verify_signature_impl(port_, that, msg, sig, public_key)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__node__Node_wait_next_event(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__node__Node_wait_next_event_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__on_chain__OnChainPayment_new_address(
        port_: i64,
        that: usize,
    ) {
        wire__ldk_adapter__on_chain__OnChainPayment_new_address_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__on_chain__OnChainPayment_send_all_to_address(
        port_: i64,
        that: usize,
        address: usize,
        retain_reserves: bool,
        fee_rate_sat_per_kwu: *mut u64,
    ) {
        wire__ldk_adapter__on_chain__OnChainPayment_send_all_to_address_impl(
            port_,
            that,
            address,
            retain_reserves,
            fee_rate_sat_per_kwu,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__on_chain__OnChainPayment_send_to_address(
        port_: i64,
        that: usize,
        address: usize,
        amount_sats: u64,
        fee_rate_sat_per_kwu: *mut u64,
    ) {
        wire__ldk_adapter__on_chain__OnChainPayment_send_to_address_impl(
            port_,
            that,
            address,
            amount_sats,
            fee_rate_sat_per_kwu,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_amount_msat(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_amount_msat_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_direction(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_direction_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_kind(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_kind_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_latest_update_timestamp(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_latest_update_timestamp_impl(
            that,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_status(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_get_status_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_amount_msat(
        that: usize,
        amount_msat: *mut u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_amount_msat_impl(
            that,
            amount_msat,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_direction(
        that: usize,
        direction: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_direction_impl(that, direction)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_id(
        that: usize,
        id: wire_cst_payment_id,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_id_impl(that, id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_kind(
        that: usize,
        kind: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_kind_impl(that, kind)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_latest_update_timestamp(
        that: usize,
        latest_update_timestamp: u64,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_latest_update_timestamp_impl(
            that,
            latest_update_timestamp,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_status(
        that: usize,
        status: i32,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PaymentDetails_auto_accessor_set_status_impl(that, status)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_get_address(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_get_address_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_get_is_connected(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_get_is_connected_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_get_node_id(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_get_node_id_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_set_address(
        that: usize,
        address: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_set_address_impl(that, address)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_set_is_connected(
        that: usize,
        is_connected: bool,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_set_is_connected_impl(
            that,
            is_connected,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__PeerDetails_auto_accessor_set_node_id(
        that: usize,
        node_id: wire_cst_public_key,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__ldk_adapter__types__PeerDetails_auto_accessor_set_node_id_impl(that, node_id)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__spontaneous__SpontaneousPayment_send_probes_unsafe(
        port_: i64,
        that: usize,
        amount_msat: u64,
        node_id: *mut wire_cst_public_key,
    ) {
        wire__ldk_adapter__spontaneous__SpontaneousPayment_send_probes_unsafe_impl(
            port_,
            that,
            amount_msat,
            node_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__spontaneous__SpontaneousPayment_send_unsafe(
        port_: i64,
        that: usize,
        amount_msat: u64,
        node_id: *mut wire_cst_public_key,
        sending_parameters: *mut wire_cst_sending_parameters,
    ) {
        wire__ldk_adapter__spontaneous__SpontaneousPayment_send_unsafe_impl(
            port_,
            that,
            amount_msat,
            node_id,
            sending_parameters,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__spontaneous__SpontaneousPayment_send_with_custom_tlvs_unsafe(
        port_: i64,
        that: usize,
        amount_msat: u64,
        node_id: *mut wire_cst_public_key,
        sending_parameters: *mut wire_cst_sending_parameters,
        custom_tlvs: *mut wire_cst_list_custom_tlv_record,
    ) {
        wire__ldk_adapter__spontaneous__SpontaneousPayment_send_with_custom_tlvs_unsafe_impl(
            port_,
            that,
            amount_msat,
            node_id,
            sending_parameters,
            custom_tlvs,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__TaprootSpendInfo_auto_accessor_get_inner(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__TaprootSpendInfo_auto_accessor_get_inner_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__TaprootSpendInfo_auto_accessor_set_inner(
        that: usize,
        inner: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__TaprootSpendInfo_auto_accessor_set_inner_impl(that, inner)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_auto_accessor_get_inner(
        that: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__Transaction_auto_accessor_get_inner_impl(that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_auto_accessor_set_inner(
        that: usize,
        inner: usize,
    ) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
        wire__shared__Transaction_auto_accessor_set_inner_impl(that, inner)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_compute_txid(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_compute_txid_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_compute_wtxid(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_compute_wtxid_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_input(port_: i64, that: usize) {
        wire__shared__Transaction_input_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_is_coinbase(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_is_coinbase_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_is_explicitly_rbf(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_is_explicitly_rbf_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_is_lock_time_enabled(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_is_lock_time_enabled_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_lock_time(port_: i64, that: usize) {
        wire__shared__Transaction_lock_time_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_new(
        port_: i64,
        transaction_bytes: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__shared__Transaction_new_impl(port_, transaction_bytes)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_output(port_: i64, that: usize) {
        wire__shared__Transaction_output_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_total_size(
        port_: i64,
        that: usize,
    ) {
        wire__shared__Transaction_total_size_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_version(port_: i64, that: usize) {
        wire__shared__Transaction_version_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_vsize(port_: i64, that: usize) {
        wire__shared__Transaction_vsize_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__Transaction_weight(port_: i64, that: usize) {
        wire__shared__Transaction_weight_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__unified_qr__UnifiedQrPayment_receive(
        port_: i64,
        that: usize,
        amount_sats: u64,
        message: *mut wire_cst_list_prim_u_8_strict,
        expiry_sec: u32,
    ) {
        wire__ldk_adapter__unified_qr__UnifiedQrPayment_receive_impl(
            port_,
            that,
            amount_sats,
            message,
            expiry_sec,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__unified_qr__UnifiedQrPayment_send(
        port_: i64,
        that: usize,
        uri_str: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__ldk_adapter__unified_qr__UnifiedQrPayment_send_impl(port_, that, uri_str)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__anchor_channels_config_default(
        port_: i64,
    ) {
        wire__ldk_adapter__types__anchor_channels_config_default_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__ldk_adapter__types__config_default(port_: i64) {
        wire__ldk_adapter__types__config_default_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_as_string(
        port_: i64,
        that: *mut wire_cst_mnemonic,
    ) {
        wire__shared__mnemonic_as_string_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_from_entropy(
        port_: i64,
        entropy: *mut wire_cst_list_prim_u_8_loose,
    ) {
        wire__shared__mnemonic_from_entropy_impl(port_, entropy)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_generate(port_: i64) {
        wire__shared__mnemonic_generate_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__mnemonic_to_seed(
        port_: i64,
        that: *mut wire_cst_mnemonic,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__shared__mnemonic_to_seed_impl(port_, that, passphrase)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__psbt_extract_tx(
        port_: i64,
        that: *mut wire_cst_psbt,
    ) {
        wire__shared__psbt_extract_tx_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__psbt_fee(port_: i64, that: *mut wire_cst_psbt) {
        wire__shared__psbt_fee_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_wire__shared__psbt_from_base64(
        port_: i64,
        base64: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__shared__psbt_from_base64_impl(port_, base64)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressData(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAddressData(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AddressData>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddress>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinAddressInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinAddressInner>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinTransactionInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
            >::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBitcoinTransactionInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BitcoinTransactionInner>,
            >::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt11Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt11Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt11Payment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt12Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBolt12Payment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Bolt12Payment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBuilder(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Builder>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChainDataSourceConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChainDataSourceConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChainDataSourceConfig>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelDetails>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEntropySourceConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEntropySourceConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EntropySourceConfig>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Event>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGossipSourceConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGossipSourceConfig(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GossipSourceConfig>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LightningBalance>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaxDustHTLCExposure(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMaxDustHTLCExposure(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MaxDustHTLCExposure>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNetworkGraph(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNetworkGraph(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NetworkGraph>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNode(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNode(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Node>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnChainPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOnChainPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OnChainPayment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentDetails>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentKind(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentKind(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PaymentKind>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerDetails>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PendingSweepBalance>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPaymentResult(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerQrPaymentResult(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QrPaymentResult>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SocketAddress>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSpontaneousPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSpontaneousPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SpontaneousPayment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfo(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfo(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfo>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfoInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTaprootSpendInfoInner(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TaprootSpendInfoInner>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTransaction(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Transaction>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnifiedQrPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>::increment_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUnifiedQrPayment(
        ptr: *const std::ffi::c_void,
    ) {
        unsafe {
            StdArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<UnifiedQrPayment>>::decrement_strong_count(ptr as _);
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChainDataSourceConfig(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelConfig(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEntropySourceConfig(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEvent(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGossipSourceConfig(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails(
        value: usize,
    ) -> *mut usize {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_anchor_channels_config(
    ) -> *mut wire_cst_anchor_channels_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_anchor_channels_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_bolt_11_invoice(
    ) -> *mut wire_cst_bolt_11_invoice {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_bolt_11_invoice::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_channel_info(
    ) -> *mut wire_cst_channel_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_channel_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_channel_update_info(
    ) -> *mut wire_cst_channel_update_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_channel_update_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_config() -> *mut wire_cst_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_config::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_ffi_log_record(
    ) -> *mut wire_cst_ffi_log_record {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_ffi_log_record::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_liquidity_source_config(
    ) -> *mut wire_cst_liquidity_source_config {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_liquidity_source_config::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_log_level(value: i32) -> *mut i32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_mnemonic() -> *mut wire_cst_mnemonic {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_mnemonic::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_alias() -> *mut wire_cst_node_alias {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_node_alias::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_announcement_info(
    ) -> *mut wire_cst_node_announcement_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_node_announcement_info::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_id() -> *mut wire_cst_node_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_node_id::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_node_info() -> *mut wire_cst_node_info {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_node_info::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_offer() -> *mut wire_cst_offer {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_offer::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_out_point() -> *mut wire_cst_out_point {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_out_point::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_hash(
    ) -> *mut wire_cst_payment_hash {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_hash::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_id() -> *mut wire_cst_payment_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_id::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_payment_preimage(
    ) -> *mut wire_cst_payment_preimage {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_payment_preimage::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_psbt() -> *mut wire_cst_psbt {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_psbt::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_public_key() -> *mut wire_cst_public_key {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_public_key::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_refund() -> *mut wire_cst_refund {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_refund::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_script_buf() -> *mut wire_cst_script_buf {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_script_buf::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_sending_parameters(
    ) -> *mut wire_cst_sending_parameters {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_sending_parameters::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_16(value: u16) -> *mut u16 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_32(value: u32) -> *mut u32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_64(value: u64) -> *mut u64 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_u_8(value: u8) -> *mut u8 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_box_autoadd_user_channel_id(
    ) -> *mut wire_cst_user_channel_id {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_user_channel_id::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress(len: i32) -> *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress{
        let wrap = wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress { ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len), len };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_String(len: i32) -> *mut wire_cst_list_String {
        let wrap = wire_cst_list_String {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_custom_tlv_record(
        len: i32,
    ) -> *mut wire_cst_list_custom_tlv_record {
        let wrap = wire_cst_list_custom_tlv_record {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_custom_tlv_record>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_list_prim_u_8_strict {
        let wrap = wire_cst_list_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_node_id(len: i32) -> *mut wire_cst_list_node_id {
        let wrap = wire_cst_list_node_id {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_node_id>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_64_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_64_strict {
        let ans = wire_cst_list_prim_u_64_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_8_loose(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_loose {
        let ans = wire_cst_list_prim_u_8_loose {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_public_key(
        len: i32,
    ) -> *mut wire_cst_list_public_key {
        let wrap = wire_cst_list_public_key {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_public_key>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_record_string_string(
        len: i32,
    ) -> *mut wire_cst_list_record_string_string {
        let wrap = wire_cst_list_record_string_string {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_record_string_string>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_tx_in(len: i32) -> *mut wire_cst_list_tx_in {
        let wrap = wire_cst_list_tx_in {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx_in>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ldk_node_cst_new_list_tx_out(len: i32) -> *mut wire_cst_list_tx_out {
        let wrap = wire_cst_list_tx_out {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
                <wire_cst_tx_out>::new_with_null_ptr(),
                len,
            ),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_anchor_channels_config {
        trusted_peers_no_reserve: *mut wire_cst_list_public_key,
        per_channel_reserve_sats: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_balance_details { total_onchain_balance_sats: u64,
spendable_onchain_balance_sats: u64,
total_lightning_balance_sats: u64,
lightning_balances: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance,
pending_balances_from_channel_closures: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_best_block {
        block_hash: *mut wire_cst_list_prim_u_8_strict,
        height: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bolt_11_invoice {
        signed_raw_invoice: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_bolt_12_invoice {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_id {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_info {
        node_one: wire_cst_node_id,
        one_to_two: *mut wire_cst_channel_update_info,
        node_two: wire_cst_node_id,
        two_to_one: *mut wire_cst_channel_update_info,
        capacity_sats: *mut u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_channel_update_info {
        last_update: u32,
        enabled: bool,
        cltv_expiry_delta: u16,
        htlc_minimum_msat: u64,
        htlc_maximum_msat: u64,
        fees: wire_cst_routing_fees,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_config { storage_dir_path: *mut wire_cst_list_prim_u_8_strict,
network: i32,
listening_addresses: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress,
announcement_addresses: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress,
node_alias: *mut wire_cst_node_alias,
trusted_peers_0conf: *mut wire_cst_list_public_key,
probing_liquidity_limit_multiplier: u64,
anchor_channels_config: *mut wire_cst_anchor_channels_config,
sending_parameters: *mut wire_cst_sending_parameters }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_custom_tlv_record {
        type_num: u64,
        value: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_ffi_log_record {
        level: i32,
        args: *mut wire_cst_list_prim_u_8_strict,
        module_path: *mut wire_cst_list_prim_u_8_strict,
        line: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_liquidity_source_config { lsps2_service: wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_public_key_opt_string }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerChannelDetails
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerLightningBalance
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPaymentDetails
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPeerDetails
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPendingSweepBalance
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress
    {
        ptr: *mut usize,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_String {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_custom_tlv_record {
        ptr: *mut wire_cst_custom_tlv_record,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_list_prim_u_8_strict {
        ptr: *mut *mut wire_cst_list_prim_u_8_strict,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_node_id {
        ptr: *mut wire_cst_node_id,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_64_strict {
        ptr: *mut u64,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_loose {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_public_key {
        ptr: *mut wire_cst_public_key,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_record_string_string {
        ptr: *mut wire_cst_record_string_string,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx_in {
        ptr: *mut wire_cst_tx_in,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_tx_out {
        ptr: *mut wire_cst_tx_out,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_mnemonic {
        words: *mut wire_cst_list_String,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_alias {
        field0: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_announcement_info { last_update: u32,
alias: *mut wire_cst_list_prim_u_8_strict,
addresses: *mut wire_cst_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSocketAddress }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_id {
        compressed: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_info {
        channels: *mut wire_cst_list_prim_u_64_strict,
        announcement_info: *mut wire_cst_node_announcement_info,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_node_status {
        is_running: bool,
        is_listening: bool,
        current_best_block: wire_cst_best_block,
        latest_lightning_wallet_sync_timestamp: *mut u64,
        latest_onchain_wallet_sync_timestamp: *mut u64,
        latest_fee_rate_cache_update_timestamp: *mut u64,
        latest_rgs_snapshot_timestamp: *mut u64,
        latest_node_announcement_broadcast_timestamp: *mut u64,
        latest_channel_monitor_archival_height: *mut u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_offer {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_out_point {
        txid: wire_cst_txid,
        vout: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_hash {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_id {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_payment_preimage {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_psbt {
        inner: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_public_key {
        hex: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_socket_address_public_key_opt_string
    {
        field0: usize,
        field1: wire_cst_public_key,
        field2: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_record_string_string {
        field0: *mut wire_cst_list_prim_u_8_strict,
        field1: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_refund {
        s: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_routing_fees {
        base_msat: u32,
        proportional_millionths: u32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_script_buf {
        inner: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sending_parameters {
        max_total_routing_fee_msat: *mut u64,
        max_total_cltv_expiry_delta: *mut u32,
        max_path_count: *mut u8,
        max_channel_saturation_power_of_half: *mut u8,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_in {
        previous_output: wire_cst_out_point,
        script_sig: wire_cst_script_buf,
        sequence: u32,
        witness: *mut wire_cst_list_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_out {
        value: u64,
        script_pubkey: wire_cst_script_buf,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_txid {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_user_channel_id {
        data: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_w_txid {
        hash: *mut wire_cst_list_prim_u_8_strict,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;
